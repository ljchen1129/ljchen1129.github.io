<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS 基于 launchctl + fastlane + 钉钉机器人实现定时自动打包]]></title>
    <url>%2F2020%2F01%2F22%2FiOS-%E5%9F%BA%E4%BA%8E-launchctl-fastlane-%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言作为一个移动端程序员，每次 feature add 或者 bug fix 后经常要打包交付给 QA，以前传统的操作都是手动点击 Xcode -&gt; Product -&gt; Archive -&gt; Organizer -&gt; Distrubute App -&gt; ipa 上传到第三方内测分发平台（蒲公英、fir）-&gt; 手动填写更新日志 -&gt; 发送安装链接到部门群（钉钉或者企业微信），看起来好像很机械和繁琐，又没啥技术含量是吧…… 如果能把这部分工作给自动化了就好了，每天可以省一点时间出来发呆也挺好的。需求整理一下大概是这样： 能够定时触发； 自动打包； 自动读取某个时间段内的 git commit messge 信息当做更新日志； 打包完成自动发送安装链接到部门群（钉钉或者企业微信）； 实现需求一、定时任务调研了一下，Mac OS 可以基于 launchctl 来配置定时任务。可以配置到不同级别的 LaunchAgents 下，几种的区别如下： 12345~/Library/LaunchAgents 由用户自己定义的任务项/Library/LaunchAgents 由管理员为用户定义的任务项/Library/LaunchDaemons 由管理员定义的守护进程任务项/System/Library/LaunchAgents 由Mac OS X为用户定义的任务项/System/Library/LaunchDaemons 由Mac OS X定义的守护进程任务项 我们配置在用户目录下就行，也就是这个目录 ~/Library/LaunchAgents，按照固定的格式新建一个 Plist 文件就行，可以看到已经有一些第三方的任务在这里了: 我的配置文件是这样： 123456789101112131415161718192021222324252627282930313233343536373839&lt;plist version="1.0"&gt;&lt;dict&gt; &lt;!-- Label唯一的标识 --&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.autoArchiveTask.plist&lt;/string&gt; &lt;key&gt;Program&lt;/key&gt; &lt;string&gt;/Users/username/Desktop/code/Project/run.sh&lt;/string&gt; &lt;!-- 指定要运行的脚本 --&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/Users/username/Desktop/code/Project/run.sh&lt;/string&gt; &lt;/array&gt; &lt;!-- 指定要运行的时间 --&gt; &lt;key&gt;StartCalendarInterval&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;Minute&lt;/key&gt; &lt;integer&gt;00&lt;/integer&gt; &lt;key&gt;Hour&lt;/key&gt; &lt;integer&gt;11&lt;/integer&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;Minute&lt;/key&gt; &lt;integer&gt;00&lt;/integer&gt; &lt;key&gt;Hour&lt;/key&gt; &lt;integer&gt;16&lt;/integer&gt; &lt;/dict&gt; &lt;/array&gt;&lt;!-- 标准输出文件 --&gt;&lt;key&gt;StandardOutPath&lt;/key&gt;&lt;string&gt;/Users/username/Desktop/code/Project/run.log&lt;/string&gt;&lt;!-- 标准错误输出文件，错误日志 --&gt;&lt;key&gt;StandardErrorPath&lt;/key&gt;&lt;string&gt;/Users/username/Desktop/code/Project/run.error&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 相关字段的解释如下： Label：对应的需要保证全局唯一性； Program：要运行脚本； ProgramArguments：指定要运行的脚本； StartCalendarInterval：运行的时间，单个时间点使用 dict，多个时间点使用 array StartInterval：时间间隔，与 StartCalendarInterval 使用其一，单位为秒 StandardInPath、StandardOutPath、StandardErrorPath：标准的输入、输出、错误文件 配置好了就可以加载了，加载后就生效了，相关的命令如下： 1234567891011# 加载任务, -w选项会将 plist 文件中无效的 key 覆盖掉，建议加上launchctl load -w xxx.plist# 删除任务launchctl unload -w xxx.plist# 查看任务列表, 使用 grep '任务部分名字' 过滤launchctl list | grep 'xxx'# 立即执行一次任务，可用来测试launchctl start xxx.plist 需求二、自动打包这个使用 fastlane 就行，很好很强大。相关的配置可参见官网，建议使用 brew 方式安装。配置安装文档就行， 由于我这个是多 target 工程，所以我这边的可能多一点配置，我的 Fastfile 文件配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788default_platform(:ios)# 网络请求依赖require 'net/http'require 'uri'require 'json' platform :ios do desc "发布app到 App Store 或者 Fir.im " lane :customer_hoc do # add actions here: https://docs.fastlane.tools/actions sh "fastlane adhoc --env Customer" end desc "发布app到 App Store 或者 Fir.im " lane :driver_hoc do # add actions here: https://docs.fastlane.tools/actions sh "fastlane adhoc --env Driver" end desc "发布指定Target到 Fir.im" lane :adhoc do gym( clean:true, #打包前clean项目 workspace: "Hedgehog.xcworkspace", export_method: "ad-hoc", #导出方式 scheme: ENV['SCHEME_NAME'], #scheme output_name: ENV['SCHEME_NAME']+".ipa", # ipa 文件名 output_directory: "./ipa", #ipa的存放目录 export_options: &#123; provisioningProfiles: &#123; "cn.ccmore.hedgehog.customer"=&gt;"CustomerAdhoc", "cn.ccmore.hedgehog.driver"=&gt;"DricerAdhoc" &#125; &#125; ) # 前往fir.im获取 api token, 将鼠标放置右上角账号上面, 在下拉窗选择API token # 若使用的蒲公英, 请前往 https://www.pgyer.com/ 查看上传方法 # 如果使用Firimfile, 此处为 firim 即可 firim(firim_api_token:'xxxx') # 钉钉机器人 app_patch = "ipa/" + ENV['SCHEME_NAME']+".ipa" app_version = get_ipa_info_plist_value(ipa: app_patch, key: "CFBundleShortVersionString") app_build_version = get_ipa_info_plist_value(ipa: app_patch, key: "CFBundleVersion") app_name = get_ipa_info_plist_value(ipa: app_patch, key: "CFBundleDisplayName") # 根据 SCHEME_NAME 区分下载链接 app_url = "https://fir.im/6udv" if ENV['SCHEME_NAME'] == "Driver" then app_url = "https://fir.im/sa4q" end app_icon = "./Hedgehog/ipa/icons/57.png" dingTalk_url = "https://oapi.dingtalk.com/robot/send?access_token=xxx" markdown = &#123; msgtype: "link", link: &#123; text: "iOS #&#123;ENV['SCHEME_NAME']&#125; 更新了！！！", title: "iOS #&#123;ENV['SCHEME_NAME']&#125; #&#123;app_version&#125; (#&#123;app_build_version&#125;) 内测版", picUrl: "#&#123;app_icon&#125;", messageUrl: "#&#123;app_url&#125;" &#125; &#125; uri = URI.parse(dingTalk_url) https = Net::HTTP.new(uri.host, uri.port) https.use_ssl = true request = Net::HTTP::Post.new(uri.request_uri) request.add_field('Content-Type', 'application/json') request.body = markdown.to_json response = https.request(request) puts "------------------------------" puts "Response #&#123;response.code&#125; #&#123;response.message&#125;: #&#123;response.body&#125;" end end 上传到第三方内测平台（蒲公英、fir等）Fastlane 也有相关的插件，一行代码搞定，如 Fir 就是： 1234# 前往fir.im获取 api token, 将鼠标放置右上角账号上面, 在下拉窗选择API token# 若使用的蒲公英, 请前往 https://www.pgyer.com/ 查看上传方法# 如果使用Firimfile, 此处为 firim 即可firim(firim_api_token:'xxxx') 需求三、读取 git commit messgeTODO: 等待实现。 需求四、自动发送安装消息我这边目前使用的钉钉进行协作，可以在相关工作群使用钉钉机器人自动发送消息。找钉钉群管理员添加一下获取 token 就行。可以向这个地址 https://oapi.dingtalk.com/robot/send?access_token=Your Token 发送纯文本、图文、markdown 等格式的消息，还可以填写需要 @ 的测试妹子们。 其他企业微信好像也是可以的，可以自行去查看文档。 踩坑一、定时脚本执行 /bin/sh: xxx/run.sh: Operation not permitted原因： 首先我配置的定时脚本路径在 /Users/username/Desktop/code/Project/run.sh，没有和定时任务的 Plist 配置文件在一个目录下，而配置的定时脚本声明的是 #!/bin/sh，意思是使用 /bin/sh 来解释执行，但是却没有给完全磁盘访问的权限。 解决方案：给足访问权限就行。系统偏好设置 -&gt; 安全性与隐私-&gt; 完全磁盘访问权限，查看是否有勾选☑️ 在定时脚本中声明的解释执行的 shell 的路径，就是#!/bin/ 后面接的，有 bash 、sh、 zsh 等，我的是 sh。没有的话就添加进去。 二、在定时脚本中直接执行 fastlane 打包命令出错： /Users/username/Desktop/code/Project/run.sh ： fastlane: command not found原因：虽然 cd 到了当前项目目录，但还是报 fastlane 找不到 解决方案：使用全路径 fastlane 执行命令 1/Users/username/.fastlane/bin/fastlane lane 总结总共折腾了一两天时间，流程基本都跑通了，还剩抓取指定时间段内的 git commit message 当做更新日志的 TODO，总体上还是很愉悦和有成就感的，以后就可以专心干其他的事情了，打包几乎无感，也不用怕忘记。nice！ 效果如下： 相关配置文件已经上传到 GitHub 仓库，地址点击这里。 参考链接 Mac上，执行定时任务：launchctl Operation not permitted Fastlane 钉钉开发文档 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「by在水一方」。]]></content>
      <categories>
        <category>软件工程</category>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 源代码是怎样成为 App 的]]></title>
    <url>%2F2019%2F10%2F28%2FiOS-%E6%BA%90%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E6%A0%B7%E6%88%90%E4%B8%BA-App-%E7%9A%84%2F</url>
    <content type="text"><![CDATA[前言这篇文章想要探究一下在 iOS 开发中，iOS 源代码是怎样变成用户手机上的一个个 App 的，Xcode 里面 Command + B 具体发生了什么？ 我想可以分为两个部分，第一个部分是 iOS 源代码是怎样打包上架市场并安装到到用户手机上的，第二部分是用户当点击 App Icon 到 App 启动经历了哪些过程？ 基础知识编程语言分类编程语言按照不同的角度可以有不同的分类。 按与硬件的距离分： 机器语言：根据硬件指令集的 0101 汇编语言：对机器语言做了简单的封装 高级语言：C/C++/Java/Python/JavaScript/Swift 等 按编程范式分： 面向过程： C 面向对象： C++/Java 函数式 现在的很多高级语言都具备多种编程范式。 按是否需要编译分： 编译型语言 Compiled Language，编译后可直接执行，执行效率高 C/C++/Objective-C/Swift（不依赖虚拟机） Java (依赖虚拟机)，Java 源代码会先编译成为 .class（字节码）文件，再经过 JVM 一行一行的解释执行 解释型语言 Interpreted Language，也叫脚本语言 Scripting Language，运行在解释器上，解释一行代码，执行一行，执行效率相对编译型语言更低，但容易移植 Python/Ruby/JavaScript Swift 是一门编译型语言，编译型语言的源代码要运行，首先是需要编译器（Complier）把源文件进行编译成目标文件，然后经过链接器（Linker）链接后才能够执行的。这篇主要记录的是 Swift 代码的编译过程。 LLVM 编译器架构 Frontend 前端 词法分析、语法分析、语义分析、生成中间代码 Optimizer 优化器 中间代码优化 Backend 后端 生成不同硬件平台的机器码 LLVM 编译器三层式的架构，前后端依赖统一格式的中间代码(IR)，使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。 Objective C/C/C++使用的编译器前端是clang，swift是swift，后端都是LLVM。 第一部分：源代码 -&gt; App 阶段Hello World先来看程序员都会写的第一行代码 hello world!，先看一下这行代码是如何变成可执行文件的，在终端打印出 Hello, World 123456#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; printf("Hello, World!\n"); return 0;&#125; 1. 预编译12# 使用 gcc 编译器编译这个文件，-E 表示只进行预编译gcc -E main.c -o main.i 预编译阶段主要是处理源代码中以 # 号开始的预编译指令，如 #include、#define等，主要的规则有： 删除所有#define ，展开所有宏定义 处理条件编译，如 #if、#ifdef、#elif、 #else、#endif 等 处理 #include 指令，递归地将被包含的文件插入到该预编译指令的位置 删除所有的注释 添加行号和文件名标识 保留所有 #pragma 预编译指令 2. 编译12345678910111213141516171819202122232425262728293031323334353637# 将预编译后的源代码编译成汇编代码gcc -S main.i -o main.s # 生成的汇编代码文件main.s .section __TEXT,__text,regular,pure_instructions .build_version macos, 10, 15 sdk_version 10, 15 .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $32, %rsp movl $0, -4(%rbp) movl %edi, -8(%rbp) movq %rsi, -16(%rbp) leaq L_.str(%rip), %rdi movb $0, %al callq _printf xorl %ecx, %ecx movl %eax, -20(%rbp) ## 4-byte Spill movl %ecx, %eax addq $32, %rsp popq %rbp retq .cfi_endproc ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz &quot;Hello, World!\n&quot;.subsections_via_symbols 3. 汇编这个阶段由汇编器将汇编代码 main.s 变成机器指令，即生成目标文件 main.o 12# 生成目标文件 main.ogcc -c main.s -o main.o 4. 链接123456789# clang 编译器前端链接main.o，生成一个 a.out 可执行文件clang main.o➜ HelloWorld lsa.out main.c main.i main.o main.s# 执行➜ HelloWorld ./a.out Hello, World! 编译上面只是简单的描述了一下程序员的第一行代码 Hello World 程序是怎样变成可执行文件的，其实在编译和链接阶段还有着更复杂更细致的操作，如在编译阶段就有词法分析、语法分析、语义分析、中间语言生成、目标代码生成和优化过程。 123456789# 查看用 clang 编译源代码的过程➜ HelloWorld clang -ccc-print-phases main.c 0: input, "main.c", c # 输入1: preprocessor, &#123;0&#125;, cpp-output # 预处理 -&gt; 输出 cpp 文件 .cpp2: compiler, &#123;1&#125;, ir # 编译 -&gt; 输出中间代码 3: backend, &#123;2&#125;, assembler # 编译器后端将中间代码转成汇编代码 -&gt; 输出汇编代码 4: assembler, &#123;3&#125;, object # 汇编器，将汇编代码转成机器代码 -&gt; 输出目标文件代码 .o5: linker, &#123;4&#125;, image # 链接器，生成机器无关的二进制代码 -&gt; 输出机器无关二进制代码6: bind-arch, "x86_64", &#123;5&#125;, image # 绑定机器架构，生成具体机器的二进制代码 -&gt; 输出具体机型二进制代码 下面就写一段简单的两数求和的加法代码来分析一下： 12345678int sum(int a, int b) &#123; return a + b;&#125;int main(int argc, const char * argv[]) &#123; int result = sum(1, 2); return 0;&#125; 词法分析词法分析就是将源代码的字符序列使用一个叫做 lex 的程序运用一种类似于有限状态机的算法（Finite Source Machine）分割成一系列的记号（token）的过程。 产生的 token 一般可以分为以下几类：关键字、标识符、字面量（数字、字符串）、特殊符号。在识别记号 token 的同时，也会将标识符放到符号表、将数字、字符串常量放到文字表等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 使用 clang 对 main.c 源代码只进行词法分析xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c# 输出结果annot_module_include '#include &lt;stdio.h&gt;int sum(int a, int b) &#123; return a + b;&#125;int main(int argc, const char * argv[]) &#123; int result = sum(1, 2);' Loc=&lt;main.c:9:1&gt; // 标识位于源文件的第 9 行，从第 1 个字符开始int 'int' [StartOfLine] Loc=&lt;main.c:11:1&gt; // 标识位于源文件的第 11 行，从第 1 个字符开始identifier 'sum' [LeadingSpace] Loc=&lt;main.c:11:5&gt;l_paren '(' Loc=&lt;main.c:11:8&gt;int 'int' Loc=&lt;main.c:11:9&gt;identifier 'a' [LeadingSpace] Loc=&lt;main.c:11:13&gt;comma ',' Loc=&lt;main.c:11:14&gt;int 'int' [LeadingSpace] Loc=&lt;main.c:11:16&gt;identifier 'b' [LeadingSpace] Loc=&lt;main.c:11:20&gt;r_paren ')' Loc=&lt;main.c:11:21&gt;l_brace '&#123;' [LeadingSpace] Loc=&lt;main.c:11:23&gt;return 'return' [StartOfLine] [LeadingSpace] Loc=&lt;main.c:12:5&gt;identifier 'a' [LeadingSpace] Loc=&lt;main.c:12:12&gt;plus '+' [LeadingSpace] Loc=&lt;main.c:12:14&gt;identifier 'b' [LeadingSpace] Loc=&lt;main.c:12:16&gt;semi ';' Loc=&lt;main.c:12:17&gt;r_brace '&#125;' [StartOfLine] Loc=&lt;main.c:13:1&gt;int 'int' [StartOfLine] Loc=&lt;main.c:15:1&gt;identifier 'main' [LeadingSpace] Loc=&lt;main.c:15:5&gt;l_paren '(' Loc=&lt;main.c:15:9&gt;int 'int' Loc=&lt;main.c:15:10&gt;identifier 'argc' [LeadingSpace] Loc=&lt;main.c:15:14&gt;comma ',' Loc=&lt;main.c:15:18&gt;const 'const' [LeadingSpace] Loc=&lt;main.c:15:20&gt;char 'char' [LeadingSpace] Loc=&lt;main.c:15:26&gt;star '*' [LeadingSpace] Loc=&lt;main.c:15:31&gt;identifier 'argv' [LeadingSpace] Loc=&lt;main.c:15:33&gt;l_square '[' Loc=&lt;main.c:15:37&gt;r_square ']' Loc=&lt;main.c:15:38&gt;r_paren ')' Loc=&lt;main.c:15:39&gt;l_brace '&#123;' [LeadingSpace] Loc=&lt;main.c:15:41&gt;int 'int' [StartOfLine] [LeadingSpace] Loc=&lt;main.c:16:5&gt;identifier 'result' [LeadingSpace] Loc=&lt;main.c:16:9&gt;equal '=' [LeadingSpace] Loc=&lt;main.c:16:16&gt;identifier 'sum' [LeadingSpace] Loc=&lt;main.c:16:18&gt; // 标识位于源文件的第 16 行，从第 18 个字符开始l_paren '(' Loc=&lt;main.c:16:21&gt;numeric_constant '1' Loc=&lt;main.c:16:22&gt;comma ',' Loc=&lt;main.c:16:23&gt;numeric_constant '2' [LeadingSpace] Loc=&lt;main.c:16:25&gt;r_paren ')' Loc=&lt;main.c:16:26&gt;semi ';' Loc=&lt;main.c:16:27&gt;return 'return' [StartOfLine] [LeadingSpace] Loc=&lt;main.c:17:5&gt;numeric_constant '0' [LeadingSpace] Loc=&lt;main.c:17:12&gt;semi ';' Loc=&lt;main.c:17:13&gt;r_brace '&#125;' [StartOfLine] Loc=&lt;main.c:18:1&gt;eof '' Loc=&lt;main.c:18:2&gt; identifier &#39;sum&#39; [LeadingSpace] Loc=&lt;main.c:16:18&gt; 表示位于源文件的第 16 行，从第 18 个字符开始 经过词法分析后，源代码就变成了一个个记号 token，并且记录了每一个记号 token 的在源代码中的位置信息。 语法分析语法分析就是语法分析器对词法分析输出的记号 token 进行语法分析，输出一颗以表达式为节点的抽象语法树(abstract syntax tree - AST)。 123456789101112131415161718192021222324252627282930# clang 语法分析生成抽象语法树xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c# sum 函数|-FunctionDecl 0x7fdd2a0126f0 &lt;main.c:11:1, line:13:1&gt; line:11:5 used sum 'int (int, int)'| |-ParmVarDecl 0x7fdd2a010590 &lt;col:9, col:13&gt; col:13 used a 'int'| |-ParmVarDecl 0x7fdd2a012618 &lt;col:16, col:20&gt; col:20 used b 'int'| `-CompoundStmt 0x7fdd2a012838 &lt;col:23, line:13:1&gt;| `-ReturnStmt 0x7fdd2a012828 &lt;line:12:5, col:16&gt;| `-BinaryOperator 0x7fdd2a012808 &lt;col:12, col:16&gt; 'int' '+'| |-ImplicitCastExpr 0x7fdd2a0127d8 &lt;col:12&gt; 'int' &lt;LValueToRValue&gt;| | `-DeclRefExpr 0x7fdd2a012798 &lt;col:12&gt; 'int' lvalue ParmVar 0x7fdd2a010590 'a' 'int'| `-ImplicitCastExpr 0x7fdd2a0127f0 &lt;col:16&gt; 'int' &lt;LValueToRValue&gt;| `-DeclRefExpr 0x7fdd2a0127b8 &lt;col:16&gt; 'int' lvalue ParmVar 0x7fdd2a012618 'b' 'int'# main 函数`-FunctionDecl 0x7fdd2a012a60 &lt;line:15:1, line:18:1&gt; line:15:5 main 'int (int, const char **)' |-ParmVarDecl 0x7fdd2a012868 &lt;col:10, col:14&gt; col:14 argc 'int' |-ParmVarDecl 0x7fdd2a012950 &lt;col:20, col:38&gt; col:33 argv 'const char **':'const char **' `-CompoundStmt 0x7fdd2a012c98 &lt;col:41, line:18:1&gt; |-DeclStmt 0x7fdd2a012c50 &lt;line:16:5, col:27&gt; | `-VarDecl 0x7fdd2a012b20 &lt;col:5, col:26&gt; col:9 result 'int' cinit | `-CallExpr 0x7fdd2a012c20 &lt;col:18, col:26&gt; 'int' | |-ImplicitCastExpr 0x7fdd2a012c08 &lt;col:18&gt; 'int (*)(int, int)' &lt;FunctionToPointerDecay&gt; | | `-DeclRefExpr 0x7fdd2a012b80 &lt;col:18&gt; 'int (int, int)' Function 0x7fdd2a0126f0 'sum' 'int (int, int)' | |-IntegerLiteral 0x7fdd2a012ba0 &lt;col:22&gt; 'int' 1 | `-IntegerLiteral 0x7fdd2a012bc0 &lt;col:25&gt; 'int' 2 `-ReturnStmt 0x7fdd2a012c88 &lt;line:17:5, col:12&gt; `-IntegerLiteral 0x7fdd2a012c68 &lt;col:12&gt; 'int' 0 sum 函数的语法树图形化为： 有了 AST 抽象语法树，语法分析阶段就可以对代码进行分析检查，如检查括号是否匹配，是否缺少操作符，类型是否匹配等，一旦检查不通过，就会报告语法分析阶段的错误。 AST 也是用来编写 Clang 插件的主要交互的数据结构，程序员可以基于 AST 来编写自定义的语法规则，可以用来做代码静态检查。Clang 也提供了很多的 API 来对 AST 的节点做增删改查操作。 语义分析语法分析仅仅是完成对表达式语法层面的检查，要想检查语句是否真正有意义，还需要语义分析。 语义分析是由语义分析器来完成，语义分析检查的是表达式是否真的有意义，如类型的转换，声明和类型的匹配，如将一个浮点型赋值给一个指针类型，就会报语义分析阶段错误。 经过语义分析阶段后，整个语法树的表达式都被标识了类型，有些需要隐式转换的类型，也会在这个阶段插入相应的转换节点。 中间语言生成12345678910111213141516171819202122232425262728293031323334353637383940414243# clang 生成中间代码 .ll 是文本格式的中间代码，还有内存格式和二进制格式clang -S -emit-llvm main.c -o main.ll; ModuleID = 'main.c'source_filename = "main.c"target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"target triple = "x86_64-apple-macosx10.15.0"; Function Attrs: noinline nounwind optnone ssp uwtabledefine i32 @sum(i32, i32) #0 &#123; %3 = alloca i32, align 4 %4 = alloca i32, align 4 store i32 %0, i32* %3, align 4 store i32 %1, i32* %4, align 4 %5 = load i32, i32* %3, align 4 %6 = load i32, i32* %4, align 4 %7 = add nsw i32 %5, %6 ret i32 %7&#125;; Function Attrs: noinline nounwind optnone ssp uwtabledefine i32 @main(i32, i8**) #0 &#123; %3 = alloca i32, align 4 %4 = alloca i32, align 4 %5 = alloca i8**, align 8 %6 = alloca i32, align 4 store i32 0, i32* %3, align 4 store i32 %0, i32* %4, align 4 store i8** %1, i8*** %5, align 8 %7 = call i32 @sum(i32 1, i32 2) store i32 %7, i32* %6, align 4 ret i32 0&#125;attributes #0 = &#123; noinline nounwind optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "darwin-stkchk-strong-link" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "probe-stack"="___chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" &#125;!llvm.module.flags = !&#123;!0, !1, !2&#125;!llvm.ident = !&#123;!3&#125;!0 = !&#123;i32 2, !"SDK Version", [2 x i32] [i32 10, i32 15]&#125;!1 = !&#123;i32 1, !"wchar_size", i32 4&#125;!2 = !&#123;i32 7, !"PIC Level", i32 2&#125;!3 = !&#123;!"Apple clang version 11.0.0 (clang-1100.0.33.8)"&#125; 可以阅读以下 IR 中间代码中的 sum 函数： 1234567891011# sum 函数define i32 @sum(i32, i32) #0 &#123; %3 = alloca i32, align 4 # 分配一个局部变量 %3 %4 = alloca i32, align 4 # 分配一个局部变量 %4 store i32 %0, i32* %3, align 4 # 将 %0 的值赋值给 %3，%0 就是 sum 函数的第一个参数 a store i32 %1, i32* %4, align 4 # 将 %1 的值赋值给 %4，%1 就是 sum 函数的第二个参数 b %5 = load i32, i32* %3, align 4 # 分配一个局部变量 %5， 并将 %3 的值赋值给 %5，即 a 的值 %6 = load i32, i32* %4, align 4 # 分配一个局部变量 %6， 并将 %4 的值赋值给 %5，即 b 的值 %7 = add nsw i32 %5, %6 a + b # 分配一个局部变量 %7，将局部变量 %5 和局部变量 %6 的值相加后赋值给 %7，即 a + b 的值 ret i32 %7 # 返回局部变量 %7 的值，即 a + b 的值&#125; 至此，编译器前端的工作已经做完，生成了中间代码，中间代码是编译器前端的输出，也是编译器后端的输入。接下来就是编译器后端的工作了。 目标代码生成和优化编译器后端将中间代码转成汇编代码，输出汇编代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 使用 clang 生成汇编代码clang -S main.c -o main.s .section __TEXT,__text,regular,pure_instructions .build_version macos, 10, 15 sdk_version 10, 15 .globl _sum ## -- Begin function sum .p2align 4, 0x90_sum: ## @sum .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp movl %edi, -4(%rbp) movl %esi, -8(%rbp) movl -4(%rbp), %esi addl -8(%rbp), %esi movl %esi, %eax popq %rbp retq .cfi_endproc ## -- End function .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $32, %rsp movl $0, -4(%rbp) movl %edi, -8(%rbp) movq %rsi, -16(%rbp) movl $1, %edi movl $2, %esi callq _sum xorl %esi, %esi movl %eax, -20(%rbp) movl %esi, %eax addq $32, %rsp popq %rbp retq .cfi_endproc ## -- End function.subsections_via_symbols 汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件(object file)： 123456clang -fmodules -c main.c -o main.o// 使用 nm 可以查看 main.o 文件中的符号 Symbol➜ HelloWorld nm -nm main.o0000000000000000 (__TEXT,__text) external _sum0000000000000020 (__TEXT,__text) external _main 目标代码生成阶段依赖具体的目标机器，不同的机器有不同的字长、寄存器、整数和浮点数数据类型。目标代码优化`会采取选择合适的寻址方式、使用位移代替乘法、删除多余的指令等方对代码进行优化。 符号 Symbol 表示一段代码或者是数据的起始地址。 链接每个文件或者模块独立编译后的目标文件组装的过程叫做链接，链接由链接器完成。链接过程主要包括了地址和空间的分配、符号决议、和重定位等步骤。 链接器 将不同的目标文件和库文件链接起来，处理好各个模块和文件中的相互引用，将符号绑定到地址上，最终形成可执行文件。 12# 使用 clang 链接生目标文件生成可执行文件clang main.o -o main 123456# 查看可执行文件中的符号表➜ HelloWorld nm -nm main (undefined) external dyld_stub_binder (from libSystem) 0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header0000000100000f60 (__TEXT,__text) external _sum0000000100000f80 (__TEXT,__text) external _main 表示符号 dyld_stub_binder 来自于 libSystem 库，undefined 表示在当前文件中找不到该符号，external 表示该符号可以支持外部访问 iOS DEMO上面我们通过一个 hello world 程序和一个加法函数的 C 语言来举例，基本覆盖了编译链接的整个大的流程，但毕竟是单文件的，涉及的场景有限，有很多细节没法展示。 下面写一个使用 Objective-C 和 Swift 的混编项目，使用 CocoaPods 来管理第三方库，包含了一个Objective-C .a 静态库 FooObjcStaticLibrary 和一个 Swift 的动态库 FooSwift.framework，尽量模拟真实的 iOS 项目场景，再来探究下。DEMO 项目结构如下： 运行效果： 点击 Command + B 构建过程大多数任务在构建过程中由命令行工具运行，比如 Clang，LD，AC 工具，IB 工具，代码符号等。这些工具等执行，需要一组特定的实参，以特定的顺序，基于 Xcode 项目配置。 构建系统 Bulid SystemXcode 10 开始，使用了新的 Bulid System，新构建系统使用 Swift Scratch 编写，提供了更好的性能，而且这个代码是开源的，地址在这里。 读取 project 文件首先，构建系统会从 project 文件读取源代码的信息，决定构建过程的模型和流程，然后转换成一个树形结构叫做定向图，它显示了所有的依赖关系，项目中的输入和输出文件，以及处理他们的执行任务。构建系统就按照定向图的顺序执行一系列的构建任务。 project 文件除了记录了 App 的一些相关信息和源代码文件的组织目录关系，还记录了 build settings、build phases、build rules、target 、target dependencies 等构建相关的信息。有关 project 文件更新详细的介绍可以看这篇文章。 构建顺序是由依赖关系决定的，依赖关系的来源下面几种： 构建系统自带的规则，如编译器、链接器、资源目录、storyboard 处理器，这些规则定义了哪些是输入文件，哪些是输出文件 target 依赖，build 当前的 target 之前，必须先对这里的依赖先进行 build 隐式依赖（Implicit dependencies） Bulid phases，代表着将代码转变为可执行文件的最高级别规则，里面描述了 build 过程中必须执行的不同类型规则，定义了构建处理的过程 ​ CocoaPods 相关的脚本 script execution Compile Sources 中规定了所有必须参与编译的文件，这里列出的所有文件将根据相关的 build rules 和 build settings 被处理 Link Binary with Libraries：列出了所有的静态库和动态库，编译结束后，这些库会参与上面编译阶段生成的目标文件进行链接 Copy Bundle Resources：将静态资源（例如图片、Storyboard 和字体）拷贝到 app bundle 中 Scheme 顺序依赖 该项目的构建定向图如下：** 编译源代码链接第二部分：点击 App Icon -&gt; 看到页面 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「by在水一方」。]]></content>
      <categories>
        <category>编译</category>
        <category>链接</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 代码编译流程]]></title>
    <url>%2F2019%2F10%2F11%2FSwift-%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[### 编程语言分类编程语言按照不同的角度可以有不同的分类。 按与硬件的距离分： 机器语言：根据硬件指令集的 0101 汇编语言：对机器语言做了简单的封装 高级语言：C/C++/Java/Python/JavaScript/Swift 等 按编程范式分： 面向过程： C 面向对象： C++/Java 函数式 现在的很多高级语言都具备多种编程范式。 按是否需要编译分： 编译型语言 Compiled Language，编译后可直接执行，执行效率高 C/C++/Objective-C/Swift（不依赖虚拟机） Java (依赖虚拟机)，Java 源代码会先编译成为 .class（字节码）文件，再经过 JVM 一行一行的解释执行 解释型语言 Interpreted Language，也叫脚本语言 Scripting Language，运行在解释器上，解释一行代码，执行一行，执行效率相对编译型语言更低，但容易移植 Python/Ruby/JavaScript Swift 是一门编译型语言，编译型语言的源代码要运行，首先是需要编译器（Complier）把源文件进行编译成目标文件，然后经过链接器（Linker）链接后才能够执行的。这篇主要记录的是 Swift 代码的编译过程。 LLVM 编译器架构 Frontend 前端 词法分析、语法分析、语义分析、生成中间代码 Optimizer 优化器 中间代码优化 Backend 后端 生成不同硬件平台的机器码 前后端依赖统一格式的中间代码(IR)，使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。 Objective C/C/C++使用的编译器前端是clang，swift是swift，后端都是LLVM。 Objective-C 源代码编译流程单文件编译 链接器Command + B 构建过程提高构建速度统计构建时间提高 App 启动时间Mach-O 文件格式 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「by在水一方」。]]></content>
      <categories>
        <category>Swift</category>
        <category>编译</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Playground Markup 语法]]></title>
    <url>%2F2019%2F10%2F11%2FPlayground-Markup-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言学习 Swift 语法最好的工具是 Xcode 配套的 Playground，所见即所得。除了实时显示变量的值，还可以加载资源，呈现视图，多文件管理等。 但还不止如此，还可以在写注释文档的时候使用 Markup 语法，写出非常漂亮的注释。 Markup &amp;&amp; Markdown Markup 语法和 Markdown 基本一致： 12345678910111213141516171819202122232425262728//: [Previous](@previous)/*: # 一级标题 ## 二级标题 ## 二级标题 ### 三级标题 ### 三级标题 ## 无序列表 - 无序列表1 - 无序列表2 - 无序列表3 ## 有序列表 1. 有序列表1 2. 有序列表2 3. 有序列表3 ## 图片 ![我是图片](myIcon.jpg) ## 链接 [在水一方](https://chenliangjing.me)*///: [下一页](@next) 查看效果： 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「by在水一方」。]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Pannellum 的全景图网页容器实现]]></title>
    <url>%2F2019%2F10%2F02%2F%E5%9F%BA%E4%BA%8E-Pannellum-%E7%9A%84%E5%85%A8%E6%99%AF%E5%9B%BE%E7%BD%91%E9%A1%B5%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言2017 年由于公司需要，做过一个支持全景图显示的网页，这篇文章主要回顾和记录一下当初开发这个功能时的一些情景。 先看效果 实现了哪些功能基于 Pannellum 实现 1. 全景图的显示123456789101112131415161718viewer = pannellum.viewer('container', &#123; // 默认参数 "default": &#123; "firstScene": "hotalScene", // 第一个场景 "sceneFadeDuration": 1000, // 场景过度的动画时长 "autoLoad": true, // 是否自动加载 "compass":true, // 指南针是否显示 "orientationOnByDefault": true,// 是否默认重力感应 &#125;, // 场景数组 "scenes": &#123; "hotalScene": &#123; "type": "equirectangular", // 全景图类型 equirectangular "panorama": path, // 全景图路径：可以本地，也可以是url &#125; &#125;&#125;); 2. 场景切换12345678// 动态添加场景，场景切换viewer.addScene('roomScene',&#123; "type": "equirectangular", // 全景图类型 equirectangular "panorama": message.PanoramaUrl, // 全景图路径：可以本地，也可以是url &#125;); // 加载房间全景 viewer.loadScene('roomScene'); 3. 和微信小程序的交互12345// 引入小程序 jsSdk&lt;script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.3.1.js"&gt;&lt;/script&gt;// 小程序跳转，url 通过 &amp; 拼接参数wx.miniProgram.navigateTo(&#123; url:'../roomBook/roomBookPage?model=' + JSON.stringify(currentRoomDict) + '&amp;from=' + '3' &#125;); 4. 和 App 的交互12345678// 自定义拦截协议var linkUrl = &apos;hjdykj://RoomID=&apos;;window.location.href = linkUrl;// 原生拦截到，做自定义的事情NSString *message = (NSString *)param;NSRange startR = [message rangeOfString:@&quot;hjdykj://RoomID=&quot;];// TODO: 参考资料 https://juejin.im/post/5b62b985e51d455d947196fc#heading-4 https://github.com/mpetroff/pannellum 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「by在水一方」。]]></content>
      <categories>
        <category>html</category>
        <category>全景图</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>全景图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 端 h5 页面秒开优化实践]]></title>
    <url>%2F2019%2F09%2F27%2FiOS-%E7%AB%AF-h5-%E9%A1%B5%E9%9D%A2%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[前言最近公司项目中需要做秒开 h5 页面的优化需求，于是调研了下市面上的方案，并结合本公司具体的业务需求做了一次这方面的优化实践，这篇文章是对这次优化实践的记录，文末附上源代码下载。 先看效果 优化思路首先来看，在 iOS 平台加载一个 H5 网页，需要经过哪些步骤： 初始化 webview -&gt; 请求页面 -&gt; 下载数据 -&gt; 解析HTML -&gt; 请求 js/css 资源 -&gt; dom 渲染 -&gt; 解析 JS 执行 -&gt; JS 请求数据 -&gt; 解析渲染 -&gt; 下载渲染图片 由于在 dom 渲染前的用户看到的页面都是白屏，优化思路具体也是去分析在 dom 渲染前每个步骤的耗时，去优化性价比最高的部分。这里面又可以分为前端能做的优化，以及客户端能做的优化，前端这个需要前端那边配合，暂且不在这篇文章中讨论，这边文章主要讨论的是客户端能做的优化思路。总体思路大概也是这样： 能够缓存的就尽量缓存，用空间换时间。这里可以去拦截的 h5 页面的所有资源请求，包括 html、css/js，图片、数据等，右客户端来接管资源的缓存策略（包括缓存的最大空间占用，缓存的淘汰算法、缓存过期等策略）； 能够预加载的，就提前预加载。可以预先处理一些耗时的操作，如在 App 启动的时候就提前初始化好 webview 等待使用； 能够并行的的，就并行进行，利用设备的多核能力。如在加载 webview 的时候就可以同时去加载需要的资源； 初始化 webview 阶段在客户端加载一个 网页和在 PC 上加载一个网页不太一样，在 PC 上，直接在浏览器中输入一个 url 就开始建立连接了，而在客户端上需要先启动浏览器内核，初始化一些 webview 的全局服务和资源，再开始建立连接，可以看一下美团测试的这个阶段的耗时大概是多少： 在客户端第一次打开 h5 页面，会有一个 webview 初始化的耗时， 可以看到数据在使用 WKWebView 的情况下，首次初始化的时间耗时有 760 多毫秒，所以如果能够在打开网页的时候使用已经初始化好了的 webview 来加载，那么这部分的耗时就没有了。 这边实现了一个 webview 缓冲池的方案，在 App 启动的时候就初始化了，在需要打开网页的时候直接从缓冲池里面去取 webview 就行： 1234567891011121314151617181920+ (void)load&#123; [WebViewReusePool swiftyLoad];&#125;@objc public static func swiftyLoad() &#123; NotificationCenter.default.addObserver(self, selector: #selector(didFinishLaunchingNotification), name: UIApplication.didFinishLaunchingNotification, object: nil)&#125;@objc static func didFinishLaunchingNotification() &#123; // 预先初始化webview WebViewReusePool.shared.prepareWebView()&#125;func prepareWebView() &#123; DispatchQueue.main.async &#123; let webView = ReuseWebView(frame: CGRect.zero, configuration: self.defaultConfigeration) self.reusableWebViewSet.insert(webView) &#125;&#125; 建立连接 -&gt; dom 渲染前阶段#拦截请求在 iOS 11 及其以上系统上可以 WKWebView 提供的 setURLSchemeHandler 方法添加自定义的 Scheme，相比较NSURLProtocol 私有 api 的方案没有审核风险，然后就可以在 WKURLSchemeHandler 协议里面拦截所有的自定义请求了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 自定义拦截请求开始func webView(_ webView: WKWebView, start urlSchemeTask: WKURLSchemeTask) &#123; let headers = urlSchemeTask.request.allHTTPHeaderFields guard let accept = headers?["Accept"] else &#123; return &#125; guard let requestUrlString = urlSchemeTask.request.url?.absoluteString else &#123; return &#125; if accept.count &gt;= "text".count &amp;&amp; accept.contains("text/html") &#123; // html 拦截 print("html = \(String(describing: requestUrlString))") // 加载本地的缓存资源 loadLocalFile(fileName: creatCacheKey(urlSchemeTask: urlSchemeTask), urlSchemeTask: urlSchemeTask) &#125; else if (requestUrlString.isJSOrCSSFile()) &#123; // js || css 文件 print("js || css = \(String(describing: requestUrlString))") loadLocalFile(fileName: creatCacheKey(urlSchemeTask: urlSchemeTask), urlSchemeTask: urlSchemeTask) &#125; else if accept.count &gt;= "image".count &amp;&amp; accept.contains("image") &#123; // 图片 print("image = \(String(describing: requestUrlString))") guard let originUrlString = urlSchemeTask.request.url?.absoluteString.replacingOccurrences(of: "customscheme", with: "https") else &#123; return &#125; // 图片可以使用 SDWebImageManager 提供的缓存策略 SDWebImageManager.shared.loadImage(with: URL(string: originUrlString), options: SDWebImageOptions.retryFailed, progress: nil) &#123; (image, data, error, type, _, _) in if let image = image &#123; guard let imageData = image.jpegData(compressionQuality: 1) else &#123; return &#125; // 资源不存在就重新发送请求 self.resendRequset(urlSchemeTask: urlSchemeTask, mineType: "image/jpeg", requestData: imageData) &#125; else &#123; self.loadLocalFile(fileName: self.creatCacheKey(urlSchemeTask: urlSchemeTask), urlSchemeTask: urlSchemeTask) &#125; &#125; &#125; else &#123; // other resources print("other resources = \(String(describing: requestUrlString))") guard let cacheKey = self.creatCacheKey(urlSchemeTask: urlSchemeTask) else &#123; return &#125; requestRomote(fileName: cacheKey, urlSchemeTask: urlSchemeTask) &#125;&#125;/// 自定义请求结束时调用func webView(_ webView: WKWebView, stop urlSchemeTask: WKURLSchemeTask) &#123; &#125; #实现资源缓存这里使用 swift 实现了内存和磁盘两种缓存逻辑，主要参(chao)考(xi)了 YYCache 的思路和源码，内存缓存利用双链表（逻辑） + hashMap（存储） 实现LRU缓存淘汰算法 ，增删改查都是 O(1) 时间复杂度，磁盘缓存使用了沙盒文件存储。两种缓存都实现了缓存时长、缓存数量、缓存大小三个维度的缓存管理。 使用协议的方式定义了接口 API： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364protocol Cacheable &#123; associatedtype ObjectType /// 缓存总数量 var totalCount: UInt &#123; get &#125; /// 缓存总大小 var totalCost: UInt &#123; get &#125; /// 缓存是否存在 /// /// - Parameter key: 缓存key /// - Returns: 结果 func contain(forKey key: AnyHashable) -&gt; Bool /// 返回指定key的缓存 /// /// - Parameter key: /// - Returns: func object(forKey key: AnyHashable) -&gt; ObjectType? /// 设置缓存 k、v /// /// - Parameters: /// - object: /// - key: func setObject(_ object: ObjectType, forKey key: AnyHashable) /// 设置缓存 k、v、c /// /// - Parameters: /// - object: /// - key: /// - cost: func setObject(_ object: ObjectType, forKey key: AnyHashable, withCost cost: UInt) /// 删除指定key的缓存 /// /// - Parameter key: func removeObject(forKey key: AnyHashable) /// 删除所有缓存 func removeAllObject() /// 根据缓存大小清理 /// /// - Parameter cost: 缓存大小 func trim(withCost cost: UInt) /// 根据缓存数量清理 /// /// - Parameter count: 缓存数量 func trim(withCount count: UInt) /// 根据缓存时长清理 /// /// - Parameter age: 缓存时长 func trim(withAge age: TimeInterval)&#125;extension Cacheable &#123; func setObject(_ object: ObjectType, forKey key: AnyHashable) &#123; setObject(object, forKey: key, withCost: 0) &#125;&#125; 用法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/// h5 页面资源缓存class H5ResourceCache: NSObject &#123; /// 内存缓存大小：10M private let kMemoryCacheCostLimit: UInt = 10 * 1024 * 1024 /// 磁盘文件缓存大小： 10M private let kDiskCacheCostLimit: UInt = 10 * 1024 * 1024 /// 磁盘文件缓存时长：30 分钟 private let kDiskCacheAgeLimit: TimeInterval = 30 * 60 private var memoryCache: MemoryCache private var diskCache: DiskFileCache override init() &#123; memoryCache = MemoryCache.shared memoryCache.costLimit = kMemoryCacheCostLimit diskCache = DiskFileCache(cacheDirectoryName: "H5ResourceCache") diskCache.costLimit = kDiskCacheCostLimit diskCache.ageLimit = kDiskCacheAgeLimit super.init() &#125; func contain(forKey key: String) -&gt; Bool &#123; return memoryCache.contain(forKey: key) || diskCache.contain(forKey: key) &#125; func setData(data: Data, forKey key: String) &#123; guard let dataString = String(data: data, encoding: .utf8) else &#123; return &#125; memoryCache.setObject(dataString.data(using: .utf8) as Any, forKey: key, withCost: UInt(data.count)) diskCache.setObject(dataString.data(using: .utf8)!, forKey: key, withCost: UInt(data.count)) &#125; func data(forKey key: String) -&gt; Data? &#123; if let data = memoryCache.object(forKey: key) &#123; print("这是内存缓存") return data as? Data &#125; else &#123; guard let data = diskCache.object(forKey: key) else &#123; return nil&#125; memoryCache.setObject(data, forKey: key, withCost: UInt(data.count)) print("这是磁盘缓存") return data &#125; &#125; func removeData(forKey key: String) &#123; memoryCache.removeObject(forKey: key) diskCache.removeObject(forKey: key) &#125; func removeAll() &#123; memoryCache.removeAllObject() diskCache.removeAllObject() &#125;&#125; 效果 注意事项#1. WKURLSchemeHandler 对象实例被释放后，网络加载回调依然访问了，这个时候就会出现崩溃The task has already been stopped的错误 解决方案：用一个字典持有 WKURLSchemeTask 实例的状态，分别在拦截请求开始的地方和拦截请求结束的地方分别记录1234567891011121314151617// MARK:- 请求拦截开始func webView(_ webView: WKWebView, start urlSchemeTask: WKURLSchemeTask) &#123; holdUrlSchemeTasks[urlSchemeTask.description] = true&#125;/// 自定义请求结束时调用func webView(_ webView: WKWebView, stop urlSchemeTask: WKURLSchemeTask) &#123; holdUrlSchemeTasks[urlSchemeTask.description] = false&#125;// 需要用到的 urlSchemeTask 实例的地方，加一层判断// urlSchemeTask 是否提前结束，结束了调用实例方法会崩溃if let isValid = self.holdUrlSchemeTasks[urlSchemeTask.description] &#123; if !isValid &#123; return &#125;&#125; #2. 网页乱码添加网络请求响应接收格式： 1manager.responseSerializer.acceptableContentTypes = Set(arrayLiteral: "text/html", "application/json", "text/json", "text/javascript", "text/plain", "application/javascript", "text/css", "image/svg+xml", "application/font-woff2", "application/octet-stream") #3. WKWebView 白屏123456789101112// 白屏override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) if webview.title == nil &#123; webview.reload() &#125;&#125;// 白屏func webViewWebContentProcessDidTerminate(_ webView: WKWebView) &#123; webView.reload()&#125; 源代码https://github.com/ljchen1129/SecondsOpenH5 TODOList 撰写单元测试 去除第三方库 SDWebImage 和 AFNetworking，使用原生实现 资源预加载逻辑 统一的异常管理 更加 Swift style 参考资料 https://blog.cnbang.net/tech/3477/ https://mp.weixin.qq.com/s/0OR4HJQSDq7nEFUAaX1x5A https://juejin.im/post/5c9c664ff265da611624764d https://tech.meituan.com/2017/06/09/webviewperf.html 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「青争哥哥」。]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》读书笔记—像小说一样有趣的算法入门书]]></title>
    <url>%2F2019%2F05%2F02%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E5%83%8F%E5%B0%8F%E8%AF%B4%E4%B8%80%E6%A0%B7%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[前言学习算法课程的时候，老师推荐了两本算法和数据结构入门书，一本是《算法图解》、一本是《大话数据结构》，《算法图解》这本书最近读完了，读完的最大感受就是对算法不再感到畏惧和陌生，对常用的算法和数据结构都会在心里有个基本的概念，这篇文章记录下这本书的主要内容和知识点。 总的来说，这本书是一本不错的算法入门书，作者以从实际开发场景出发，介绍了软件开发中最基本、最常用的一些数据结构和算法思想，同时作者写得非常深入浅出，联系实际应用场景，并结合了大量的算法推演图示，举例生动形象，循序渐进，使读者易于理解，能够很大地培养读者对算法的兴趣，从而引导读者进一步地进行学习研究。 正如作者在书开头关于本书中所说，阅读这本书最佳姿势是从头到尾读，因为作者对内容顺序专门做了精心地编排，从简到难。前三章是最基础的部分，第一章通过二分查找算法来引出衡量算法优劣的大O表示法概念，同时介绍了数组和链表这两种最基本的数据结构，通过这两种最基本的数据结构，可以来创建更高级更复杂的数据结构，第三章则介绍了递归，一种被众多算法（如快速排序）采用的编程技巧。 从第四章开始，介绍地都是应用特别广泛的一些算法，第四章介绍了快速排序，一种效率最高的排序算法。第五章介绍了散列表，也叫哈希表或者字典，介绍了哈希表的实现，怎么解决冲突，应用场景等内容。第六七章主要介绍的是图这种数据结构，有向图还是无向图，带权值还是不带权值，以及和图相关的几种算法，广度优先算法和狄克斯特算法。第八章介绍了贪婪算法，在没有高效的解决方案是，可以考虑用贪婪算法来得到近似答案。第九章介绍的是动态规划，第十章介绍一种简单的机器学习算法 K 最近邻算法，可以应用于创建推荐系统、OCR引擎、预测股价以及物体分类等领域，最后一章介绍了其他一些解决特定问题的常见算法。 二分查找二分查找解决的是如何最快地在一个有序的集合中找到一个目标数的问题。使用二分查找，每次都折半，通过和中间大的数比对，缩小范围，最终只需要 O(logn) 的事件复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 二分查找 array：有序数组 target: 目标数 loopCount: 寻找次数 return: 目标数下标 */- (NSInteger)binarySearchSortInArray:(NSArray&lt;NSNumber *&gt; *)array target:(NSNumber *)target loopCount:(NSInteger *)loopCount&#123; NSInteger low = 0; NSInteger high = array.count - 1; while (low &lt;= high) &#123; NSInteger mid = (low + high) / 2; NSInteger guess = array[mid].integerValue; *loopCount = *loopCount + 1; if (guess == target.integerValue) &#123; // 猜中了 return mid; &#125; if (guess &lt; target.integerValue) &#123; // 猜小了 low = mid + 1; &#125; else &#123; // 猜大了 high = mid - 1; &#125; &#125; return -1;&#125;// 测试数据 -----------------------------------------------------NSArray *array = @[@1, @2, @5, @6, @9, @10, @13, @18, @22, @30];NSInteger loopCount = 0;NSInteger result = [self binarySearchInSortArray:array target:@2 loopCount:&amp;loopCount];if (result &gt;= 0) &#123; NSLog(@&quot;找到目标数，目标数的的下标是：%ld，寻找：%ld 次&quot;, result, (long)loopCount);&#125; else &#123; NSLog(@&quot;没有找到找到目标数，目标数的的下标是：%ld, 寻找：%ld 次&quot;, result, (long)loopCount);&#125;// 打印日志 ------------------------------------------------------找到目标数，目标数的的下标是：1，寻找：2 次 递归递归是一种自己调用自己的函数，每个递归有两个条件，分别是基线条件和递归条件。如著名的斐波那契数列，在数学上，就是可以用递推公式来表示这个数列。 在编程领域，是常被很多算法所采用的一种编程技巧。如上面的二分查找也可以使用递归来写： 12345678910111213141516171819int binary_search(int nums[], int target, int low, int high)&#123; if(low &gt; high) &#123;return low;&#125; // 基线条件 int mid = low + (high - low) / 2; if(nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &gt; target) &#123; // 中间值大于目标值，递归条件 return binary_search(nums, target, low, mid - 1); &#125; else &#123; // 中间值小于目标值，递归条件 return binary_search(nums, target, mid + 1, high); &#125; &#125;// 测试 -----------------------------------------------------int array[10] = &#123;1, 2, 5, 6, 9, 10, 13, 18, 22, 30&#125;; int result = binary_search(array, 9, 0, sizeof(array)/sizeof(int));printf("result = %d", result); // result = 4 排序#选择排序选择排序的思想是，每次都从数组中选择最小的数然后依次从起始的位置开始存放，有两层循环，所以时间复杂度是 n^2。 1234567891011121314151617181920212223242526272829303132333435363738// 选择排序void select_sort(int nums[], int length)&#123; int a = nums[0]; // n -1 轮选择 for(int i = 0; i &lt; length - 1; i++) &#123; // 最小值所在索引 int min_index = i; for(int j = i + 1; j &lt; length; j++) &#123; if(nums[min_index] &gt; nums[j]) &#123; // 有更小的 min_index = j; &#125; &#125; // 如果正好，就不用交换 if (i != min_index) &#123; // 交换位置 int temp = nums[i]; nums[i] = nums[min_index]; nums[min_index] = temp; &#125; &#125;&#125;// 测试数据 ------------------------------------------int a[10] = &#123;12, 7, 67, 8, 5, 199, 78, 6, 2, 1&#125;;select_sort(a, 10); for(int i = 0; i &lt; 10; i++)&#123; printf("%d ", a[i]);&#125;// 打印日志 -----------------------------------------1 2 5 6 7 8 12 67 78 199 #快速排序快速排序是最快的一种排序算法，使用递归的思路，每次从数组中找出一个基准点，将数组分割成三分部分，小于所有基准点的元素组成一个数组less，大于基准点的元素组成一个数组greater，less + 基准点 + greater 就是新的数组，小数组也按照这种思路选取基准点进行分割，递归下去，递归的基线条件是数组的长度小于 2 时停止，意味着数组不能再分割下去了。这种思路下排序的时间复杂度是O(nlogn)。 12345678910111213141516171819202122// 快速排序func quickSort(_ array:[Int]) -&gt; [Int]&#123; if array.count &lt; 2 &#123; // 基线条件 return array; &#125; else &#123; // 递归条件 let pivot = array[0] let less = array.filter&#123;$0 &lt; pivot&#125; let greater = array.filter&#123;$0 &gt; pivot&#125; return quickSort(less) + [pivot] + quickSort(greater) &#125;&#125;// 测试var array = [1, 78, 8, 76, 98, 90, 3, 100, 45, 78]var newArray = quickSort(array)// 打印print(newArray) // [1, 3, 8, 45, 76, 78, 90, 98, 100] 散列表散列表是一种非常常见的数据结构，通过数组结合散列函数实现，散列函数计算出值所对应的数组下标映射，在其他一些平台上也被称为散列映射、映射、字典和关联数组，能做到 O(1) 平均复杂度的访问、插入和删除操作，是一种比较底层的数据结构。 散列表常用于查找、去重、缓存等应用场景，几乎每种编程语言都有自己的散列表实现，如 Objective-C 的 NSDictionary，要想散列表有较好的性能和避免冲突（两个键映射到了同一个位置），意味着需要有较低的填装因子（散列表包含的元素数/占用存储的位置总数）和良好的散列函数。 一个不错的经验是，一旦填装因子大于0.7，就要调整散列表的长度。而一旦发生冲突的一种解决办法是，在冲突的位置存储一个链表，将多个值存储到链表的不同的节点上，这样访问的时候就还需要从头遍历一遍该位置的链表才行，好的散列函数应该是将键均匀的映射到散列表的不同位置。 leetCode上第一道两数之和的题目就可以使用散列表来降低算法的时间复杂度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * @lc app=leetcode.cn id=1 lang=swift * * [1] 两数之和 * * https://leetcode-cn.com/problems/two-sum/description/ * * algorithms * Easy (44.51%) * Total Accepted: 243.9K * Total Submissions: 548K * Testcase Example: &apos;[2,7,11,15]\n9&apos; * * 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 * * 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 * * 示例: * * 给定 nums = [2, 7, 11, 15], target = 9 * * 因为 nums[0] + nums[1] = 2 + 7 = 9 * 所以返回 [0, 1] * * */ // C 两层循环实现int* twoSum(int* nums, int numsSize, int target) &#123; static int resultArray[2]; for (int i = 0; i &lt; numsSize; i ++) &#123; for (int j = i + 1; j &lt; numsSize; j++) &#123; if (nums[i] + nums[j] == target) &#123; resultArray[0] = i; resultArray[1] = j; &#125; &#125; &#125; return resultArray;&#125;// swift 使用散列表实现class Solution &#123; func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123; var hash = [Int: Int] for (index, item) in nums &#123; // 使用散列表来判断元素是否在散列表中，有的话返回元素的下标，即散列表的值 if let firstIndex = hash[target - item] &#123; return [firstIndex, index] &#125; // 将数组元素的值当做散列表的键，下标当做散列表的值存储在散列表中 hash[item] = index &#125; return [-1,-1] &#125;&#125; 使用散列表实现后: 广度优先搜索算法(breadth-first-search，BFS)广度优先搜索要解决的问题是基于图这种数据结构的最短路径的问题。是一种用于图的查找算法，可帮助回答两类问题： 从顶点 a 出发，有前往顶点 b 的路径吗？ 从顶点 a 出发，前往顶点 b 的哪条路径最短？ 再看一下图的定义： 图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。 图有很多种类： 按照有无方向可以分为有向图和无向图，有向图的边又称为弧，有弧头和弧尾之分。 按照边或弧的多少又分为稀疏图和稠密图。如果任意两个顶点之间都存在边叫做完全图，边有向的叫做有向完全图，若无重复的边或者顶点到自身的边叫做简单图。 图上的边或者弧带上权则叫做网。 可以得出结论，广度优先搜索解决问题的数据模型是有向图，且不加权。 书中列举了两个列子，先来看第一个，如何选择换乘公交最少的路线？，假设你住在旧金山，现在要从双子峰前往金门大桥，如图所示： 可以从图中得知，到达金门大桥最少需要三步，最短路径是从双子峰步行到搭乘 44 路公交，然后再换乘 28 路公交最短。 第二个例子是这样的，假设你经营一个芒果农场，需要寻找芒果销售商，如何在你自己的朋友关系网中找到芒果销售商，这种关系包括你自己的朋友，这个是一度关系，也包括朋友的朋友，这个是二度关系，依次类推，那怎么找到最短路径呢？ 解题思路： 使用散列表来存储关系网，使用队列来存储查找顺序，优先查找一度关系，再二度关系，依次类推。然后遍历队列判断是否是芒果销售商，是的话就是最近的芒果销售商，如果不是，再查找二度关系，如果最后都没有找到就是关系网里面没有芒果销售商。 swift 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 1. 使用数组来实现一个队列，先进先出struct Queue&lt;Element&gt; &#123; private var elements: [Element] = [] init() &#123; &#125; var count: Int &#123; return elements.count &#125; var isEmpty: Bool &#123; return elements.isEmpty &#125; // 队列第一个元素 var peek: Element? &#123; return elements.first &#125; // 入队 mutating func enqueue(_ element:Element) &#123; elements.append(element) &#125; // 出队 mutating func dequeue() -&gt; Element?&#123; return isEmpty ? nil : elements.removeFirst() &#125;&#125;extension Queue: CustomStringConvertible &#123; var description: String &#123; return elements.description &#125;&#125;// 2. 使用散列表来存储关系网var graph = [String:Any]()// 一度关系graph["you"] = ["claire", "bob", "alice"]// 二度关系graph["bob"] = ["anuj", "peggy"]graph["claire"] = ["thom", "jonny"]graph["alice"] = ["peggy"]// 三度关系graph["anuj"] = []graph["peggy"] = []graph["thom"] = []graph["jonny"] = []// 3. 广度优先搜索算法func search(_ name: String, inGraph g: [String:Any]) -&gt; Bool &#123; // 搜索队列 var searchQueue = Queue&lt;String&gt;() // 入队列 for item in g[name] as! Array&lt;String&gt; &#123; searchQueue.enqueue(item) &#125; // 记录已经查找过的人 var searched = [String]() // 循环结束条件 1. 找到一位芒果销售商；2. 队列为空，意味着关系网里面没有芒果销售商 while !searchQueue.isEmpty &#123; // 出队 let person = searchQueue.dequeue() // 判断是否已经检查过，检查过就不再检查，防止出现死循环 if !searched.contains(person!) &#123; if personIsSeller(person!) &#123; print("找到了芒果销售商:\(person!)") return true &#125; else &#123; // 寻找下一度关系 // 入队列 for item in g[person!] as! Array&lt;String&gt; &#123; searchQueue.enqueue(item) &#125; // 将这个人标记检查过 searched.append(person!) &#125; &#125; &#125; // 循环结束，没有找到 return false&#125;// 是不是销售商，规则可以随便设置func personIsSeller(_ name: String) -&gt; Bool &#123; if let c = name.last &#123; return c == "y" &#125; return false&#125;// 测试search("you", inGraph: graph) // 找到了芒果销售商:jonnysearch("bob", inGraph: graph) // 找到了芒果销售商:peggy 狄克斯特算法深度优先算法BFS适用于无加权图，找出的最短路径是边数最少的路径，而狄克斯特算法解决的是加权图中的最短路径问题，找出的是最经济最划算的路径。 注意：狄克斯特算法也不适用于带环的图，只适用于有向无环图，也不适用于负权边的图，负权边的图的最短路径问题可以使用贝尔曼-福德算法。 狄克斯特算法包含四个步骤： 找出最便宜的顶点，即可在最少权重内到达前往的顶点； 对于该顶点的邻居，检查是否有前往他们的更短路径，如果有，就更新其开销； 重复这个过程，直到图中的每个顶点都这样做了； 计算最终路径； 书中举了一个换钢琴的例子，如何用乐谱再加最少的钱换到钢琴的问题，使用狄克斯特算法的解决思路是： 解题思路： 一、找出最便宜的节点，乐普的邻居是唱片和海报，换唱片要支付 5 美元，换海报不用钱。先创建一个表格，记录每个节点的开销以及父节点。所以下一个最便宜的节点是海报。 二、计算前往该节点的各个邻居节点的开销。第一步中海报最便宜，所以先从海报出发，海报可以换吉他需要加 30 美元，还可以换架子鼓需要加 35 美元，再计算黑胶唱片，黑胶唱片可以换吉他需要加 15 美元，还可以换架子鼓需要加 20 美元，和第一步的相加可以算出，通过黑胶唱片这条路径前往，开销最短，更新上一步中最便宜的节点为黑胶唱片。从乐普换吉他最少需要花 20 美元，换架子鼓最少需要花 25 美元。所以下一个最便宜的节点是海报。 三、优先从吉他出发，计算其邻居节点开销。吉他的邻居就是钢琴，需要加 20 美元，总开销加上之前的 20 美元是 40 美元，再从架子鼓出发，计算架子鼓到其邻居节点的开销，架子鼓的邻居节点也是钢琴，开销 10 美元，加上之前的 25 美元总开销是 35 美元，所以更新最优节点是架子鼓。 最终路径是从乐谱-&gt;黑胶唱片-&gt;架子鼓-&gt;钢琴。 算法实现 需要三个散列表，一个用来存储整个图结构，一个用来存储节点的开销，最后一个用来存储节点的父节点。算法执行流程图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// 狄克斯特搜索算法// 参数g：图形结构散列表// costs:节点开销散列表 inout 关键字可以是得函数内部可以修改外部参数的值// parents: 父节点散列表// targetNode:目标节点// 返回值：（总的最少花销，最短路径步骤，排序数组）func search(costs:inout [String :Int], parents:inout [String: String?], targetNode: String, inGraph g: [String : Any]) -&gt;(Int, String)&#123; // 存储处理过的节点 var processed = [String]() // 找出最便宜的节点 func findLowerCostNode(_ costs: [String:Int]) -&gt; String? &#123; var lowestCost = Int.max var lowerCostNode: String? for (key, value) in costs &#123; // 遍历开销散列表，找出没有处理过且到起点花费最小开销的节点 if value &lt; lowestCost &amp;&amp; !processed.contains(key)&#123; lowestCost = value lowerCostNode = key &#125; &#125; return lowerCostNode &#125; var node = findLowerCostNode(costs) // 遍历所有的节点 while (node != nil) &#123; // 节点开销 let cost = costs[node!] // 遍历当前节点的所有的邻居节点 var neighbors = graph[node!] for n in (neighbors?.keys)! &#123; // 判断该邻居节点如果从当前节点经过的总开销是否小于该邻居节点原来的开销，如果小于，就更新该邻居节点的开销 let new_cost = cost! + (neighbors?[n])! if costs[n]! &gt; new_cost &#123; // 更新该节点的邻居节点的最新最短开销 costs[n] = new_cost // 更新该邻居节点的父节点为当前节点 parents[n] = node! &#125; &#125; // 将当前节点标记为已经处理过的节点 processed.append(node!) // 继续寻找下一个最少开销且未处理过的节点 node = findLowerCostNode(costs) &#125; // 到达目标节点的最少开销 let minCost = costs[targetNode] // 最短路径 var minRoadArray = [targetNode] var parent:String? = targetNode while parents[parent!] != nil &#123; parent = parents[parent!]! minRoadArray.append(parent!) &#125; return (minCost!, minRoadArray.reversed().joined(separator: "-&gt;"))&#125;// 测试 ————————————————————-------------------------------------------// 1. 存储图结构var graph = [String : Dictionary&lt;String, Int&gt;]()// 乐谱的邻居节点graph["乐谱"] = [String : Int]()// 到唱片的开销graph["乐谱"]?["黑胶唱片"] = 5// 到海报的开销graph["乐谱"]?["海报"] = 0// 唱片节点的邻居节点graph["黑胶唱片"] = [String : Int]()// 唱片节点到吉他的开销graph["黑胶唱片"]?["吉他"] = 15// 唱片节点到架子鼓的开销graph["黑胶唱片"]?["架子鼓"] = 20// 海报节点的邻居节点graph["海报"] = [String : Int]()// 海报节点到吉他的开销graph["海报"]?["吉他"] = 30// 海报节点到架子鼓的开销graph["海报"]?["架子鼓"] = 35// 吉他节点的邻居节点graph["吉他"] = [String : Int]()// 吉他节点到钢琴的开销graph["吉他"]?["钢琴"] = 20// 架子鼓节点的邻居节点graph["架子鼓"] = [String : Int]()// 架子鼓节点到钢琴的开销graph["架子鼓"]?["钢琴"] = 10// 钢琴节点graph["钢琴"] = [String : Int]()print(graph)// 2. 创建开销表，表示从乐谱到各个节点的开销var costs = [String : Int]()// 到海报节点开销costs["海报"] = 0// 到黑胶唱片节点开销costs["黑胶唱片"] = 5// 到钢琴节点开销，不知道，初始化为最大costs["吉他"] = Int.max// 到钢琴节点开销，不知道，初始化为最大costs["架子鼓"] = Int.max// 到钢琴节点开销，不知道，初始化为最大costs["钢琴"] = Int.maxprint(costs)// 3. 创建父节点表var parents = [String : String?]()// 海报节点的父节点是乐谱parents["海报"] = "乐谱"// 黑胶唱片的父节点是乐谱parents["黑胶唱片"] = "乐谱"// 吉他的父节点，不知道parents["吉他"] = nil// 架子鼓的父节点，不知道parents["架子鼓"] = nil// 钢琴的父节点， 不知道parents["钢琴"] = nilprint(parents)// 测试var (minCost, minRoadString) = search(costs: &amp;costs, parents: &amp;parents, targetNode: "钢琴", inGraph: graph) 打印日志： 贪婪算法贪婪算法是一种通过寻找局部最优解来试图获取全局最优解的一种易于实现、运行速度快的近似算法。是解决 NP 完全问题（没有快速算法问题）的一种简单策略。书上总共举了四个例子来说明贪婪算法的一些场景。 1. 教师调度问题有如下课程表，要怎么排课调度，使得有尽可能多的课程安排在某间教室上。 这个问题就可以使用贪婪算法来解决。 选出结束最早的课，他就是要在这件教室上的第一节课。 接着，选择第一节课结束后才开始的课，同样选择结束最早的课，这就是要在这件教室上的第二节课。重复这样做，就能找出答案。 2. 背包问题这个问题是这样的，如何在容量有限的背包中装入总价值最高的商品。这个问题不适用贪婪算法，按照贪婪算法，每次都需要往背包里先装最大价值的商品，然后根据背包剩余容量，再选择最大价值的商品，这样有可能背包的空间利用率不是最高的，却不一定会是最优解。 2. 集合覆盖问题背景是这样的，有个广播节目，要让全美 50 各州的听众都能听到，需要在选出覆盖全美 50 各州的最小广播台集合。如果要需求最优解，可能的子集有 2^n 次方个，如果个广播台很多，那么这个算法的复杂度将非常之高，几乎没有任何算法可以足够快速的解决这个问题，而使用贪婪算法可以快速的找到近似解，算法的复杂度是 O(n^2)。步骤如下： 选择一个覆盖最多未覆州的广播台，即时已经覆盖了一些已经覆盖过的州也没关系。 重复第一步，知道覆盖了所有的州。 代码模拟实现： 1234567891011121314151617181920212223242526272829303132333435363738// 要覆盖的州列表var statesNeeded = Set([&quot;mt&quot;, &quot;wa&quot;, &quot;or&quot;, &quot;id&quot;, &quot;nv&quot;, &quot;ut&quot;, &quot;ca&quot;, &quot;az&quot;])// 广播台清单var stations = [String: Set&lt;String&gt;]()stations[&quot;kone&quot;] = Set([&quot;id&quot;, &quot;nv&quot;, &quot;ut&quot;])stations[&quot;ktwo&quot;] = Set([&quot;wa&quot;, &quot;id&quot;, &quot;mt&quot;])stations[&quot;kthree&quot;] = Set([&quot;or&quot;, &quot;nv&quot;, &quot;ca&quot;])stations[&quot;kfour&quot;] = Set([&quot;nv&quot;, &quot;ut&quot;])stations[&quot;kfive&quot;] = Set([&quot;ca&quot;, &quot;az&quot;])// 最终选择的广播台集合var finalStations = Set&lt;String&gt;()// 如果要覆盖的州列表不为空while !statesNeeded.isEmpty &#123; // 覆盖了最多没覆盖州的广播台 var bestStation:String? // 已经覆盖了的州的集合 var statesCovered = Set&lt;String&gt;() // 遍历所有的广播台 for (station, states) in stations &#123; // 取交集操作 let covered = statesNeeded.intersection(states) if covered.count &gt; statesCovered.count &#123; bestStation = station statesCovered = covered &#125; &#125; // 取差集操作 statesNeeded = statesNeeded.subtracting(statesCovered) finalStations.insert(bestStation!)&#125;// 打印print(finalStations) // [&quot;ktwo&quot;, &quot;kfive&quot;, &quot;kone&quot;, &quot;kthree&quot;] 对比一下两种算法的运行效率差异： 3. 旅行商问题旅行商问题的背景是一个旅行商商想要找出前往若干个城市的最短路径，如果城市数量少，比如两个，可能的路径有 2 条，三个城市有 有 6 条，4 个城市有 24 条，5 个城市有 120 条，n 个城市有 n! 个可能路线，n! 复杂度是一种非常难以快速找出最优解的问题。就可以考虑贪婪算法快速地去求近似解。 4. 如何判断 NP 完全问题上面的集合覆盖问题和旅行商问题都是 NP 完全问题，如果能够判断出问题属于 NP 完全问题，就可以考虑贪婪算法求近似解的策略了，但是判断 NP 完全问题并不容易，作者归纳了一些常见场景： 随着元素增加，速度会变得非常慢。 涉及所有组合的问题通常是 NP 完全问题。 不能将问题分成小问题，必须考虑各种可能的情况。也可能是 NP 完全问题。 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，可能就是 NP 完全问题。 如果问题涉及集合（如广播台集合的例子）且难以解决，可能就是 NP 完全问题。 如果问题可转换成集合覆盖问题或者旅行商问题，那肯定是 NP 完全问题。 动态规划动态规划常用来解决一些在给定约束条件下的最优解问题，如背包问题的约束条件就是背包的容量，一般可以将大问题分解为彼此独立且离散的小问题时，可以通过使用网格，每个小网格就是分解的小问题的手段的方式来解决。使用动态规划来解决的实际问题场景有： 最长公共子串、最长公共子序列来判断两个字符串的相似程度。生物学家通过最长公共序列来确定 DNA 链的相似性。 git diff 文件对比命令，也是通过动态规划实现的。 word 中的断字功能。 K 最近邻算法KNN 用来分类和回归，分类是编组，回归是预测一个结果。通过特征抽取，大规模训练，然后比较数据之间的相似性，从而分类或是预测一个结果。有如下常见应用场景： 推荐系统。 机器学习。 OCR（光学字符识别），计算机通过浏览大量的数字图像，并将这个图像的特征提取出来，遇到新图像时，从数据中寻找他最近的邻居。 垃圾邮件过滤器，通过使用朴素贝叶斯分类器计算出邮件为垃圾邮件的概率。 预测股票市场。 其他一些算法介绍 树，二叉查找树，左子节点的值总比自己小，右子节点的值总比自己大，可以用来优化数组插入和删除的复杂度底的问题，二叉查找树的查找、插入、删除的复杂度都是O(logn)。 反向索引。一种将单词映射到包含他的页面的数据结构，可用于创建搜索引擎。 傅里叶变换。傅里叶变换可以将数字信号中的各种频率分离出来，可计算歌曲中每个音符对整个音乐的贡献，用来做音乐压缩，音乐识别等。 并行算法。利用设备的多核优势，提高算法的执行性能。也会有一些额外开销，如并行性管理和负载均衡。 MapReduce。一种分布式并行算法，可让算法在多台计算机上运行，非常适合用于在短时间内完成海量工作，MapReduce的两个概念，映射（map）和归并（reduce）函数。映射（map）是将序列中的元素都执行一种处理然后返回另一个序列，归并（reduce）是序列归并为一个元素。MapReduce 使用这个两个概念在多台计算机上执行数据查询，能极大的提高速度。 布隆过滤器和 HypelogLog。布隆过滤器是一种概率性数据结构，有点在于占用空间小，非常适用于不要求答案绝对准确的情况。HypelogLog 近似地计算集合中不同的元素数，也是类似于布隆过滤器的一种概率性算法。 SHA 算法。SHA 算法是一种安全散列算法，给定一个字符串，SHA 算法返回其散列值，可用来比较文件，检查密码。 局部敏感散列算法。Simhash 是一种局部敏感散列算法。如果字符串只有细微的差别，那么散列值也只存在细微的差别，这就能够用来通过比对散列值来判断两个字符串的相似程度，也很有用。 Diffie-Hellman 秘钥交换算法。可用来解决如何对消息加密后只有收件人能看懂的问题。这个种算法使用两个秘钥，公钥和私钥，公钥是公开的，发送消息使用公钥加密，加密后的消息只有使用私钥才能解密。通信双方无需知道加密算法，要破解比登天还难。 线性规划。线性规划算法用于在给定约束条件下最大限度地改善指定的指标。线性规划使用 Simplex 算法，是一种非常宽泛的算法，如所有的图算法都可以用线性规划来实现，图问题只是线性规划的一个子集。 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「青争哥哥」。]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《当我谈跑步时，我谈些什么》读书笔记--我跑，故我在]]></title>
    <url>%2F2019%2F04%2F30%2F%E3%80%8A%E5%BD%93%E6%88%91%E8%B0%88%E8%B7%91%E6%AD%A5%E6%97%B6%EF%BC%8C%E6%88%91%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%88%91%E8%B7%91%EF%BC%8C%E6%95%85%E6%88%91%E5%9C%A8%2F</url>
    <content type="text"><![CDATA[前言这本书是村上春树写得一本关于自己跑步的随笔集，记录了村上几十年来跑步训练、马拉松比赛的一些心情日志和对跑步的感悟，其实大学时期就读过了，不过那时候刚刚跑步不久，读完也没啥印象了，现在跑步也已经七八年了，马拉松也跑了快十场，再读这本书，就稍微有点感觉了，如果你也是一个爱跑步的人，我想也会有一些相似的体会吧，于我而言，觉得有感觉的地方有以下几点： 为什么是跑步？ 跑步简单。跑步对人类而言是一种天生的本能，每个人基因里天生就会跑，而且不需要同伴，一点不复杂，只需要一双合脚的跑鞋，说跑就跑了。 跑步平等。这个参加马拉松比赛就会有体会了，不论你的种族、肤色、年龄、性别、都是站在同一起跑线、同一个 42.195 公里的赛道上公平竞技，享受同样的饮料事物补给，同样的加油鼓励。 对精神健康的意义。一天跑步一个小时，来确保只属于自己的沉默时间，至少在在跑步的时候，不需要和任何人交谈，只需要眺望周围的风光，凝视自己就行。 哲学意义。无论何等微不足道的举动，只要日日坚持，从中总会产生出某些类似客观认知的东西来。我自己有过一些跑步的心灵高峰体验，那是一种通过跑步达到的身体和精神协调一致的状态，是呼吸，步伐、摆臂产生的秩序美感，是整个人完全像是一种工业化的惯性在前进，每公里配速几乎不差几秒，心情非常舒服愉悦，完全不累的状态。还有一种状态是我未曾体验过的，就是村上跑 100 时公里描述的，75 公里后整个人进入自动驾驶状态，感知不到了自己肉体的痛苦，连自己是谁也不知道，整个时候跑步达到形而上学的领域。我跑，故我在。 跑步倦怠期——跑者蓝调无论如何，跑步并不总是能让人一直感受到愉悦。如刚开始跑步时候，可能跑个1000米就气喘吁吁了，恶心，想吐，肚子疼，但这一阶段一般不会很长，只要循序渐进，慢慢提高自己体能，掌握正确的跑步姿势和呼吸，就能陆续得到跑步对你的馈赠，这个时候，只要继续坚持跑步，你会感觉越来越舒服，身体更好，不感冒了，精神状态也会更好，接着，你可能会想要跑一场真正的马拉松了，你会变得追求配速、会对跑步装备上心，追求不断pb，但与此同时对你的训练要求也更高了，你需要很系统的训练计划，很强的执行力，有时候心太急还会遭遇伤病，会让人沮丧，成绩也并不总是能一直提高，付出得不到应有的回报，村上把这个称作跑者蓝调。并且伴随着工作、家庭、年龄的变化，也会有一部分跑者进化成了佛系跑者。 跑步时，在想些什么？我觉得这个和跑步难度或者距离有关系。日常维持体能的匀速跑，可能什么都会想，工作、生活啊，最近发生的事情啊，也可能什么不会想，放空自己，只关注周围的风景和耳机里的音乐。另外如果是跑马拉松的话，可能前半程会想一下怎么控制速度，到补给站了要不要补充等问题，后半程可能想得更多的是怎么能够完成比赛吧，用什么样的方式说服自己和身体的疲劳感作斗争，也可能会不停给自己“还有不到x公里就到了“的心里暗示，村上写他跑希腊马拉松完赛时也这样写到： 终于跑到了终点，什么成就感，根本毫无感觉，满脑子是终于不用再跑了的安心感。 一些摘抄p2任何一把剃刀都有其哲学的解释： 无论何等微不足道的举动，只要日日坚持，从中总会产生出某些类似客观认知的东西来。 p8长期作业的一种方法论，以协作为例： 在似乎可以写下去的地方，果断地停下笔来，这样第二天重新着手时便易于进入状态。 p14 在长跑中，如果有什么必须要战胜的对手，那就是过去的自己。 p16村上的跑者蓝调： 期间所有付出的努力都得不到报偿的失望，有理应敞开的门户不知何时却被关上的茫然，我称这些为”跑者蓝调“。 p24跑步认识自己： 当受到某人无缘无故的非难时，或是觉得能得到某人的接受却事与愿违时，我总比平日跑得更远一些。跑长于平日的距离，让肉体更多地消耗一些，好重新认识自己是个能力有限的软弱人类——从最深处物理性地认识这一点。 p47对为什么能够坚持跑步的解释： 人生来如此，喜欢的事自然可以坚持下去，不喜欢的事却怎么也坚持不了。 p78每天跑步： 每天跑步对我来说好比生命线，不能说忙就抛开不管，或者停下来不跑了。忙就中断跑步的话，我一辈子都无法跑步了。坚持跑步的理由不过一丝半点，中断跑步的理由却足够装满一辆大型载重卡车。我们只能讲那”一丝半点的理由“一个个慎之又慎地不断打磨，见缝插针，得空就孜孜不倦地打磨他们。 p87跑步的本质： 同样是十年，与其稀里糊涂地活，目的明确、生气勃勃地活当然令人更满意。跑步无疑大有裨益。在个人的局限中，可以让自己更有有效地燃烧，哪怕是一丁点，这便是跑步一事的本质，也是活着一事的隐喻。 p119跑步定下的原则： 不管奔跑速度降低多少，我都不能走，这是原则。违背了自己定下的原则，哪怕只有一次，以后就将违背更多的原则，想跑完这场比赛就难上加难了。 p175 一旦把握住了节奏，只需维持即可。 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「马码」。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>跑步</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人类简史》读书笔记-一切并不是那么理所当然]]></title>
    <url>%2F2019%2F03%2F29%2F%E3%80%8A%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80%E5%88%87%E5%B9%B6%E4%B8%8D%E6%98%AF%E9%82%A3%E4%B9%88%E7%90%86%E6%89%80%E5%BD%93%E7%84%B6%2F</url>
    <content type="text"><![CDATA[前言作者：[以色列] 尤瓦尔·赫拉利翻译：林俊宏出版年份：2014-11 在看到这本书的名字还没正式读之前，我有个预设，人类简史，是本历史书吧，于是我开始联想在脑海里面存储的有关历史书的一些感性认识，我想到了中学历史课本，想到《史记》、《左传》、《战国策》、《资治通鉴》，通常来讲，我印象里面的历史书应该大体约莫是一些历史事件的罗列、历史人物的英雄故事记录，典故渊源等诸如此类，如被鲁迅评价为史家之绝唱，无韵之离骚的太史公写的《史记》，包含了纪、表、书、世家、列传五类，写得也都是历史事件和王侯将相的生平事迹。基本上看不到关于某个普通个体在历史进程中的有关信息，他或她在不同的历史时期过得怎么样呢？被我们驯化的牛羊鸡鸭他们开心吗？我们全然不知，可能也并不在意。借用一句流行的话——历史是胜利者书写的！也如作者书中所言： 大多数的历史书籍强调的都是伟大的思想家、英勇的战士、慈爱的圣人，以及创造力丰沛的艺术家。这些书籍对于社会结构的建立和瓦解、帝国的兴衰、科技的发明和传播，都可以说是知无不言、言无不尽。但对于这一切究竟怎么为个人带来快乐或造成痛苦，却是只字未提。 而当我读完这本《人类简史》后，我惊奇地发现，作者写得历史和我以往概念中的历史书很不一样啊，作者是站在间谍卫星的高度（不是几世纪，而是几千年的时间跨度）来看待人类几百万年来发生的历史，他提出了更接近本质的改变人类生活方式的三次革命，分别是让历史启动的认知革命、让历史加速发展的农业革命、让历史画句号并创造新局面的科学革命。与此同时，作者也以整个生态环境为视角，摒弃人类中心主义，不忽视单个人类个体和其他物种、自然环境在人类历史进程中的命运纠结。 作者以不到 400 页厚度的书，感觉信手拈来引用了很多物理学、生物学、政治学、经济学、文化学、宗教学、生态学、人类学等诸多学科的知识，既写清楚了人类从一个没什么特别的物种如何通过三次革命演化到现在几乎接近神的智人的整个演化历程，又对整个历史过程中被忽略的个体、其他物种、环境加以关怀，对智人的未来忧虑和思考，体现了作者的博爱之心。很多作者列举的史料和论据知识由于我并不具备，因此也很难辨别真伪，但透过字里行间，也能获得一些感性浅显的体会，下面写得就是我阅读完整本《人类简史》带给我的感受。 陷阱、骗局，要怀疑一切吗？作者在书中说很多我们以为理想当然的东西其实并没有那么的理想当然，也有可能是场骗局或是陷阱。 如农业革命，通常我们会认为，农业革命是人类的大跃进，是由人类脑力所推动的进步故事。可作者却说农业革命其实是场骗局，起初，人类仅仅是为了生活过的好一点或者是某种神圣的信仰的目的，开始锄地认真地种小麦、水稻等农作物，细心呵护，希望自己多干一些、辛苦一点，能够多产出一些，养活更多的人，但没有想到的是随着时间的推移，农业革命造成的后果确是人口越来越多、食物越来越不够吃，并产生了少数养尊处优的精英分子，农业革命后人类就需要越来越辛苦努力，与此同时，由于饮食上的的单一，造成免疫力下降，人类的死亡率也升高，对土地资源的占领意识也极大加强，从而引发更大更残酷的暴力。虽然从生物演化的角度上看，农业革命对人类整体物种的基因传播起到了重要的积极作用，但对人类个体而言，相比较农业革命前采集狩猎时代的智人，那时智人过着只需要每三天打猎一次，每天采集 3 ~ 6 个小时，饮食上多样化，能抵御传染疾病、饥饿、营养不良，对周遭环境，动植物的了解的更深、更广更多样，被称为最初的富裕社会的生活状态，却是更辛苦更糟了，所以作者说农业革命的真正本质是让更多的人以更糟的情况活下去。与其说是人类驯化了小麦，不如说是小麦驯化了人类。 不仅如此，被人类驯化的牛、羊、马、鸡、鸭等也从此迎来了灾难性的命运，他们本可以在自然界活得更自由、寿命更长，而农业革命后，要被人类无情残忍地阉割、宰杀、限制自由，成为这场革命的受害者。 人类不会想到本来只是想让生活变得轻松的努力却给人类自己带来了无穷的麻烦，等到发现时，却深陷其中，无法回头。 这种故事在历史上也不会是最后一次，历史总是重复上演相似的故事。如现代经济增长的故事。从 15 世纪的欧洲开始，资本主义联合帝国的力量，促使爆发了科学革命，科学成果又反过来促进资本主义和帝国的统治，这就是科学、帝国、资本之间回馈循环系统的故事，于是资本主义发展成为了最成功的现代宗教，而现代经济增长的故事也就此开始。诚然，资本主义现代经济让我们有了更好的房子，更多的商品、更长的寿命等等诸多好处，可作者认为这也或许是个巨大的骗局。 第一，资本主义现代经济增长故事之所以能够发生是因为他有一个前提：人类愿意信任未来，相信未来的资源肯定远远超过目前的资源，资本主义经济理论将人类的这种目前还不存在、只存在于想象之中的信用变成货币和金钱的概念，认为只要认真对投资进行研究，一切就能变得更好。所以只要经济的大饼能一直变大，这个故事就也能讲下去。虽然截止到目前为止，人类的现代经济一直不可思议的在持续增长，原因是科学家总能每隔几年就取得一项发现、一项发明、如各种新能源、新科技，降低生产成本，提高利润，于是政府和银行只需要印钞票，最后科学家来买单就行。但未来变化莫测，当未来有一天科学家终于再也没有新发现没有新发明了，能源耗尽了又找不到新能源了，或者科学家的速度赶不上政府和银行印钞票的速度，不就出现经济泡沫了吗？这是一个值得深刻思考的问题。 第二，资本主义的地狱。资本主义现代经济并非只有好的一面，他也有残忍邪恶的一面，自由资本主义是一种不受控制的市场力量，一旦政府没有及时控制住或者一旦和资本主义勾结在一起，那就是灾难性的后果，会充满着各种欺诈、盗窃和暴力。历史上有很多这样的例子，如欧洲帝国殖民化对非洲黑人、美洲原住民、印度人的残酷压迫和剥削，其根本原因就在于资本主义的本质是贪婪。贪婪就像是硬币的一体两面，一面是让经济是能够持续增长的力量，一面是不受控制的邪恶。我们都不会忘记我们国家的近代史就是一部落后挨打的灾难史，第一次鸦片战争就是因为英国国会政府被资本家影响和绑架了，资本主义为了利益要打开中国的国门，将鸦片倾销到中国，我们不同意，就用枪炮打我们，这不就是强盗吗？然而历史从无正义。 第三，资本主义的现代经济将不断拉大贫富差距。经济大饼在变大，穷人分配到的数量虽然也在增大，但占比却在减小，这就是现实，就拿我们现在的生活来说，不知道大家是否有所发觉，从概率上说，个体的奋斗努力对于能否成功（或许每个人对于成功的定义不一样，暂且这么说吧，可以当做是一种虚拟的概念，就是社会普遍追求的所谓美好生活）所占的比例越来越小了，一个人能否成功很大部分取决于先天优势。拿买房子举例，普通人要想在大城市买房子，是不是很难，因为工资虽然多了，但购买力下降了，而各种消费主义的思想观念却大行其道，什么刺激消费、消费升级、轻奢主义、各种购物狂欢节等等。按照作者的说法，这是资本-消费主义道德伦理在起作用，有钱人的最高指导原则依旧是投资，而剩下的其他人的最高指导原则就变成了购买。现代人活得更辛苦了，可能我们既比不了采集狩猎时代一周工作三天，一天 3 ~6 个小时的智人，甚至农业革命后的农民我们也比不了，就像前两天有很多程序员在 githup 上控诉公司严重加班的 996.icu 项目，还有很多年轻人都佛系了。让我们不禁要问一下，对普通个体而言，现代的经济增长真的是个进步的故事吗？ 甚至于随着科技发展下去，人类有可能能够战胜死亡或者移民外太空，如果真是这样，有人不死，有人要死，那么谁先能不死呢？有人只能依赖地球家园，有人可以移民外太空，那么谁更有机会呢？如果有部分人类不再依赖地球家园了，那么他们还会珍惜吗？剩下的人要怎么办呢？这也并不会很遥远，去年就有一条新闻讲日本有个富豪预定了去火星的太空之旅。如果人类社会、伦理、经济秩序没有同步发展到能够支撑和掌控这些科技成果的时候，整个人类社会就会混乱一片。所以作者这样说： 我们这个现代晚期的世界，是有史以来第一次认为所有人类应享有基本上的平等，然而我们可能正准备要打造出一个最不平等的的社会。纵观历史，上层阶级总是说自己比下层阶级更聪明、更强壮，整体而言更为优秀，他们过去通常只是在自欺欺人，贫苦农家的孩子智力上很可能和王子也相去不远。然而，在新一代医药推波助澜下，上层阶级的自命不凡可能即将成为一种客观事实。 第四，对地球生态系统的破坏。当经济飞奔向前的时候，我们周遭的环境却遭到了巨大的破坏，森林被砍伐了、空气河流被污染了、其他物种的生存空间被现代人挤压，慢慢灭绝了，生态平衡终于慢慢在被打破，虽然人类的能力已经很强并且可预见会越来越强，对生态环境的依赖也在降低，但也许在我们还没能够完成太空移民前，人类对地球生态环境的破坏就将人类自己反噬掉了，只要海平面持续上升，陆地面积就会减少到人类没有家园，或者空气氧气浓度持续下降，人类就将窒息而亡，类似种种。这并不是危言耸听，越来越多反常诡异的自然现象已经在给我们敲响警钟。 第五，人类自己玩死自己。苏联解体时，有人预测苏联人拥有的核弹数量可以将地球摧毁 N 多次，那是 1991 年，人类已经拥有了结束历史进程的能力，万一那个手握核武器发射按钮的国家元首突然精神失常，按下发送，人类也就完了，虽然这种概率很低。另外一个就是人类对手中能力的掌控尺度，吉尔伽美什计划已经让科学所做的一切有了正当的理由，现在有些很前沿的研究，如基因工程，仿生人、AI机器人，已经很强大了，AlphaGo 战胜人类大脑已经是几年前的事情了，未来会发展什么样，我们很难想象，或许我们正在接近下一个奇点，所有我们现在这个世界的意义（无论你我、男女、爱恨）都即将变得再也无关紧要。而在那个点之后的任何事，都还超出我们现在所能想象的。 天龙八部里面有个情节，鸠摩智偷学了少林寺很多绝技，结果却走火入魔，扫地僧对他说，自古至今少林寺只有达摩祖师一个人练成 72 项绝技，因为每练一项绝技，就需要同时修一门佛法化解武功的戾气，鸠摩智只练绝技不修佛法于是就走火入魔了。所以对于人类来说，在我们拥有了这么多的能力后，是不是也要修炼一下自己的佛法呢？所以作者说可能我们人类真正该问的问题不是我们究竟想要变成什么？而是我们究竟希望自己想要什么？。 第六，我们变快乐了吗？通常认为，历史不断进展，人类的能力也不断增加，人类会运用掌握的能力来减轻痛苦、满足愿望，我们应该会更快乐才对。但作者在书中提出了不同的看法，作者在书中探讨了快乐常见的几种解释。 快乐是一种主观感受。影响人类快乐的因素主要是物质和精神方面，有更多的金钱、更好的身体、紧密的社群、家庭关系等。现代社会确实让人类的物质方面得到了很大的提高，但在精神上，新的社会秩序导致了家庭和地方社群崩溃，现代人越来越孤独，可能两者的作用相互抵消，现代人并没有比过去更快乐。 快乐是在于客观条件和主观期望之间是否相符。比如我是穷人，我的期望只是想要一辆自行车，我努力工作赚钱买到了，我就快乐，假如我是个富豪，可能我的期望就不是一辆自行车了，我可能有更高的期望，如果这个时候给我一辆自行车，我可能不一定快乐。按照这个思路，古人可能对物质条件的期望也比现代人更低，不能将现代人自己的期望放到古人的那个环境下来评判，所以也很难讲现代人就一定比古人更快乐。 快乐是种快感。快乐与否只是一种生化机制，谁身体的血清素、多巴胺多那么他就更快乐，天生忧郁的人很少能够快乐。但根据相关的研究，快乐体质的的基因并没有更多的被遗传，忧郁体质的基因也没有更少的被遗传，人体的这套生化机制总是维持在一个平衡的水平。另外，如果快乐只是快感，只需要找到某种能够提高人体清素、多巴胺浓度的药物，如百忧解，注射到人体，不就所有人都快乐了吧，但这会有什么问题呢，这种理论很难解释痛并快乐着这句话，有时候我们做一件事可能并没有快感，但我们能感受到幸福快乐，如养小孩。 快乐在于生命的意义。不同的社会、不同的时代的人，身体感受到快乐的生化机制都是一样，然而由于对生命赋予的意义却大不相同，感受到的快乐也不一样，如中国古代文人普遍的理想就是修身齐家治国平天下，做到了生命就有意义，就开心，虽死无憾。但从科学的角度看，人类的生命本没有意义，诸如现代的人文主义、民族主义和资本主义都没有什么意义，所谓的快乐，很可能只是让个人对意义的错觉和现行的集体错觉达成同步而已。 快乐在于放下主观追求感受这件事。这个是佛教理论，佛教认为真正的快乐既不在于主观感受到愉悦、也不是主观觉得生命有意义，而是在于放下主观追求感受这件事。 最后，作者书中对快乐的研究也没有得出最终的结论，但作者认为，我们过去对于快乐的这件事的历史认知可能是错误的，究竟期望该不该得到满足、感受是否快活都不是重点，真正重要的问题在于人类是否了解自己，今天没有足够的证据证明现代人就比过去的人更了解自己。 无法逃脱的虚构想象？大约 7 万年 ~ 3 万年前，智人间出现了某次偶然的基因突变，导致智人开始发生认知革命。认知革命给智人逐步带来了河边有只狮子、八卦、虚构想象的能力。 河边有只狮子使得智人能够和同类描述周围的环境，合作捕猎，躲避危险。这是认知革命的最初阶段。 八卦的能力使得智人能组织最大到 150 人的团体进行更紧密合作，形成团体作战的能力。 虚构想象的能力是认知革命中智人最大最重要的能力，通过虚构想象，智人创造出国家、宗教、神、贸易、法律、人权等概念，使得大量的陌生人能能够展开合作，共同相信这种虚构想象，并且智人同时能够创新这些虚构想象，使得智人的演化跳过了传统基因演化的通道，大大加快了智人的演化速度。 虚构想象构建的秩序本质上是虚构的故事，不同于稳定不变的自然界秩序，总有一朝崩溃的风险，只要人们不再相信这些就行了，何以虚构想象会如此的强大，人类无法脱离？ 第一，相信这种虚构想象的秩序可以让人提升合作效率、打造更完美的世界。第二，军队、警察、法院和监狱等国家力量发挥作用。第三，大部分的社会精英分子相信支持。第四，对外的说法永远强调想象的秩序是千真万确、是客观事实、是由伟大的神或者是自然法则所创造、 并在教育上彻底如一贯彻。第五，想象的秩序与真实世界结合、塑造了人类的欲望、存在于人与人之间的思想连接（主体间）等原因，导致人类不会发现组织自己生活的秩序其实是种想象。第六，为了改变由想象构造的秩序，需要先用想象构造出另外一套秩序，而这并不容易，想象一下中国近代的新民主主义革命是多么艰难就知道了。 回顾一下历史上存在的那些虚构想象，美洲的洁净观念，对黑人的歧视、种族主义、女性性别歧视、同性恋歧视、父权制度、人类中心主义。这些其实统统并没有生物学上的基础，而只是基于毫无根据的虚构概念。一切并不是那么理想当然。但不幸的是，复杂的人类社会似乎就是需要这些由想象建构出来的阶级制度和歧视。 全球性帝国写到这里，未免有些悲观。可喜的是作者同时也告诉我们，当今世界正进入一个比历史上任何时期都要和平的年代。 经济上的货币秩序、政治上的帝国秩序、宗教上的全球性宗教相互作用，正在让人类社会进入一个全球性帝国，这个帝国不受任何特定国家或族群管辖，由多民族的精英共同统治，并且是由共同的文化和共同的利益结合。在世界各地，越来越多的企业家、工程师、专家、律师和经理人正在得到召唤，一起加入这个帝国。 全球性帝国让国际网络日渐紧密，多数国家无法再维持全然独立，任何经济和外交政策都不可能自外于他国，全面性的战争也不可能独自发动，战争成本高昂、和平利润更多。这个帝国会努力维持自己疆域内的和平，只是这个疆域变成了整个地球。 最后，成功不仅要靠努力奋斗，还要考虑到历史的进程。明清政府就是闭关锁国，不知道历史的进程已经进入到了新的阶段，还做天朝帝国美梦，结果被那些如同来自外层空间的侵略者按在地上摩擦，阿兹特克人同样也因为视野狭隘而被西班牙侵略者诱骗欺诈，付出了沉重的代价。 学习了解历史，我们会发现，历史上的很多现象都不是那么地理所当然。 一些摘抄p84奢侈生活的陷阱教训： 原本的奢侈品往往最后会变成必需品，而且带来新的义务。等到习惯某种奢侈品，就开始认为这是天经地义。接着就是一种依赖。最后生活中就再也不能没有这种奢侈品。人类一心追求更轻松的生活，于是释放出一股巨大的力量，改变了世界的面貌，但结果并没有任何人料想到，甚至也不是任何人所乐见的。 p98农业革命给农民带来了什么： 可悲的是，虽然农民勤劳不懈、希望能够保障自己未来的经济安全，但这几乎从来未曾实现。不管在什么地方都出现了统治者和精英阶级，不仅靠着农民辛苦种出的粮食为生，还几乎全征收抢光，只留给农民勉强和过活的数量。正是这些征收来的多余的粮食，养活了政治、战争、艺术和哲学，建立起宫殿、堡垒、纪念碑和庙宇。 p113人类无法摆脱想象建构的秩序： 身为人类，我们不可能脱离现象所建构的秩序。每一次我们以为自己打破了监狱的高墙、迈向自由的前方，其实只是到了另一间更大监狱，把活动范围稍稍加以扩大而已。 p138对阶级制度恶性循环的控诉： 随着时间流逝，不公不义的歧视只是加剧而不是改善。富者越富，而贫者越贫。教育带来进一步教育，而无知只会造成进一步的无知。历史上过去的受害者，很可能会再次受害。而历史上过去的特权分子，他们的特权也可能依然存在。 p145文化对性别的约束： 从出生到死亡，男性必须一辈子不断通过各种仪式和表演来证明自己真的是条汉子。而女性也永无宁日，必须不断说服自己和其他人自己散发着女人味。而且，这种成功没得保证，特别是男性，总是很害怕别人觉得自己没有男子气概。在整个历史上，总看到男性愿意冒险犯难甚至牺牲生命，只为了让人夸赞一句：他是个真正的男人！ p176对金钱积极一面的看法： 所有人类创造的信念之中，只有金钱能够跨越几乎所有文化鸿沟，不会因为宗教、性别、种族、年龄或者性取向差异而有所歧视。也多亏有了金钱制度，才让人就算互不相识、不清楚对方的人品，也能携手合作。 p225为什么要学历史： 我们之所以研究历史，不是为了要知道未来，而是要拓宽视野，要了解现在的种种绝非“自然”，也并非无可避免。 p361对有钱人能长生不老的看法： 纵观历史，穷人和受压迫者之所以还能自我安慰，就是因为死亡是唯一完全公平的事情。不论再富有，权利再大，人也难逃一死。光想到自己得死，但有钱人居然能长生不老，就会让穷人怒火中烧，不可遏抑。 p368如果快乐在于追求生命的意义。 但也就是说，我们对于生活所赋予的任何意义，其实都只是错觉，所谓的快乐，很可能只是让个人对意义的错觉和现行的集体错觉达成同步而已。这个结论听起来似乎让人难过，难道快乐真的就只是种自我欺骗吗？ p370佛教对于快乐的观点，这就是佛系啊！ 苦的根源既不在于感到悲伤或者疼痛，也不在于感觉一切没有意义。苦的根源在于“追求”主观感受这件事情，不管追求什么，都会让人陷入持续的紧张、困惑和不满之中。人要想离苦得乐，就必须要了解自己所有的主观感受都只是一瞬间的波动，而且别再追求某种感受，如此一来，虽然感受疼痛，但不再感受痛苦，虽然愉悦，但不再干扰心灵的平静，于是，心灵一片橙明、自在。这样产生的心灵平静力量强大，那些穷极一生疯狂追去愉悦心灵的人完全难以想象。这就像是有人已经在海滩上站了数十年，总是想抓住“好的海浪”，让这些海浪永远留下来，同时又想躲开某些“坏的海浪”，希望这些海浪永远别靠近。就这样一天又一天，这个人站在海滩上徒劳无功，被自己累得几近发疯。最后终于气力用尽，瘫坐在海滩上，让海浪就这样自由来去。忽然发现，这样多么平静啊！ p386对智人未来生命科学发展的思考： 我们这个现代晚期的世界，是有史以来第一次认为所有人类应享有基本上的平等，然而我们可能正准备要打造出一个最不平等的的社会。纵观历史，上层阶级总是说自己比下层阶级更聪明、更强壮，整体而言更为优秀，他们过去通常只是在自欺欺人，贫苦农家的孩子智力上很可能和王子也相去不远。然而，在新一代医药推波助澜下，上层阶级的自命不凡可能即将成为一种客观事实。 p387智人下一个奇点： 物理学家认为宇宙大爆炸就是一个奇点。在奇点之前，所有我们认知的自然法则都还不存在，就连时间也不存在。所以要说宇宙大爆炸之前如何如何，对我们来说是没有意义，无法理解的。而我们现在正面临下一个奇点，所有我们现在这个世界的意义（无论你我、男女、爱恨）都即将变得再也无关紧要。而在那个点之后的任何事，都还超出我们现在所能想象的。 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「青争哥哥」。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言拾遗]]></title>
    <url>%2F2019%2F03%2F09%2FC-%E8%AF%AD%E8%A8%80%E6%8B%BE%E9%81%97%2F</url>
    <content type="text"><![CDATA[前言最近学习数据结构和算法，使用 C 语言实现一些算法和练习题的时候，容易卡壳在 C 语言里面的一些指针、结构体、内存分配等相关语法知识点上，这次复习了一下，下面是一些记录。 指针指针：就是保存地址的变量，变量的值是所指像的内存地址。 12345int i;int *p = &amp;i;int *p, q;int *p,q; 指针应用场景场景一，函数返回多个值，某些值只能通过指针返回如 iOS 里面常见的一些这样的代码： 123456789NSError *error = nil;[[NSFileManager defaultManager] removeItemAtPath:@&quot;xxx/path&quot; error:&amp;error];if (error) &#123; NSLog(@&quot;操作失败！\n&quot;); NSLog(@&quot;error = %@&quot;, error);&#125; else &#123; NSLog(@&quot;操作成功！&quot;);&#125; 这段代码在给定路径下删除资源，通过外界传递的 error 来接收错误值，用来判断操作是否成功。这个方法里面的 error 只能通过参数返回。 再看一段 C 代码： 1234567891011121314151617181920212223242526272829303132// 求整型数组中元素的最大值和最小值void minmax(int a[], int len, int *max, int *min)&#123; int i; *min = *max = a[0]; for (i = 1; i &lt; len; i++) &#123; if (a[i] &lt; *min) &#123; *min = a[i]; &#125; if (a[i] &gt; *max) &#123; *max = a[i]; &#125; &#125;&#125;int main(int argc, const char * argv[]) &#123; int a[] = &#123;1, 3, 4, 10, 66, 78, 34, 99&#125;; int min, max; minmax(a, sizeof(a)/sizeof(a[0]), &amp;max, &amp;min); printf("min = %d, max = %d\n", min, max); return 0;&#125;// 日志输出min = 1, max = 99Program ended with exit code: 0 这种场景下，指针的作用就是作为函数参数把函数需要返回的值带出来。 场景二，函数返回运算状态，常用 -1 和 0 表示，函数结果通过指针返回举例，除法运算有可能不成功，当除数为 0 时，就不成功，这个时候函数既需要告诉外界函数的运算状态，又要将结果返回，这样可以把运算结果通过指针来返回 123456789101112131415161718192021222324252627// 如果除法成功，返回1；否则返回0int divide(int a, int b, int *resutlt)&#123; int ret = 1; if (b == 0) ret = 0; else &#123; *resutlt = a/b; &#125; return ret;&#125;int main(int argc, const char * argv[]) &#123; int a = 5; int b = 2; int c; if (divide(a, b, &amp;c)) &#123; printf("%d/%d=%d\n", a,b,c); &#125; return 0;&#125;// 执行结果5/2=2Program ended with exit code: 0 指针使用常见错误场景定义了指针变量，但还没有指向任何变量，就开始使用指针。 指针数组1. 函数参数中的数组其实就是指针。看段代码： 在sum函数里面修改数组参数a[0]的值，影响到了原数组。其实在函数中，数组参数就是指针，所以下面这几种写法是等价的。 1234int sum(int a[], int length)int sum(int *, int);int sum(int *a, int length)int sum(int [], int length) 2. 数组是特殊的指针 数组变量本身表达地址，赋值给指针不需要用&amp;取地址。 数组的单元表达的是变量，赋值给指针需要用&amp;取地址。 [] 可以对数组做，也可以对指针做。 * 运算符可以对指针做，也可以对数组做。 数组变量是const 的指针，不能被赋值。 指针与const1. 指针是const12345678910111213int a = 1;int *const p = &amp;a;*p = 2;// 指针指向的变量可以改变printf("*p=%d\n", *p); // 指针不能改// *p++;// 打印日志*p=2Program ended with exit code: 0 2. 所指是const12345678910111213141516int a = 1;// 两个等价// const int *p = &amp;a;int const *p = &amp;a;// 指针可以改printf("*p = %d\n", *p);*p++;// 指针指向的变量不能改// *p = 2;printf("*p = %d\n", *p);// 打印日志*p = 1*p = -272632560Program ended with exit code: 0 3. 应用场景当要传递的参数类型比地址大的时候，如结构体类型，使用const类型修饰所指变量，既能用比较小的字节数传递值给参数，又能防止函数内部对外面变量的修改。 4. const 数组 上面说到，数组在函数参数中其实是指针，在函数内部可以修改原数组的值，为了保护数组不被函数破坏，可以设置函数参数为const 指针运算1. 指针加减指针加减运算是将指针指向的内存单元下移或者上移，移动的单位是sizeof(内存单元)。 指针加减常数（p+1、p-1, p += 1; p -= 1） 指针自增自减（p++、p–） 指针之间相减 : 指两个指针之间相差多少个内存单元，即地址之差/sizeof(内存单元) 1234567891011121314151617181920212223242526272829303132333435printf("指针加减运算-----\n");printf("p = %p\n", p);// p 加运算，指向数组下一个内存单元p += 1;printf("p = %p\n", p);// p 减运算，指向数组上一个内存单元p = p - 1;printf("p = %p\n", p); // p 自增自减printf("指针自增自减-----\n");p++;printf("p = %p\n", p);p--;printf("p = %p\n", p); // 指针相减int *q = &amp;a[8];printf("指针相减-----\n");printf("q = %p, p = %p,q - p = %ld\n", q,p, q - p); // 打印日志，地址之间相差16进制正好sizeof(int)，*(p+1) -&gt; 相当于a[1]// 指针相减，地址相差 32，正好是8 * sizeof(int)指针加减运算-----p = 0x7ffeefbff4c0p = 0x7ffeefbff4c4p = 0x7ffeefbff4c0指针自增自减-----p = 0x7ffeefbff4c4p = 0x7ffeefbff4c0指针相减-----q = 0x7ffeefbff4e0, p = 0x7ffeefbff4c0,q - p = 8Program ended with exit code: 0 注意：指针能够进行这些运算的前提是指针指向的是一片连续的内存空间地址，如数组这样。如果指针不是指向一片连续的内存空间，则这种运算是没有意义的。 2. *p++ 取出p所指内存的那个数据，然后再把p移到下一个位置去，即p+1。 ++ 的优先级大于* 常用语数组类的连续空间操作，如数组遍历 在一些CPU上，可以直接被翻译成一条汇编指令，所以运行效率高 12345678910111213141516171819int a[] = &#123;0,1,2,3,4,5,6,7,8,9, -1&#125;;int *p = &amp;a[0];while (*p != -1) &#123; printf("%d\n", *p++);&#125;// 打印日志0123456789Program ended with exit code: 0 3. 指针比较指针的比较其实就是对指针所指内存地址大小的比较 &lt;、&lt;=、==、&gt;、&gt;=、！= 这些运算符都可以来对指针操作 0 地址每个用用程序都有 0 地址，0 地址可以用来表示不能随便访问的地址，所以指针不应该具有 0 值，但可以用来表示特殊的事情 返回的指针无效的 指针没有被真正初始化（先初始化为NULL、0） NULL 表示 0 地址 1234// 表示q没有被真正初始化，不能使用int *q = NULL;// 错误// *q = 15; 指针类型 指针的类型主要是指所指向的内存变量的类型，不同指向类型的指针是不能直接相互赋值的 指针类型转换 void * 表示不知道指向指向什么类型的指针 动态内存分配C 语言中动态内存分配要引入 #include &lt;stdlib.h&gt; 系统库。 12345// 内存分配函数，传入一个需要申请的内存空间大小，单位是字节，返回一个 void * 指针指向这片内存空间void *malloc(size_t __size)// 释放空间，传入是指向要释放内存的指针void free(void *); 常见问题 申请了空间忘记free free过了在free 地址变过了，直接去free 结构体结构体常用来表达复杂一些的数据结构。 声明12345678910111213141516171819202122// 1. 有名结构体struct point &#123; int x; int y;&#125;;// p1，p2都是结构体 point 类型struct point p1, p2;// 2. 无名结构体，没有定义结构体类型，只是声明了两个结构体的变量p3，p4struct &#123; int x; int y;&#125; p3, p4;// 3. 既定义了结构体类型point，有声明了两个变量 p5，p6struct point &#123; int x; int y;&#125; p5, p6; 访问 作为函数参数结构体直接当做函数参数和数组不一样，数组是传递的指针，而结构传递的是值，需要赋值一遍原结构到函数参数中，如果结构很大的话，这样的操作就需要消耗挺大的资源。可以选择使用指针传递。 指向结构的指针123456789101112131415161718192021222324252627struct point *getNewPoint(struct point *point)&#123; point-&gt;x = 2; point-&gt;y = 2; return point;&#125;int main(int argc, const char * argv[]) &#123; // p2 指向结构体的指针变量 struct point *p2 = &amp;p1; // 赋值 (*p2).x = 1; // 用 -&gt; 表示指针所指结构体变量的成员变量 p2-&gt;y = 1; printf("x = %d, y = %d\n", p2-&gt;x, p2-&gt;y); // 将结构体指针传入函数参数 p2 = getNewPoint(p2); printf("x = %d, y = %d\n", p2-&gt;x, p2-&gt;y);&#125;// 打印日志x = 1, y = 1x = 2, y = 2Program ended with exit code: 0 结构数组12345678// 结构数组，数组里面的元素是一个个结构体struct point points[] = &#123; &#123;0,0&#125;,&#123;1,1&#125;, &#123;2,2&#125;&#125;; // 访问int x = points[0].x;int y = points[1].y; typedef12345678910111213141516// 取别名，相当于Point就是结构体体类型。typedef struct &#123; int x; int y;&#125;Point;// 使用Point p1;Point *p2 = &amp;p1; p1.x = 1;p1.y = 1;p2-&gt;x = 2;p2-&gt;y = 2; 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「青争哥哥」。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法学习-链表下]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言上一篇文章讲了链表相关的概念，这篇主要记录的是和链表相关的算法以及一些写好链表算法代码相关的技巧。 实现单链表、循环链表、双向链表，支持增删操作1. 单链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324// 头文件 ----------------------------------------------------------typedef struct _node &#123; int value; // 数据域 struct _node *next; // 指针域&#125; Node;typedef struct _list &#123; Node *head; // 头指针 Node *tail; // 尾指针 int length; // 链表的长度&#125; SingleList;// 创建链表SingleList * creatList(void);// 释放链表void freeList(SingleList *pList);// 给链表末尾添加一个结点void appendNode(SingleList *pList, int value);// 删除末尾结点void removeLastNode(SingleList *pList);// 在指定位置插入一个结点void insertNodeAtIndex(SingleList *pList, int index, int value);// 在指定位置删除一个结点void deleteNodeAtIndex(SingleList *pList, int index);// 打印链表中所有结点值void printList(SingleList *pList);// .m 文件 --------------------------------------------------------------------SingleList * creatList(void)&#123; SingleList *pList = (SingleList *)malloc(sizeof(SingleList)); pList-&gt;head = NULL; pList-&gt;tail = NULL; pList-&gt;length = 0; return pList;&#125;// 释放链表void freeList(SingleList *pList)&#123; if(pList == NULL) &#123; return; &#125; if (pList-&gt;head == NULL) &#123; free(pList); return; &#125; // 用q 来保存下一个p节点 Node *p, *q = NULL; for (p = pList-&gt;head; p; p = q) &#123; q = p-&gt;next; free(p); &#125; free(pList);&#125;// 给链表末尾添加一个结点void appendNode(SingleList *pList, int value)&#123; // 制造一个结点，加入链表中去 Node *p = (Node *)malloc(sizeof(Node)); p-&gt;value = value; p-&gt;next = NULL; // 如果链表为空 if (pList-&gt;head == NULL) &#123; // p 结点就是头结点，也是尾结点 pList-&gt;head = pList-&gt;tail = p; &#125; else &#123; pList-&gt;tail-&gt;next = p; // 更新尾指针 pList-&gt;tail = p; &#125; pList-&gt;length += 1;&#125;// 删除末尾结点void removeLastNode(SingleList *pList)&#123; if (pList-&gt;tail == NULL) &#123; // 链表为空 printf("链表为空!!!!"); return; &#125; if (pList-&gt;head == pList-&gt;tail) &#123; // 链表只有一个结点 pList-&gt;head = pList-&gt;tail = NULL; pList-&gt;length -= 1; return; &#125; // 需要先遍历的到尾结点的上一个结点，然后删除尾结点，再更新尾结点 Node *p = pList-&gt;head; while (p-&gt;next != pList-&gt;tail) &#123; p = p-&gt;next; &#125; // 释放尾结点 free(pList-&gt;tail); p-&gt;next = NULL; pList-&gt;length -= 1; // 更新尾结点 pList-&gt;tail = p;&#125;// 在指定位置插入一个结点，下标从 0 开始void insertNodeAtIndex(SingleList *pList, int index, int value)&#123; if (index &gt;= pList-&gt;length || index &lt; 0) &#123; // 下标越界 printf("下标不合法!!!"); return; &#125; // 制造一个结点，加入链表中去 Node *s = (Node *)malloc(sizeof(Node)); s-&gt;value = value; s-&gt;next = NULL; Node *p = pList-&gt;head; Node *q = NULL; for (int i = 0; i &lt; pList-&gt;length; i ++) &#123; // 找到了要插入的节点位置 if (i == index) &#123; if (i == 0) &#123; // 插入到头结点 s-&gt;next = pList-&gt;head; pList-&gt;head = s; &#125; else &#123; s-&gt;next = p; q-&gt;next = s; &#125; pList-&gt;length += 1; break; &#125; q = p; p = p-&gt;next; &#125;&#125;// 在指定位置删除一个结点void deleteNodeAtIndex(SingleList *pList, int index)&#123; if (index &gt;= pList-&gt;length || index &lt; 0) &#123; // 下标越界 printf("下标不合法!!!"); return; &#125; Node *p = pList-&gt;head; Node *q = NULL; for (int i = 0; i &lt; pList-&gt;length; i ++) &#123; if (index == i) &#123; if (i == 0) &#123; // 首节点，将链表的首节点指向 pList-&gt;head = p-&gt;next; &#125; else &#123; q-&gt;next = p-&gt;next; &#125; free(p); pList-&gt;length -= 1; break; &#125; // 用 q 来记录 p 的上一个结点 q = p; p = p-&gt;next; &#125;&#125;// 打印链表中所有结点值void printList(SingleList *pList)&#123; Node *p = pList-&gt;head; if (p == NULL) &#123; printf("链表为空!!!"); &#125; while (p) &#123; printf("%d\n", p-&gt;value); p = p-&gt;next; &#125;&#125;// 测试代码 ------------------------------------------------------SingleList *pList = creatList();// 加入结点printf("------加入结点\n");appendNode(pList, 10);appendNode(pList, 20);appendNode(pList, 30);appendNode(pList, 40);appendNode(pList, 50);printList(pList);printf("------删除结点\n");removeLastNode(pList);printList(pList);printf("------插入新结点到头结点位置\n");insertNodeAtIndex(pList, 0, 100);printList(pList);printf("------插入新结点到尾结点位置\n");insertNodeAtIndex(pList, 4, 200);printList(pList);printf("------插入新结点到中间结点位置\n");insertNodeAtIndex(pList, 1, 300);printList(pList);printf("------插入新结点到中间结点位置\n");insertNodeAtIndex(pList, 3, 500);printList(pList);printf("------删除头结点\n");deleteNodeAtIndex(pList, 0);printList(pList);printf("------删除尾结点\n");deleteNodeAtIndex(pList, 6);printList(pList);printf("------删除中间结点\n");deleteNodeAtIndex(pList, 3);printList(pList);printf("------删除中间结点\n");deleteNodeAtIndex(pList, 2);printList(pList);// 释放链表freeList(pList);// 打印日志 ---------------------------------------------------------加入结点1020304050------删除结点10203040------插入新结点到头结点位置10010203040------插入新结点到尾结点位置10010203020040------插入新结点到中间结点位置10030010203020040------插入新结点到中间结点位置10030010500203020040------删除头结点30010500203020040------删除尾结点300105002030200------删除中间结点3001050030200------删除中间结点3001030200Program ended with exit code: 0 2. 循环链表循环链表就是尾结点的next指针指向的是头结点,这样链表就构成了环，实现起来和单链表差不多。主要是循环的条件变成了 p-&gt;next != head，这里用到了哨兵结点，关键代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 创建链表，至少有一个结点CycleList * creatList(void)&#123; CycleList *pList = (CycleList *)malloc(sizeof(CycleList)); // 哨兵结点 Node *head = (Node *)malloc(sizeof(Node)); // 自己的 next 指针指向自己 head-&gt;next = head; pList-&gt;head = head; return pList;&#125;// 在指定位置插入一个结点void insertNodeAtIndex(CycleList *pList, int index, int value)&#123; int length = listLength(pList); if (index &lt; 0 || index &gt; length) &#123; printf("下标不合法!!!!"); return; &#125; // 在末尾插入 if (index == length) &#123; appendNode(pList, value); return; &#125; // 在中间插入 Node *p = pList-&gt;head; int i = 0; while (p-&gt;next != pList-&gt;head) &#123; if (i == index) &#123; // 插入结点 Node *s = (Node *)malloc(sizeof(Node)); s-&gt;value = value; s-&gt;next = p-&gt;next; p-&gt;next = s; &#125; p = p-&gt;next; i++; &#125;&#125;// 在指定位置删除一个结点void deleteNodeAtIndex(CycleList *pList, int index)&#123; int length = listLength(pList); if (index &lt; 0 || index &gt;= length) &#123; printf("下标不合法!!!!"); return; &#125; Node *p = pList-&gt;head; int i = 0; while (p-&gt;next != pList-&gt;head) &#123; if (i == index) &#123; if (index == length - 1) &#123; // 在末尾删除 Node *q = p-&gt;next; p-&gt;next = pList-&gt;head; free(q); return; &#125; else &#123; // 在中间删除 Node *q = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; free(q); &#125; &#125; p = p-&gt;next; i++; &#125;&#125; 3. 双向链表双向链表既有前驱指针，又有后继指针，所以可以双向遍历。关键代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 指定位置插入结点void insertNodeAtIndex(ListNode *head, int index, int value)&#123; int length = listLength(head); if (index &lt; 0 || index &gt; length) &#123; printf("下标不合法！！！\n"); return; &#125; // 在末尾插入 if (index == length) &#123; appendNode(head, value); return; &#125; // 在中间插入 ListNode *p = head; int i = 0; while (p &amp;&amp; p-&gt;next) &#123; if (index == i) &#123; // 插入结点 ListNode *s = (ListNode *)malloc(sizeof(ListNode)); s-&gt;value = value; // 新结点的前驱结点为上一个结点 s-&gt;prev = p; // 新结点的下一个结点的前驱结点为新结点 p-&gt;next-&gt;prev = s; // 新结点的后继结点为p的下一个结点 s-&gt;next = p-&gt;next; // p 结点的后继结点为s p-&gt;next = s; &#125; p = p-&gt;next; i++; &#125;&#125;// 指定位置删除结点void deleteNodeAtIndex(ListNode *head, int index)&#123; int length = listLength(head); if (index &lt; 0 || index &gt;= length) &#123; printf("下标不合法！！！\n"); return; &#125; ListNode *p = head; ListNode *q = NULL; int i = 0; while (p &amp;&amp; p-&gt;next) &#123; if (index == i) &#123; // 保存要删除的结点 q = p-&gt;next; if (index == length - 1) &#123; // 删除最后一个结点 // 直接让p的next指针置空 p-&gt;next = NULL; &#125; else &#123; // 删除中间结点 // p 的下一个结点的下一个结点的前驱结点变成p p-&gt;next-&gt;next-&gt;prev = p; // p的下一个结点变成下下个结点 p-&gt;next = p-&gt;next-&gt;next; &#125; // 释放要删除的结点 free(q); &#125; p = p-&gt;next; i++; &#125; &#125; 实现两个有序的链表合并为一个有序链表解题思路： 这个题和合并两个有序的数组为一个有序数组的思路一样，申请第三个链表，长度链表同时遍历，谁的结点比较小就将谁的结点插入到新链表中，最后短链表遍历完，再将长链表中剩余的结点插入到新的链表中去，时间复杂度只有一层循环遍历是 O(n)，空间复杂度额外申请了一个 ListNode 空间，来存储新的链表结点，所以是 O(n)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2)&#123; // 异常判断 if (l1 == NULL) &#123; return l2; &#125; if (l2 == NULL) &#123; return l1; &#125; struct ListNode *firsthead = l1; struct ListNode *secouondhead = l2; // 用第三个链表来保存数据 struct ListNode *l3 = malloc(sizeof(struct ListNode)); // 临时变量，指向新申请的结点l3 struct ListNode *thirdhead = l3; // 同时遍历两个长短链表 while (firsthead &amp;&amp; secouondhead) &#123; // 那个链表的结点值比较小就将该结点插入到新链表中 if (firsthead-&gt;val &lt;= secouondhead-&gt;val) &#123; l3-&gt;next = firsthead; firsthead = firsthead-&gt;next; &#125;else &#123; l3-&gt;next = secouondhead; secouondhead = secouondhead-&gt;next; &#125; l3 = l3-&gt;next; &#125; if (firsthead == NULL) &#123; // 还剩第二个链表，将第二个链表中的所有结点都插入到新链表中 while (secouondhead) &#123; l3-&gt;next = secouondhead; secouondhead = secouondhead-&gt;next; l3 = l3-&gt;next; &#125; &#125; if (secouondhead == NULL) &#123; // 还剩第一个链表，将第一个链表中的所有结点都插入到新链表中 while (firsthead) &#123; l3-&gt;next = firsthead; firsthead = firsthead-&gt;next; l3 = l3-&gt;next; &#125; &#125; // 该结点的next指针指向的才是真正合并后的第一个结点 return thirdhead-&gt;next;&#125; 实现求链表的中间结点快慢指针就可以实现，快指针走两步，慢指针走一步，遍历完整个链表慢指针指向的就是中间节点。默认链表没有环。如果链表长度是偶数，中间节点取的是下中位节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 求中间节点Node *getMiddleNode(SingleList *pList)&#123; if (pList-&gt;head == NULL) &#123; printf("链表为空！！！"); &#125; // 快指针，每次走两步 Node *fast = pList-&gt;head; // 慢指针，每次走一步 Node *slow = pList-&gt;head; while (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125;// 测试代码 ---------------------------------SingleList *pList = creatList();// 加入结点printf("------加入结点\n");appendNode(pList, 10);appendNode(pList, 20);appendNode(pList, 30);appendNode(pList, 40);appendNode(pList, 50);printList(pList); // 中间节点Node *mid = getMiddleNode(pList);printf("mid.value = %d\n", mid-&gt;value);// 打印日志 ---------------------------------------加入结点1020304050mid.value = 30 leetcode 上相关练习1. 反转一个单链表题目地址 1234567891011121314151617181920struct ListNode* reverseList(struct ListNode* head)&#123; if(head == NULL || head-&gt;next == NULL) return head; struct ListNode* provious = NULL; struct ListNode* current = head; while(current) &#123; // 保存当前结点的下一个结点指针 struct ListNode* temp = current-&gt;next; // 将当前节点的next指针指向上一个结点 current-&gt;next = provious; // 将当前节点赋值给上一个结点 provious = current; // 指向下一个结点 current = temp; &#125; // 最后一个provious就是链表的头指针 return provious;&#125; 2. 两两交换链表中的节点题目地址 解题思路：每次走两步遍历链表，每次两两交换都需要修改三个结点指针的指向，需要三个变量来保存。其中 previous 用来保存上一次的 current 指针。 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* swapPairs(struct ListNode* head) &#123; struct ListNode *current = head; struct ListNode *previous = NULL; while (current &amp;&amp; current-&gt;next) &#123; // 当前指针的下一个结点 struct ListNode *a = current-&gt;next; // 当前指针的下下一个结点 struct ListNode *b = a-&gt;next; // 交换 a-&gt;next = current; current-&gt;next = b; if (previous) &#123; // 将上次的指针指向交换后的结点 previous-&gt;next = a; &#125; else &#123; // 重新赋值给头指针 head = a; &#125; // 保存上一次的指针 previous = current; // 每次走两步 current = b; &#125; return head;&#125; 3. 判断链表是否有环题目地址 解法一：使用一个散列表老保存遍历过的结点，每次遍历链表都去散列表中查找，判断当前结点是否已经存在散列表中，如果在散列表中找到，那么就有环，如果直到链表遍历结束也没找到，就没有环。这种的时间复杂度是 O(n)，空间复杂度是 O(n)。 解法二：使用快慢指针，遍历链表，快指针每次走两步，慢指针每次走一步，判断快慢指针是否相遇，如果相遇则链表有环，如果遍历完链表也没有相遇，说明没有环。这种解法的时间复杂度是 O(n)，空间复杂度是 O(1)。 123456789101112131415161718192021222324252627// 解法二/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */bool hasCycle(struct ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return false; // 快慢指针 struct ListNode *fast = head; struct ListNode *slow = head; while(slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; // 如果快慢指针相遇，就表示有环 if(slow == fast) &#123; return true; &#125; &#125; return false; &#125; 4. 环形链表题目地址 解题思路： 给定一个链表，返回链表开始入环的第一个节点。这里运用到了一个几何上的数学公式，快指针和慢指针走一移动直到第一次相遇在 X 结点，假设慢指针走了 N 步，快指针就走了 2N 步，假设入环的第一个节点为 Z，则会有起点到 Z 的距离会等于 X 结点到 Z 的距离，所以在快慢指针判断链表有环后只需要让快指针从头开始一步一步走，以此同时慢指针继续向前走，两者就会在第一个入环节点为 Z 相遇。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode *detectCycle(struct ListNode *head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return NULL; &#125; struct ListNode *fast = head; struct ListNode *slow = head; // 快慢指针检测是否有环 while(slow &amp;&amp; fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) &#123; break; &#125; &#125; // 有环 if(fast == slow) &#123; // 寻找环的入环结点 fast = head; while (fast != slow) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return fast; &#125; else &#123; return NULL; &#125;&#125; 5. 每 k 个节点一组翻转链表题目地址 解题思路： 每 k 个结点一组翻转，可以使用递归实现，每一组翻转完成后，传入下一个结点的指针，递归调用，递归的基线条件是剩余的结点个数小于k，然后需要将每一组翻转翻转的组尾的 next 指针指向下一组的组头。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * @lc app=leetcode.cn id=25 lang=c * * [25] k个一组翻转链表 * * https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/ * * algorithms * Hard (48.65%) * Total Accepted: 10.3K * Total Submissions: 20.3K * Testcase Example: '[1,2,3,4,5]\n2' * * 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 * * k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 * * 示例 : * * 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 * * 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 * * 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 * * 说明 : * * * 你的算法只能使用常数的额外空间。 * 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 * * *//** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* reverseKGroup(struct ListNode* head, int k)&#123; // 异常判断 if (head == NULL || head-&gt;next == NULL || k &lt; 2) &#123; return head; &#125; // 判断链表中的结点是否大于等于k个，还够不够翻转 struct ListNode *temp = head; for (int i = 0; i &lt; k; i++, temp = temp-&gt;next) &#123; if (temp == NULL) &#123; // 不够翻转，基线条件 return head; &#125; &#125; // k个结点一组进行结点的翻转 struct ListNode *current = head; struct ListNode *previous = NULL; for (int i = 0; i &lt; k; i ++) &#123; struct ListNode *temp = current-&gt;next; current-&gt;next = previous; previous = current; current = temp; &#125; // 递归条件，正好每组的头结点翻转完成后到组尾，将next指针指向下一组的组头结点 head-&gt;next = reverseKGroup(current, k); // 返回头结点指针 return previous;&#125; 总结一些技巧1. 理解指针的概念指针保存的是变量的内存地址，通过指针就能找到这个变量，如链表中经常写的 p-&gt;next = q，意思是说 p 结点的next 指针保存了 q 结点的内存地址。 2. 警惕指针丢失和内存泄漏对于链表的插入操作，需要注意代码的先后顺序，写反了就会发生内存泄漏，删除操作需要手动 free 结点的内存。 1234567// 在 a 结点和 b 结点中间插入 x 结点，p 指针指向 a 结点， 正确写法✔️x-&gt;next = p-&gt;next-&gt;next;p-&gt;next = x;// 错误写法，这个时候 p-&gt;next 已经不指向 b 了，而是指向 x。❌p-&gt;next = x;x-&gt;next = p-&gt;next; 3. 善用哨兵结点简化问题有时候处理头指针和尾指针是需要特别的处理，代码也不统一，引入哨兵结点后，可以简化问题，哨兵结点不存储数据，只是 next 指针指向链表的实际结点，这样，头结点的逻辑就可以和其他结点一样了，不用特别处理。这样就简化了代码逻辑。如链表的插入逻辑和删除逻辑，不用哨兵结点的话，就需要区别对待头结点和尾结点。引入哨兵结点的链表叫做带头链表，相反没有哨兵结点的链表叫做不带头链表。如图所示： 4. 重点留意边界条件处理写链表代码很容易出错，需要考虑的边界条件有很多，有些额外需要做特别处理，需要特别考虑如： 链表为空时，代码是否正常？ 链表只有一个结点时，代码是否正常？ 链表只包含两个结点时，代码是否正常？ 处理头结点和尾结点，代码是否正常？ 5. 画图辅助分析如果空间想象能力不够好，特别是多层循环或者递归时，画图辅助分析可以帮助定位每一步的变量值，指针是怎么指向的，也可以在没有思路的时候通过画图辅助分析一步一步的总结归纳出规律来，这个时候算法思路就变清晰一些。我写快慢指针检测环，定位链表中点和两两翻转链表代码时就是在笔记上一步一步推到出代码规律来的。 6. 多写多练，掌握套路很多链表相关的写法其实写多了会发现很多类似的思路，如快慢指针思路，既可以用来定位链表中间结点，又可以用来检测环，复杂点的问题也一般可以分割成小问题来处理。 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「青争哥哥」。]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法学习-链表上]]></title>
    <url>%2F2019%2F03%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[前言这一篇笔记主要记录总结了线性表数据结构中的链表概念，以及和数组的对比，数组和链表都是计算机中最基本的数据结构，是构建其他高级复杂数据的结构的基础。开发中应该根据具体的场景选择最合适的数据结构和算法。下一篇将会实现链表相关的算法。 链表概念上一篇数组讲了数组是一种是一种线性表数据结构，是用一组连续的内存空间，来存储一组具有相同数据类型的数据。和数组相同的是，链表也是一种线性表数据结构，不同的是链表是通过指针将一组零散的内存块串联起来存储数据，可以存储不同数据类型的数据。 链表的种类五花八门，主要有以下几类： 单链表每个内存块被称为链表的结点，每个结点包含了数据域和指针域，数据域存储数据，指针域的指针指向下一个结点的内存地址，称为后继指针next。 另外，通常把第一个结点称作头结点，头结点用来记录链表的基地址，有了头结点就可以遍历整个链表。最后一个结点称作尾节点，尾结点的指针指向NUll。 循环链表循环链表是一种特殊的单链表。和单链表唯一的区别是循环链表的尾指针不是指向NUll，而是指向头结点。像环一样首尾相连，所以叫做循环链表。 循环链表的优点是在处理的数据具有环形结构特点时，特别适合使用，如经典的约瑟夫问题。 双向链表双向链表除了像单链表一样结点指针域有后继指针外，还有前驱指针prev，指向上一个结点。 缺点是需要额外开辟两个空间来存储后继结点和前驱结点的地址，如果存储同样的数据，双向链表要比单链表占用更多的空间。 优点是支持双向遍历，可以在 O(1)的复杂度下找到前驱结点，所以在某些情况下的插入、删除等操作比单链表简单高效。 如删除指定指针指向的结点q，单链表需要先遍历找到到这个结点的前驱结点，直到 p-&gt;nex = q， 时间复杂度是O(n)，而双向链表的结点指针域中已经存储了前驱结点的指针，不需要遍历，时间复杂度是O(1)。同理，要在指定结点前面插入一个结点，使用双向链表也是只要 O(1) 复杂度就能完成。 另外，对于有序链表，查找一个数据时，可以记录上次查找的数据的位置p，后面的查找的数据可以和 p 位置的数据比大小，决定是向前还是向后查找，这样平均查找只需要找一半的数据。 双向链表里面有个重要的设计思想就是空间换时间思想，当需要很在意运行时间时，可以选择空间复杂度较高而时间复杂度相对较低的算法或者数据结构，相反，如果内存空间比较重要，如在单片机上的程序，就要反过来使用时间换空间思想。缓存的思想就是利用了空间换时间，让经常使用到的数据存储到到高速的内存中，大大提高了数据读取的速度。 双向循环链表双向循环链表是双向链表和循环链表的结合体，相比较双向链表，尾结点的后继指针指向了头结点，头结点的前驱指针指向尾结点。 链表和数组对比可以看到，再算法时间复杂度上，数组和链表在随机访问和插入删除的复杂度上正好相反。 数组是用一组连续的内存空间来存储数据，优点是可以借助 CPU 缓存机制，预先读取数组中的数据，访问效率更高，而链表在内存中不连续，所以对 CPU 缓存不友好。 数组的缺点是大小固定，要占用整块连续的内存空间，如果声明的数组过大，系统可能没有足够连续的空间给分配，就会导致内存不足，如果申请的数组大小过小，出现不够用，就需要重新申请一块更大的连续内存空间，然后将之前的数据全部拷贝一份过来，这个过程很耗时，而链表天然就支持动态扩容。 所以，如果代码对内存使用很苛刻，就使用用数组，因为链表存储相同的数据，需要更多的内存空间。在实际的开发中，需要根据不同情况选用最合适的数据结构和算法。 LRU 缓存淘汰算法最近最少使用策略 LRU 是一种常见的缓存策略。常用缓存策略的有下列几种： 先进先出策略 FIFO(First In，Fitst Out)。 最少使用策略 LFU(Least Frequently Used)。 最近最少使用策略 LRU(Least Recently Used)。 链表实现维护一个有序的单链表，越靠近链表头部的越是最近访问的，也靠近尾结点的是越早之前访问的。 当该数据存在缓存的链表中，缓存命中，遍历得到数据对应到的结点，从原位置删除，然后将该结点插入到头结点位置。 没有命中缓存，需要将该数据加入到缓存中，如果缓存未满，直接将该数据结点插入到链表的头部，如果缓存已满，删除链表尾结点，再将该数据结点插入到链表的头结点位置。 数组实现维护一个有序的数组，下标越小越是最近访问的，下标越大越是越早之前访问的。 当该数据存在数组中，缓存命中，从原位置删除该元素，然后将该元素插入到数组的首位置。 缓存没有命中，需要将数据存入到缓存中。这个时候如果缓存还没满，就直接将该数据插入到数组的首位置。如果缓存已经满了，先删除数组最后一个元素，然后再将该数据插入到数组的首位置。 课后问题 如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的思题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？ 解答： 使用快慢指针定位到中间结点，同时翻转链表前半部分使其逆序； 如果链表长度是偶数，那么快指针为空，此时慢指针指向的是下中位结点，如果是链表长度是奇数，快指针不为空，此时慢指针指向的正好是链表的中间结点，再将慢指针向前走一步。 遍历链表比较链表两端的结点，如果有一个结点不相等，则不是回文串，遍历结束，如果都相等则是回文串。 时间复杂度遍历一遍链表是O(n)，空间复杂度没有利用额外的空间是O(1)。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* * @lc app=leetcode.cn id=234 lang=c * * [234] 回文链表 * * https://leetcode-cn.com/problems/palindrome-linked-list/description/ * * algorithms * Easy (34.93%) * Total Accepted: 22.3K * Total Submissions: 61.2K * Testcase Example: '[1,2]' * * 请判断一个链表是否为回文链表。 * * 示例 1: * * 输入: 1-&gt;2 * 输出: false * * 示例 2: * * 输入: 1-&gt;2-&gt;2-&gt;1 * 输出: true * * * 进阶： * 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ * *//** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */bool isPalindrome(struct ListNode* head)&#123; if(head == NULL || head-&gt;next == NULL) &#123; return true; &#125; // 快慢指针获取中间结点指针 // 快指针，每次走两步 struct ListNode *fast = head; // 慢指针，每次走一步 struct ListNode *slow = head; struct ListNode *previous = NULL; while (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; // 将前半部分链表翻转 struct ListNode *temp = slow-&gt;next; slow-&gt;next = previous; previous = slow; slow = temp; &#125; // 链表长度是偶数时，fast 为空 if (fast) &#123; // 链表数是奇数，此时 slow 指向中间结点，provious 指向头结点，slow指针需要向前走一步， slow = slow-&gt;next; &#125; while (slow) &#123; if (slow-&gt;val != previous-&gt;val) &#123; return false; &#125; slow = slow-&gt;next; previous = previous-&gt;next; &#125; return true;&#125; 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「青争哥哥」。]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法学习-数组]]></title>
    <url>%2F2019%2F02%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[前言这一篇笔记主要记录总结了线性表数据结构中的数组概念以及相关的算法。 名词解释1. 线性表（Linear List）线性表是数据排成像一条线一样的结构，每个线性表上的数据最多有向前和向后两个方向。除了数组外，链表、队列、栈也是线性表数据结构。 2. 非线性表和线性表相对立，数据之间不是简单的前后关系，这样的结构称为非线性表，如图、树、堆等数据结构。 数组数组是一种线性表数据结构，是用一组连续的内存空间，来存储一组具有相同数据类型的数据。几乎在所有的编程语言都存在数组这中最基本的数据结构类型。在 Objective-C 语言中是 NSArray，当然 Objective-C 是 C 的超集，所以也完全可以使用 C 语言的数组类型。 随机访问正式因为数组是用一组连续的内存空间来存储数据的，所以数组支持下标随机访问，复杂度是 O(1)。 12345678int[] a = new int[10]// 数组a 首地址base_address = 1000// 寻址公式 data_type_size：数组中元素的数据类型长度a[i]_address = base_address + i * data_type_size 插入和删除相比于复杂度是 O(1)的随机访问操作，对于数组而言，插入和删除操作的复杂度都为O(n)，因为每次要在数组的第 k 个位置插入或者删除一个元素的话，都需要移动 k ~ n 个元素的位置。 优化技巧： 插入操作：如果不需要追求数组中元素的有序，则可以考虑直接将第 k 个位置的元素移到数组的末尾，然后把要插入的新元素放到第 k 个位置就行，这样，复杂度也就是O(1)。删除操作：在一些场景下，并不追求数组中数据的连续性，可以将多次删除操作集中在一起执行。先记录下已经删除的元素，并不真的删除，当数组没有更多空间时，再触发真正的删除操作，这样可以省下大量重复的数据移动操作。 警惕数组越界问题看一段 C 语言代码： 123456789int main(int argc, char* argv[])&#123; int i = 0; int arr[3] = &#123;0&#125;; for(; i&lt;=3; i++)&#123; arr[i] = 0; printf("hello world\n"); &#125; return 0;&#125; 这里就会出现数组越界问题，C语言的执行结果是未决，就是没有规定数组访问越界时编译器应该如何处理。如果该内存是一块可以访问的不受限内存，在x86架构机器下，那么执行结果是会无线循环打印hello world。原因是内存分配从栈的高位到低位开始，i 变量实际上与数组元素 arr[2] 相邻。数组下标从 0 开始，当执行到循环最后一次 i = 3 时，根据根据之前的寻址公式 a[i]_address = base_address + i * data_type_size，实际上 arr[3] 访问的会是变量 i 的地址，赋值给 i = 0，然后死循环。 这里还和使用的编译器内存分配以及字节对齐有关系，有些编译器会默认开启堆栈保护，当如果变量访问一块不属于自己的内存时，会出现编译错误。为了不让程序出现这种不确定的错误，导致 debug 难度大，还有就是容易被黑客利用攻击，所以写代码时要特别警惕数组越界。不过很多高级语言的都会默认做越界检查，如 Objective-C 里面的数组，如果越界访问就会下面这种经典错误。 怎么选择容器还是数组？容器优点 将很多数组插入删除等操作细节封装起来，提供很多易用的API。 动态扩容，如果插入数据的时候发现数组的空间不够，就需要重新申请一块更大的内存空间，并把原来的数据都复制进新的数组，在将新的数据插入。但是如果事先知道数据的大小，可以创建的时候就制定好数据的大小，这样可以避免不必要的动态扩容操作。 数组优点 存储基本数据类型。 当数组大小事先已知，并且数据操作比较简单。 总结日常业务开发，使用高级语言提供的数组容器就行，如 Objective-C 的 NSArray，损失一点性能，但写起来方便简单。如果是做比较注重性能的底层开发，可以考虑使用数组。 数组的下标为什么从 0 开始？ 寻址算法，如果下标不从 0 开始，从 1 开始会怎样，寻址算法就变成 a[i]_address = base_address + （i - 1 * data_type_size），转成汇编指令，对于 CPU 而言，就多了一条要执行的减法指令，而这种数组的操作是很频繁很底层的操作，为了优化，所以数组的下标都设计从 0 开始。 历史原因，由于 C 语言是后面很多语言设计的参考，为了保持程序员的编码习惯，所以后面的程序语言设计者也保持和 C 语言数组一样的风格。 课后思考题 前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念，我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉回顾下你理解的标记清除垃圾回收算法。 解答： 不熟悉 Java 语言。 前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一二维数组的寻址公式是怎样？ 解答： m n 数组，`a[i][j]_address = base_address + （i n + j data_type_size）`，其中 i &lt; m，j &lt; n。内存布局如下： 数组相关编程题目代码实现部分涉及到了一些 C 语言的知识点，我也复习了一下，有需要的可以看看我写得这篇：C 语言拾遗 1. 实现一个支持动态扩容的数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174// 头文件 ————————————————————————————————————————————————————————#ifndef DynamicExpansionArray_h#define DynamicExpansionArray_h#include &lt;stdio.h&gt;typedef struct &#123; int *array;// 指针数组 int size; // 数组大小&#125;Array;// 创建数组Array array_creat(int init_size);// 释放数组void array_free(Array *a);// 获取数组大小int array_size(const Array *a);// 根据下标获取数组int* array_at(Array *a, int index);// 根据下标获取值int array_get(const Array *a, int index);// 根据下标设置值void array_set(Array *a, int index, int value);// 数组扩容void array_inflate(Array *a, int more_size);#endif /* DynamicExpansionArray_h */// 实现文件 ————————————————————————————————————————————————————#include "DynamicExpansionArray.h"#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//typedef struct &#123;// int *array;// int size;//&#125;Array;const int BLOCK_SIZE = 20;// 创建数组Array array_creat(int init_size)&#123; Array a; a.size = init_size; a.array = (int *)malloc(sizeof(int) * a.size); return a;&#125;// 释放数组void array_free(Array *a)&#123; free(a-&gt;array); a-&gt;size = 0; // 防止外界重复free导致崩溃，free(NULL) 是没问题的。 a-&gt;array = NULL;&#125;// 获取数组大小int array_size(const Array *a)&#123; return a-&gt;size;&#125;// 返回对应index的内存地址int* array_at(Array *a, int index)&#123; if (index &lt; 0) &#123; printf("下标不合法！！！！"); &#125; // 如果下标大于等于当前最大的size，则数组需要扩容 if (index &gt;= a-&gt;size) &#123; array_inflate(a, (index / BLOCK_SIZE + 1) * BLOCK_SIZE - a-&gt;size); &#125; // array[index] ：如果分配的是连续的内存空间，指针array可以像数组一样使用 return &amp;(a-&gt;array[index]);&#125;// 根据下标获取值int array_get(const Array *a, int index)&#123; return a-&gt;array[index];&#125;// 根据下标设置值void array_set(Array *a, int index, int value)&#123; a-&gt;array[index] = value;&#125;// 数组扩容void array_inflate(Array *a, int more_size)&#123; int *p = (int *)malloc((a-&gt;size + more_size) * sizeof(int)); // memcoy，将a-&gt;array内存拷贝到p memcpy(p, a-&gt;array, sizeof(int) * a-&gt;size);// for (int i = 0; i &lt; a-&gt;size; i++)// &#123;// p[i] = a-&gt;array[i];// &#125; // free(a-&gt;array); a-&gt;array = p; a-&gt;size += more_size;&#125;// 测试 ——————————————————————————————————————————————————————————#include &lt;stdio.h&gt;#include "DynamicExpansionArray.h"int main(int argc, const char * argv[]) &#123; // 创建一个大小 100 数组结构 Array a = array_creat(10); int b[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; a.array = b; printf("size = %d\n", array_size(&amp;a)); // 根据索引下标设置值 *array_at(&amp;a, 0) = 10; *array_at(&amp;a, 1) = 12; // 根据索引下标取值 int index_0_Value = *array_at(&amp;a, 0); int index_1_Value = *array_at(&amp;a, 1); printf("index_0_Value = %d\nindex_1_Value = %d\n",index_0_Value, index_1_Value); // 设置值 array_set(&amp;a, 2, 20); array_set(&amp;a, 3, 21); // 测试超出数组下标出插入，动态扩容数组，原来数组空间为 10，现在是120 *array_at(&amp;a, 101) = 101; int index_101_Value = *array_at(&amp;a, 101); printf("index_101_Value = %d\n", index_101_Value); // 打印原来的值 for (int i = 0; i &lt; 10; i ++) &#123; printf("---index_%d_Value %d\n", i, array_get(&amp;a, i)); &#125; // 释放内存空间 array_free(&amp;a); return 0;&#125;// 打印日志 ——————————————————————————————————————————————————————————size = 10index_0_Value = 10index_1_Value = 12index_101_Value = 101---index_0_Value 10---index_1_Value 12---index_2_Value 20---index_3_Value 21---index_4_Value 4---index_5_Value 5---index_6_Value 6---index_7_Value 7---index_8_Value 8---index_9_Value 9Program ended with exit code: 0 2. 实现一个大小固定的有序数组，支持动态增删改操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209// 头文件 -----------------------------------------------------#ifndef SortArray_h#define SortArray_h#include &lt;stdio.h&gt;typedef struct &#123; int size;// 数组大小 int used; // 数组已经使用了多少 int *array; // 指针&#125;Array;// 根据数组大小初始化一个数组Array arrayCreat(int init_size);// 释放空间void arrayFree(Array *a);// 增，在数组末尾插入新数据void arrayAdd(Array *a, int value);// 删void arrayDelete(Array *a, int index);// 改，修改指定下标位置的值void arrayUpdate(Array *a, int index, int value);#endif /* SortArray_h */// 实现文件 --------------------------------------------------------#include "SortArray.h"#include &lt;stdlib.h&gt;//typedef struct &#123;// int size;// 数组大小// int *array; // 指针//&#125;Array;// 创建固定大小数组Array arrayCreat(int init_size)&#123; Array a; a.array = (int *)malloc(init_size*sizeof(int)); a.size = init_size; a.used = 0; return a;&#125;// 释放空间void arrayFree(Array *a)&#123; free(a-&gt;array); a-&gt;size = 0; a-&gt;used = 0; // 防止外界重复free导致崩溃，free(NULL) 是没问题的。 a-&gt;array = NULL;&#125;// 增，在数组末尾插入新数据void arrayAdd(Array *a, int value)&#123; // 先判断数组空间是否满了 if (a-&gt;used == a-&gt;size) &#123; printf("添加失败，数组空间已满！！！"); &#125; else &#123; // 如果数组为空 if (a-&gt;used == 0) &#123; a-&gt;array[a-&gt;used] = value; &#125; else if (value &gt;= a-&gt;array[a-&gt;used - 1]) &#123; // 比数组中最大的还大 a-&gt;array[a-&gt;used] = value; &#125; else &#123; // 循环遍历数组中的元素，比较新加入的值是否比原来每一个元素大，大的话就往前再比 for (int i = a-&gt;used - 1; i &gt;= 0; i--) &#123; // 将 i ~ used -1 下标都要往后移动一位 a-&gt;array[i+1] = a-&gt;array[i]; if (value &gt;= a-&gt;array[i]) &#123; a-&gt;array[i + 1] = value; break; &#125; else &#123; if (i == 0) &#123; a-&gt;array[i] = value; &#125; &#125; &#125; &#125; // 加入元素成功，更新used a-&gt;used += 1; &#125;&#125;// 删，根据下标删除一个元素void arrayDelete(Array *a, int index)&#123; // 判断下标是否合法 if (index &gt;= a-&gt;size || index &lt; 0) &#123; printf("下标不合法!!!"); &#125; else &#123; // 从 index + 1 ~ used 位置的元素都需要向前移动 for (int i = index + 1; i &lt; a-&gt;used; i ++) &#123; a-&gt;array[i - 1] = a-&gt;array[i]; &#125; // 更新used a-&gt;used -= 1; &#125;&#125;// 改，修改指定下标位置的值void arrayUpdate(Array *a, int index, int value)&#123; // 判断下标是否合法 if (index &gt;= a-&gt;used || index &lt; 0) &#123; printf("下标 = %d 不合法!!!", index); &#125; else &#123; if (value != a-&gt;array[index]) &#123; // 先删掉index位置的元素 arrayDelete(a, index); // 重新把value加入进来 arrayAdd(a, value); &#125; &#125;&#125;// 测试 ------------------------------------------------------------------// 1. 创建一个 10 大小的固定数组Array a = arrayCreat(10); // 2.添加元素printf("-----插入\n");arrayAdd(&amp;a, -4);arrayAdd(&amp;a, 8);arrayAdd(&amp;a, 2);arrayAdd(&amp;a, 19);arrayAdd(&amp;a, 4);arrayAdd(&amp;a, 78);arrayAdd(&amp;a, 100);arrayAdd(&amp;a, 11);arrayAdd(&amp;a, 12);arrayAdd(&amp;a, 5);// 插入失败arrayAdd(&amp;a, 10); printf("\n"); // 打印数组元素for (int i = 0; i &lt; a.used; i++) &#123; printf("a[%d] = %d\n", i, a.array[i]);&#125; // 3. 删除printf("-----删除\n");arrayDelete(&amp;a, 0);arrayDelete(&amp;a, 1);arrayDelete(&amp;a, 2);arrayDelete(&amp;a, 3);arrayDelete(&amp;a, 4);printf("\n"); for (int i = 0; i &lt; a.used; i++) &#123; printf("a[%d] = %d\n", i, a.array[i]);&#125; // 4. 修改printf("-----修改\n");arrayUpdate(&amp;a, 0, 10);arrayUpdate(&amp;a, 5, 50);printf("\n"); for (int i = 0; i &lt; a.used; i++) &#123; printf("a[%d] = %d\n", i, a.array[i]);&#125; // 释放空间arrayFree(&amp;a);// 打印日志 -------------------------------------------------------------------插入添加失败，数组空间已满！！！a[0] = -4a[1] = 2a[2] = 4a[3] = 5a[4] = 8a[5] = 11a[6] = 12a[7] = 19a[8] = 78a[9] = 100-----删除a[0] = 2a[1] = 5a[2] = 11a[3] = 19a[4] = 100-----修改下标 = 5 不合法!!!a[0] = 5a[1] = 10a[2] = 11a[3] = 19a[4] = 100Program ended with exit code: 0 3. 实现两个有序数组合并为一个有序数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// 合并两个有序数组Array mergeSortArray(const Array *a, const Array *b)&#123; Array p; // 申请内存空间 p.array = (int *)malloc(sizeof(int) * (a-&gt;used + b-&gt;used)); p.size = a-&gt;used + b-&gt;used; p.used = a-&gt;used + b-&gt;used; // 长短数组同时遍历，如果短数组遍历完了，剩下的就是长数组里面的数据，直接加上去就行，前面的数据都已经排好序了 int i = 0, j = 0, k = 0; while (i &lt; a-&gt;used &amp;&amp; j &lt; b-&gt;used) &#123; if (a-&gt;array[i] &lt;= b-&gt;array[j]) &#123; p.array[k++] = a-&gt;array[i++]; &#125; else &#123; p.array[k++] = b-&gt;array[j++]; &#125; &#125; while (i &lt; a-&gt;used) &#123; p.array[k++] = a-&gt;array[i++]; &#125; while (j &lt; b-&gt;used) &#123; p.array[k++] = b-&gt;array[j++]; &#125; return p;&#125;//测试 --------------------------------------------------------Array a = arrayCreat(10);Array b = arrayCreat(10); printf("-----a数组插入数据\n");arrayAdd(&amp;a, 20);arrayAdd(&amp;a, 93);arrayAdd(&amp;a, 3);arrayAdd(&amp;a, 43);arrayAdd(&amp;a, 65); for (int i = 0; i &lt; a.used; i++) &#123; printf("a[%d] = %d\n", i, a.array[i]);&#125; printf("-----b数组插入数据\n");arrayAdd(&amp;b, 100);arrayAdd(&amp;b, 125);arrayAdd(&amp;b, 34);arrayAdd(&amp;b, 2);arrayAdd(&amp;b, 11);arrayAdd(&amp;b, 19);arrayAdd(&amp;b, 78);arrayAdd(&amp;b, 89); for (int i = 0; i &lt; b.used; i++) &#123; printf("b[%d] = %d\n", i, b.array[i]);&#125; printf("数组合并\n");Array c = mergeSortArray(&amp;a, &amp;b);for (int i = 0; i &lt; c.used; i++) &#123; printf("c[%d] = %d\n", i, c.array[i]);&#125; arrayFree(&amp;a);arrayFree(&amp;b);// 打印日志 ---------------------------------------------------------a数组插入数据a[0] = 3a[1] = 20a[2] = 43a[3] = 65a[4] = 93-----b数组插入数据b[0] = 2b[1] = 11b[2] = 19b[3] = 34b[4] = 78b[5] = 89b[6] = 100b[7] = 125数组合并c[0] = 2c[1] = 3c[2] = 11c[3] = 19c[4] = 20c[5] = 34c[6] = 43c[7] = 65c[8] = 78c[9] = 89c[10] = 93c[11] = 100c[12] = 125Program ended with exit code: 0 代码详细地址：点击这里 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「青争哥哥」。]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法学习-复杂度分析]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言这一篇笔记主要记录总结了什么是算法复杂度？、为什要做算法复杂度分析？、如何做算法复杂度分析？、常用的复杂度级别？以及如何掌握复杂度分析？等问题。 算法复杂度分析是什么？数据结构与算法解决的是如何更省、更快的存储和处理数据的问题。因此就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。 复杂度也叫渐进复杂度，其中包含时间复杂度和空间复杂度两个维度，是用来分析算法执行时间（或者占用空间）与数据规模的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。 为什么要做算法复杂度分析？ 统计、监控等事后统计法的局限性： 测试结果高度依赖测试环境 测试结果受数据规模影响很大 因此需要一个不用具体的测试数据就可以粗略地估计算法的执行效率的方法。复杂度分析不依赖执行环境、成本低、可操作性强。 掌握复杂度分析，将能写出性能更优的代码。 如何做算法复杂度分析？大 O 复杂度表示法 所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。 大 O 时间复杂度实际上并不具体代表代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，叫做渐进时间复杂度，简称时间复杂度。 由于公式中的低阶、常量、系数对增长趋势不影响，所以都可以忽略，只需要记录一个最大的量级。 算法复杂度分析法则 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 空间复杂度分析类比时间复杂度，空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。 常见的空间复杂度是：O(1)、O(n)、O(n^2) 最好、最坏时间复杂度对有些代码，其复杂度有不是固定的，有最好、最坏的情况。如数组元素查找，有可能第一次就找到，这个时候算法时间复杂度是常数阶O(1)，也有可能需要整个遍历一遍数组才能找到，这个时候是最坏的时间复杂度O(n)。 最好时间复杂度：在最理想情况下，代码执行的时间复杂度。 最坏时间复杂度：在最糟糕的情况下，代码执行的时间复杂度。 平均情况复杂度由于最好和最坏情况复杂度对应的都是极端情况下的代码复杂度，发生的概率并不大，所以需要引入平均情况复杂度来更好的表示算法的时间复杂度。 平均情况复杂度 是将各种情况下时间复杂度发生的概率考虑进去，然后计算整体时间复杂度的期望值，所以平均情况复杂度也叫做加权平均时间复杂度或者期望时间复杂度。 很多时候，只要使用一个复杂度就可以满足需求了。只有同一块代码在不同情况下，时间复杂度有量级的差距，才会使用这三种复杂度表示法来区分。 均摊时间复杂度适用场景：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个情况下，就可以将这一组操作放在一起分析，看能否将较高时间复杂度的那次操作平摊到其他那些时间复杂度较低的操作上。一般在能够应用均摊时间复杂度的场景，均摊时间复杂度就等于最好情况时间复杂度。 分析方法：摊还分析。 常用的算法复杂度级别 非多项式量级 O(2^n) 和 O(n!) 当数据规模 n 越大时，非多项式量级的算法的执行时间会急剧增加。所以非多项式量级算法是非常低效的算法，因此要避免使用到。 多项式量级 O(1)：代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度记做 O(1)，一般情况下，如果算法中不存在循环语句、递归语句、不管有多少行代码，其时间复杂度都是 O(1)。 O(logn)、O(nlogn)：对数阶复杂度。 O(m+n)、O(m*n)：代码的复杂度由两个数据的规模来决定。 多项式量级算法时间复杂度随数据规模的增长变化趋势曲线 如何掌握复杂度分析多练习。 课后问题1. 项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析是不是多次一举？解答：不是多此一举，渐进时间，空间复杂度分析为我们提供了一个很好的理论分析的方向，成本低，可操作性强，不用具体的测试数据就可以粗略地估计算法的执行效率，有助于写出性能高效的代码，同时培养起算法复杂度分析的思维，可以和性能测试相辅相成。 2. 分析以下代码的复杂度12345678910111213141516171819202122// 全局变量，大小为 10 的数组 array，长度 len，下标 i。int array[] = new int[10]; int len = 10;int i = 0;// 往数组中添加一个元素void add(int element) &#123; if (i &gt;= len) &#123; // 数组空间不够了 // 重新申请一个 2 倍大小的数组空间 int new_array[] = new int[len*2]; // 把原来 array 数组中的数据依次 copy 到 new_array for (int j = 0; j &lt; len; ++j) &#123; new_array[j] = array[j]; &#125; // new_array 复制给 array，array 现在大小就是 2 倍 len 了 array = new_array; len = 2 * len; &#125; // 将 element 放到下标为 i 的位置，下标 i 加一 array[i] = element; ++i;&#125; 解答： 最好时间复杂度：当 i 小于 len 时，代码不执行 if 语句，算法时间复杂度是 O(1)， 最坏时间复杂度：当 i &gt;= len 时，代码开始执行 if 语句，里面有个循环操作，所以算法时间复杂度是 O(n)。 平均情况复杂度：进入 if 语句后，数组扩容 2 倍，数组每次插入元素的概率都是 1/len + 1，所以根据加权时间复杂度计算公式为 1 1/len + 1 + 1 1/len + 1 + … + len *(1/(len+1)) = 1，所以平均情况复杂度是 O(1)。 均摊时间复杂度：每次 O(len)前都有 len 次 O(1)，存在前后连贯的时序关系，所以可以将高时间复杂度的 O(len) 平摊到之前的 len 次上，所以均摊时间复杂度是 O(1)。 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「青争哥哥」。]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法学习-开篇]]></title>
    <url>%2F2019%2F02%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言数据结构和算法这门课一直是计算机专业最基础的一门课，大学时期掌握的不够好，毕业后长期写业务，也没有特别的花时间好好攻克一下，一直是自己的短板。这次在极客时间上订阅了两门数据结构和算法方面的专栏，一是 Google 工程师王争老师主讲的《数据结构与算法之美》专栏，另一篇是前 Facebook 工程师覃超老师主讲的视频专栏《算法面试通关40讲》，计划将这两个专栏配合着学习，相互补充，并适时输出学习笔记。这是第一篇学习笔记，主要回答了数据结构和算法是什么？为什么要学习？以及怎么样学习？这三个问题。 数据结构与算法是什么？数据结构与算法是每个计算机专业必修的一门课，这里分为两个部分，一个是数据结构，一个是算法。 数据结构是一组数据的存储结构，算法是操作数据的一组方法。数据结构和算法是相辅相成的，数据结构是为算法服务的，算法是作用在特定的数据结构之上。数据结构和算法解决的是如何更省、更快地存储和处理数据的问题。 为什么要学习数据结构与算法？如果把一个优秀程序员需要掌握的技能和金庸武侠小说中的武功技能类比，那么掌握多少门编程语言就如同掌握了多少招式，如降龙十八掌，打狗棒法等，而数据结构与算法就如同是武林高手的内功，像九阳神功、易筋经一样。内功就如同基础，只有内功扎实，学习任何招式就会事半功倍。 总结下有这几个理由： 进入国内外大厂必备 修炼编程基础思维，写出性能更优的代码 提高学习力，掌握计算机程序的本质 怎么样学习数据结构与算法？#学什么这是王争老师绘制的一张几乎涵盖了所有数据结构与算法知识点的知识图谱： 学习重点： 学习复杂度分析，考量效率和资源消耗的标准。 最常用、最基础的 20 个数据结构与算法，学习他们的：来历、特点、适合解决什么问题和实际的应用场景。 数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树。 算法：递归、排序、二分查找、搜索、哈希算法、分治算法、回溯算法、动态规划、字符串匹配算法。 #怎么学 边学边练习，三分学，七分练。将每次讲到的数据结构和算法使用自己熟悉的编程语言实现一遍，这里将先使用最常用的 C 语言实现，后面想再分别使用 Objective-C、Swift、JavaScript 实现一遍。 多问多思考多互动，在专栏留言区多提问，参与讨论，一起进步。 设定切实可行目标，每次学习完输出学习笔记。 心态平和，沉淀知识，反复迭代。 #有关书籍 入门：《大话数据结构》、《图解算法》 编程语言：《数据结构和算法分析》 面试：《剑指offer》、《编程之美》、《编程珠玑》 闲暇阅读：《算法帝国》、《数学之美》、《算法之美》 经典大部头：《算法导论》、《算法》 殿堂级：《计算机程序设计艺术》 分享个人技术学习记录和跑步马拉松训练比赛、读书笔记等内容，感兴趣的朋友可以关注我的公众号「青争哥哥」。]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Developing-iOS-11-Apps-with-Swift》学习笔记（七)]]></title>
    <url>%2F2019%2F01%2F18%2F%E3%80%8ADeveloping-iOS-11-Apps-with-Swift%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%2F</url>
    <content type="text"><![CDATA[前言这套课程是苹果官方推荐的入门 iOS 开发的学习课程。之前也听过，Paul 老爷子讲的非常好，这次准备重看一遍，顺便把 swift 和 iOS 相关的一些基础知识点复习一遍。文章会按照视频的次序写笔记，记录重点以及自己的理解。 课程地址 Demo 示例地址 参考资料一：官方文档参考资料二：官方文档中文翻译]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Developing-iOS-11-Apps-with-Swift》学习笔记（六)]]></title>
    <url>%2F2019%2F01%2F17%2F%E3%80%8ADeveloping-iOS-11-Apps-with-Swift%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%2F</url>
    <content type="text"><![CDATA[前言这套课程是苹果官方推荐的入门 iOS 开发的学习课程。之前也听过，Paul 老爷子讲的非常好，这次准备重看一遍，顺便把 swift 和 iOS 相关的一些基础知识点复习一遍。文章会按照视频的次序写笔记，记录重点以及自己的理解。 课程地址 Demo 示例地址 参考资料一：官方文档参考资料二：官方文档中文翻译 这节课通过讲解扑克牌绘制的Demo。将上一节课里面讲到的绘图、触摸事件、手势等知识点串联起来了，另外插入了一些 AutoLayout 相关的知识点。 手势 Gestrue手势基本概念 UIGestureRecognizer 是一个抽象父类，具体实现有其具体的子类实现 步骤： 添加手势到具体的视图上 处理手势反馈的事件（非必须） 1. 添加手势可以在视图属性 didSet 时添加上去 在 iOS runtime 时，当这个视图和控制器相关联时就会调用 参数：target 是获取手势通知对象 参数：action 是手势响应时的方法，方法的参数是手势 recognizer 对象 2. 处理手势每个具体子类都提供了具体的特殊的方法来处理，如 UIPanGestureRecognizer 提供了三个方法 123456// func translation(in: UIView?) -&gt; CGPoint // 手势速度func velocity(in: UIView?) -&gt; CGPoint func setTranslation(CGPoint, in: UIView?) 抽象父类也提供了诸如手势状态的一些属性，描述手势的状态信息 手势分类1. UIPanGestureRecognizer：拖动手势1234func translation(in: UIView?) -&gt; CGPoint func velocity(in: UIView?) -&gt; CGPoint func setTranslation(CGPoint, in: UIView?) 2. UIPinchGestureRecognizer：捏合手势，用于缩放12var scale: CGFloat var velocity: CGFloat &#123; get &#125; 3. UIRotationGestureRecognizer：旋转手势12var rotation: CGFloat var velocity: CGFloat &#123; get &#125; // radians per second 4. UISwipeGestureRecognizer：滑动手势12345// 滑动支持的方向，可以组合var direction: UISwipeGestureRecoginzerDirection // 触发手势时手指的数量var numberOfTouchesRequired: Int 5. UITapGestureRecognizer：点击手势12345// 单击，双击，N击var numberOfTapsRequired: Int // 点击屏幕是要求手指的数量var numberOfTouchesRequired: Int 6. UILongPressRecognizer：长按手势1234567// 最小触摸时间var minimumPressDuration: TimeInterval // 点击屏幕是要求手指的数量var numberOfTouchesRequired: Int // 在至少多少范围内移动手势依然生效var allowableMovement: CGFloat DEMO自定义实现对象的打印日志 设置字体大小随系统设置改变而即时改变 AutoLayout 设置约束优先级 @IBDesignable 和 @IBInspectable @IBDesignable： 将代码的设置显示到IB监视器中去，直接在IB中观察而不用重新运行模拟器 @IBInspectable：将属性显示到IB监视器中去设置 将图片绘制到视图上]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Developing-iOS-11-Apps-with-Swift》学习笔记（五)]]></title>
    <url>%2F2019%2F01%2F04%2F%E3%80%8ADeveloping-iOS-11-Apps-with-Swift%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[前言这套课程是苹果官方推荐的入门 iOS 开发的学习课程。之前也听过，Paul 老爷子讲的非常好，这次准备重看一遍，顺便把 swift 和 iOS 相关的一些基础知识点复习一遍。文章会按照视频的次序写笔记，记录重点以及自己的理解。 课程地址 Demo 示例地址 参考资料一：官方文档参考资料二：官方文档中文翻译 这节课主要讲了一些常用的系统对象，以及一个扑克牌绘制的Demo。 Thrown Errors抛出异常，在 swift 中，语法是： 123456789101112131415// 抛出异常func save() throws// 处理异常do &#123; try context.save()&#125; catch let error &#123; // 重新抛出异常 throw error &#125;// 确定不会异常，可以使用`try! `try! context.save() // 不确定，使用`try? `let x = try? errorProneFunctionThatReturnsAnInt() Any &amp; AnyObject介绍 Any &amp; AnyObject 过去常常是为了兼容 Objective-C 而存在的，但是自从在 iOS 11 后 Objective-C APIs 更新后就不在使用了 区别：Any 可以表示任何类型，而 AnyObject 只能表示 Class 类 swift 是一门强类型语言，不能直接对 Any &amp; AnyObject 发送消息，必须要转成具体的类型先 为了体现 swift 强类型语言的优点，在 swift 中我们要避免使用 Any 使用场景 let attributes: [NSAttributedStringKey:Any]：在字典表示中 value 可以是任何类型 有时候但比较少见出现在函数的参数中，func prepare(for segue: UIStoryboardSegue, sender: Any?) 这些是旧的 Objective-C API，在 swift 中使用带关联值的枚举或者协议来代替。 类型转换使用 as? 转换 Any 到具体的类型 12345let unknown: Any = ... if let foo = unknown as? MyType &#123;&#125; 注意：as? 并不是 Any 专有的，as? 其实经常用来将父类转成子类，从而调用子类的方法，另外也用来转化类型实现的协议。 其他一些类NSObject 所有 Objective-C 的基类 在 swift 中，一些高级特性需要定义子类继承自 NSObject NSNumber 数值泛型，是引用类型 12345// 将数值转成NSNumberlet n = NSNumber(35.5) or let n: NSNumber = 35.5// 将NSNumber转成具体的数值let intified: Int = n.intValue // also doubleValue, boolValue, etc. Date过去，现在，将来的日期的时间对象，相关 Calendar, DateFormatter, DateComponents 等对象，结果是本地化后的结果。 Data二进制数据，在整个 iOS SDK 中，用来保存，重新存储、传递原始数据。 视图 一个视图（UIView 以及UIView的子类）表示了一块矩形区域： 定义空间坐标 绘图 处理触摸事件 层次 一个视图只有唯一的父视图：var superview: UIView? 可以有许多或者没有子视图：var subviews: [UIView] 子视图数组中的顺序：索引更后面的子视图越显示在索引更前面的子视图顶部 一个视图可以决定是否裁剪他的子视图超出自己 bounds 部分 UIWindow UIWindow 是在整个视图层次中最最顶部的视图，甚至包含了状态栏 整个 App 生命周期中只有一个 UIWindow 视图 可以使用 Xcode graphically 查看视图的层次结构 使用代码添加或者删除一个视图 视图的层次从哪里开始？ 最顶部的视图是控制器的 view 属性：var view: UIView. 控制器的 view 在设备旋转时 bounds 会发生改变 初始化一个view 使用代码创建的view：构造器是 init(frame: CGRect) 使用storyboard创建的view： 构造器是 init(coder: NSCoder) 如果需要重载视图构造器，需要实现两个构造器 123456789101112func setup() &#123; ... &#125;override init(frame: CGRect) &#123; super.init(frame: frame) setup() &#125;// 可失败构造器，必须实现requiredinit?(coderaDecoder:NSCoder)&#123; super.init(coder: aDecoder) setup()&#125; 另一个可供替代的方案：awakeFromNib()，只有当视图从 storyboard 中创建才会调用，但不是一个构造器，在视图构造完成后会立即调用这个方法，所有在 storyboard 中继承自 NSObject 的对象都会调用这个方法。但调用顺序是不确定的。 坐标系统中的数据结构CGFloat总是用来在坐标系统中代替 Double 或者 Float，可以使用构造器相互转化：let cgf = CGFloat(aDouble) CGPoint表示坐标系中的一个点，数据结构中只用两个 CGFloat，x 和 y. 123var point = CGPoint(x: 37.0, y: 55.2)point.y -= 30point.x += 20.0 CGSize包含了两个 CGFloat，width 和 height。在坐标系统中用来表示视图的大小。 123var size = CGSize(width: 100.0, height: 50.0) size.width += 42.5size.height += 75 CGRect包含了 CGPoint 和 CGSize 的结构体，用来表示视图的位置和大小。 123456789101112131415161718192021// 结构体对象struct CGRect &#123; var origin: CGPoint var size: CGSize&#125;// 初始化let rect = CGRect(origin: aCGPoint, size: aCGSize)// 最小的Xvar minX: CGFloat// 中间的Yvar midY: CGFloat// 是否和给定的rect相交intersects(CGRect) -&gt; Bool// 裁剪和给定的rect相交的部分intersect(CGRect)// 是否包含了一个给定的点pointcontains(CGPoint)-&gt;Bool 视图坐标系统 原点是左上角 实体是点 Point，不是像素 Pixels 像素 Pixels 是设备能够绘制的最小的实体 点 Point 是坐标系统中的最小实体 iOS 设备常见是每个点两个像素，有些是设备是 3 个 每个点有多少个像素，视图有个属性：var contentScaleFactor: CGFloat bounds vs frame bounds：视图内部能够绘图的矩形空间，包括 origin 和 size，是以自己的坐标系统做参考的。 frame：在视图的父视图坐标系统中，包含视图的 rect。 注意：bounds 和 frame 不总是相等的，如当视图旋转、拉伸后 bounds 和 frame就不相等了。 创建视图创建视图的两种方式: storyboard 代码 1234let labelRect = CGRect(x: 20, y: 20, width: 100, height: 50)let label = UILabel(frame: labelRect) label.text = “Hello”view.addSubview(label) 自定义视图1. 自定义视图可以用来做什么？ 需要在屏幕上自定义绘图； 需要用特殊的方式处理触摸事件，而不是像 button 或者 slider 控件等那样； 通过创建 UIView 的子类并重载 draw(CGRect) 来绘图 注意：不要主动调用 draw(CGRect) 方法，如果需要重新绘图，可以调用 setNeedsDisplay()或者 setNeedsDisplay(_ rect: CGRect) 告诉系统，系统将会在适合的时间调用 draw(CGRect) 方法，其中 rect 参数为需要重绘制的区域。 2. 怎么绘图？#绘图上下文123456789101112131415// 使用图像上下文绘制一个圆形if let context = UIGraphicsGetCurrentContext() &#123; // 在当前图形上下文上添加一个圆形 // 参数 center：原点，radius：半径，startAngle：开始角度，endAngle：结束角度，clockwise：顺时针还是逆时针 context.addArc(center: CGPoint(x: bounds.midX, y: bounds.midY), radius: 100, startAngle: 0, endAngle: 2*CGFloat.pi , clockwise: true) // 设置边线宽度 context.setLineWidth(5.0) // 设置填充颜色 UIColor.red.setFill() // 设置边线颜色 UIColor.green.setStroke() context.fillPath() context.strokePath()&#125; #贝塞尔曲线 UIBezierPath 能够自动绘制到当前的上文中去 UIBezierPath 提供绘图的方式以及设置属性的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1. 使用 UIBezierPath 绘制三角形// 创建UIBezierPath对象let path = UIBezierPath()// 定位到(80, 50)点path.move(to: CGPoint(80, 50))// 从(80, 50)点开始画直线到(140, 150)path.addLine(to: CGPoint(140, 150))// 从 (140, 150) 开始画直线到(10, 150)path.addLine(to: CGPoint(10, 150))// 封闭路径path.close()// 设置填充色UIColor.green.setFill()// 设置线框颜色UIColor.red.setStroke()// 设置线框宽度path.linewidth = 3.0path.fill()path.stroke()// 2. 使用贝塞尔曲线绘制一个圆let path = UIBezierPath()path.addArc(withCenter: CGPoint(x: bounds.midX, y: bounds.midY), radius: 100, startAngle: 0, endAngle: 2*CGFloat.pi , clockwise: true)path.lineWidth = 5.0UIColor.red.setFill()UIColor.green.setStroke()path.stroke()path.fill()// 3. 带圆角的矩形let roundedRect = UIBezierPath(roundedRect: rect, cornerRadius: cornerRadios)// 裁剪roundedRect.addClip()UIColor.white.setFill()roundedRect.fill()// 判断给定点是否在路径里面，路径必须是关闭的func contains(_ point: CGPoint) -&gt; Bool UIColor let green = UIColor.green，定义颜色，其他方式如 RGB, HSB 等 带透明度的颜色：UIColor.yellow.withAlphaComponent(0.5) 设置整个 View 的透明度：var alpha: CGFloat 注意：如果想要绘制带透明度的颜色，需要设置 var opaque = false Layers 在 UIView 下面，负责掌管绘图工作的是 CALayer，其中 CA 代表是“Core Animation”. 可以通过视图的属性直接访问：var layer: CALayer CALayer 中比较常用的几个属性 1234567// 圆角var cornerRadius: CGFloat// 边框宽度var borderWidth: CGFloat// 变宽颜色var borderColor: CGColor? 注意：需要将颜色转成 cgColor. View Transparency 隐藏一个 View 而不用将 View 从视图层次中移除出去：var isHidden: Bool 绘制文本 通常，使用 UILabel 来在屏幕上显示文本 绘制文本使用 NSAttributedString 12345let text = NSAttributedString(string: “hello”) // 从给定点开始文本绘制text.draw(at: aCGPoint) // or draw(in: CGRect)let textSize: CGSize = text.size 字体代码获取字体 static func preferredFont(forTextStyle: UIFontTextStyle) -&gt; UIFont：特别的，获取到的字体大小在 系统-&gt;设置 中修改后会立即生效 获取指定的字体：let font = UIFont(name: “Helvetica”, size: 36.0) static func systemFont(ofSize: CGFloat) -&gt; UIFont 和 static func boldSystemFont(ofSize: CGFloat) -&gt; UIFont 绘制图片 UIImageView UIImage 对象 加载在 Assets.xcassets 存储的图片资源：UIImage(named: “foo”) 通过图片文件路径加载：let image: UIImage? = UIImage(contentsOfFile: pathString) 通过图片的原始数据（jpg, png, tiff等）加载：let image: UIImage? = UIImage(data: aData) 通过 Core Graphics 图形上下文创建 绘制图片 1234567// 给定的的点作为左上点开始绘制图片image.draw(at point: aCGPoint) // 将图片拉伸绘制到给定的 rectimage.draw(in rect: aCGRect) // 将图片平铺绘制到给定的 rectimage.drawAsPattern(in rect: aCGRect) // tiles the image into aCGRect 视图 bounds 改变时是否重新绘制Redraw？ 当视图 bounds 改变时，默认不会重新绘制 UIViewContentMode：指定视图内容模式 .left/.right/.top/.bottom/.topRight/.topLeft/.bottomRight/.bottomLeft/.center：不拉伸视图，视图优先在指定位置开始绘制 .scaleToFill/.scaleAspectFill/.scaleAspectFit ：会拉伸视图， .scaleToFill 默认 .redraw：通过调用 draw(CGRect) 重新绘制 视图 bounds 改变时是否重新布局Layout？ 当视图 bounds 改变时，如果要重新布局子视图的话 通过 Autolayout 约束 通过重载 layoutSubviews 方法，手动重新布局子控件 1234override func layoutSubviews() &#123; super.layoutSubviews() // reposition my subviews’s frames based on my new bounds &#125; DEMO 构造一张扑克牌结构体，有四种花色，13 中大小，其中包括，ace、numeric、face，使用了带关联值的枚举。 一副扑克牌 随机抽取 10 张 打印结果]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS JS-Native 交互方案总结]]></title>
    <url>%2F2018%2F12%2F28%2FiOS-JS-Native-%E4%BA%A4%E4%BA%92%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言随着移动互联网的发展，一些跨平台技术层出不穷，如 Facebook 的 ReactNative、阿里的Weex、国内各大互联网大厂的小程序、PWA、Google 的 Flutter 等，各种前端技术和原生混合形式开发方式正在成为一个大的趋势，所以在日常 iOS 开发中，经常会有原生 App 嵌入网页的业务需求，因此常常会有网页和原生页面交互的场景出现，希望能够结合网页和原生的各自优势，打造更极致的用户体验。本文就是总结日常开发中常见的几种 JS-Native 交互方案。 本文结合具体代码示例，尝试从使用、原理浅析、方案对比这几个角度来介绍各种方案的优缺点，希望能够说清楚在不同的业务场景下开发者该如何选择最合适自己的方案，最后，还会尝试自己实现一套满足基本业务需求的轻量级 hybrid 方案并展望未来。 使用一般情况下，一个原生和网页的交互需求需要满足一下几点： 网页能够获取原生特有的一些能力，如调用原生的方法，获取原生的数据，监听原生的事件。 原生能够执行 JS 的代码，并将数据传递给网页。 一、JS 调用原生1. 假链接跳转拦截2. JavaScriptCore 系统库3. WebViewJavaScriptBridge 第三方库4. WKWebView 的 scriptMessageHandle5. 跨平台框架二、原生调用 JS1. UIWebView2. JavaScriptCore 系统库3. WebViewJavaScriptBridge 第三方库4. WKWebView 的 scriptMessageHandle5. 跨平台框架UIWebView 时代在 iOS 8 以前，可以使用 UIWebView 控件来做。 WKWebView ## 跨平台框架ReactNativeWeexphoneGap-cordova原理浅析各种方案对比]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队 git-flow 开发流程]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%9B%A2%E9%98%9F-git-flow-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言之前做项目的时候，出现过一些因为代码提交管理出现的问题。问题如下： 分支过多，每个做马甲一个分支，每次混淆完又一个备份分支，每次企业包发版一个分支、每个新特性又是一个分支，大量的分支，又没有及时的删除，一方面容易造成 git 服务器的存储压力，另一方面，大量的提交记录造成工程体积庞大，全部 clone 下来好几个 G，费时费力，http 方式 clone 也容易报 RPC failed; curl 18 transfer closed with outstanding read data remaining 错。 有些文件和资源没有必要纳入到版本管理中去。如 pod 的库，只保存 podfile 文件在远程就可以了，需要的时候本地 podfile install/update 就行，可以添加到 git 忽略文件里去。github 上专门有个仓库收纳了各个语言开发时的 gitignore 模板，可以参考下。 修改 bug 或者开发完新特性后没有及时全部同步到所有分支。同样是因为分支过多以及没有一个规范，造成有些 bug 或者新特性在某个分支修复和开发完了，另外的分支却没有及时同步。 打包管理，应该要保证发包前测试通过后的项目代码是不能有任何修改的，最好能够自动化打包，避免开发人员人为修改代码后打包上传，造成测试人员测试通过的代码和真正发包的代码不一致问题。 git 规范参考 git flow，一图胜千言 中心分支生命周期长，一直存在。 Master（主分支）顾名思义，既然名字叫 Master，那么该分支就是主分支的意思。在 git repo下主分支的职责主要就是负责记录 stable版本的迭代，当在 beta 版本的项目或是开发版本的项目得到了充分的验证之后，才能将分支并入 master 分支。master 分支永远是 production-ready 的状态，即稳定可产品化发布的状态。每发布一个版本则打上对应的 tag 标签。 Develop（开发分支）这个分支是平常开发的一个主要分支，不管是要做新的 feature 还是需要做 bug fix，都是从这个分支分出来做。在这个分支下主要负责记录开发状态下相对稳定的版本，即完成了某个 feature 或者修复了某 个bug 后的开发稳定版本。从 develop 分支总能够获得最新开发进展的代码。 1. 从 master 分支迁出1git checkout -b develop master 2. 拉取远程最新代码1git fetch origin develop 3. 合并本地123git merge origin/develop// 或者git rebase origin/develop 4. 推送到远程1git push origin develop 辅助分支生命周期短，完成使命后删除。 Feature branches（功能分支）这是由许多分别负责不同 feature 开发的分支组成的一个分支系列。new feature 主要就在这个分支系列下进行开发。当在一个大的 develop 的迭代之下，往往会把每一个迭代分成很多个功能点，并将功能点分派给不同人的人员去开发。每一个人员开发的功能点就会形成一个 feature 分支，当功能点开发测试完毕之后，就会合并到 develop 分支去。 1. 从 develop 分支新建一条特性分支并切到这条分支上1git checkout -b feature-xxx develop 2. 做完了新特性切回到 develop 分支1git checkout develop 3. 合并新特性分支1git merge --no-ff -m "合并说明" feature-xxx 4. 删除分支1git branch -d feature-xxx 5. 提交代码到远程1git push origin develop Release branches（发布辅助分支）Relase branch 通常负责短期的发布前准备工作、小 bug 的修复工作、版本号等元信息的准备工作。与此同时，develop 分支又可以承接下一个新功能的开发工作了。 在一段短时间内，在 Release branches 上，我们可以继续修复 bug。在此阶段，严禁新功能的并入，新功能应该是被合并到 develop 分支的。 经过若干 bug 修复后，Release branches 上的代码已经达到可发布状态，此时，需要完成三个动作：第一是将 Release branches 合并到 master 分支，第二是一定要为 master 上的这个新提交打 Tag（记录里程碑），第三是要将 Release branches 合并回 develop 分支。 1. 当一个迭代测试的差不多的时候，从 develop 分支切出来1git checkout -b release-0.1 develop ​ 2. 一旦准备好了发版，合并修改到 master 分支和 develop 分支上，删除发布分支​​12345​#合并修改到 master 分支git checkout master git merge --no-ff -m "合并说明" release-0.1 git push origin master​ ​ 3. 打标签1234git tag -a v0.1 -m "version 0.1 released"// 推送标签到远程git push origin v1.0 ​ 4. 合并修改到 develope 分支123git checkout develop git merge --no-ff -m "合并说明" release-0.1 git push origin develop ​ 5. 删除发布分支1git branch -d release-0.1 Hotfix branches（热修复分支）这个分支系列是紧急线上修复，当线上出现 bug 且特别紧急的时候，就可以从 master 拉出分支到这里进行修复，修复完成后分别并入 master 和 develop 分支。 1. 从 master 主分支上切出来1git checkout -b hotfix-#001 master 2. 修复bug完成12345678910111213#切回主分支git checkout master #合并到主分支git merge --no-ff -m "合并说明" hotfix-#001 #推送到远程git push origin master# 合并到 develop 分支git checkout developgit merge --no-ff -m "合并说明" hotfix-#001​#删除 bug 修复分支git branch -d bugfix-#001 pull request &amp; codeReview需要执行 codeReview 的时候可以引入一些工具，在完成代码推送到远程后，将提交合并到 mater 分支之前，设置 codeReview。 解决冲突还未提交到本地暂存区 123456789# `file` 指那个需要回退的文件git checkout -- file 已经提交到本地暂存区，没有提交到本地# `file` 指那个需要回退的文件git reset HEAD file ​# 此操作相当于让之前的 git add 失效：git checkout -- file 已经提交到本地，没有提交到远程 123# 此操作相当于让之前的 git commit -m "修改说明" 失效。# HEAD^表示上一个版本，HEAD^^则表示上上个版本，再往上 100 个版本可以写成HEAD~100git reset --hard HEAD^ 已经提交到远程 1234567# 采取 revert 的方法，相当于重新生成一个提交，来撤销前一次错误的commit:git revert HEAD​# 然后再把从工作区提交到暂存区，最后推送到远程分支：git add .git commit -m "撤销上次提交的修改"git push origin master 草稿箱有时候，需要切换到其他分支去，而当前分支开发任务还未完成提交，可以暂存到草稿箱中去。 12345678910111213# 存入草稿箱git stash​# 取出草稿git stash popgit stash apply​#查看草稿箱git stash list​#显示某次草稿的具体文件git stash show [stash序号] 注意点待补充…]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活动行 App_iOS 性能检测分析]]></title>
    <url>%2F2018%2F08%2F20%2F%E6%B4%BB%E5%8A%A8%E8%A1%8C-App-iOS-%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[性能检测使用到的相关工具 instruments： XCode 内置的性能检测工具，可以实时查看程序内存占用，调试的内存泄漏，代码执行耗时，页面渲染，网络等，并可辅助定位到具体的代码； MLeaksFinder：微信读书开源的一款 debeg 模式下精准 iOS 内存泄露检测工具； BLStopwatch：代码耗时打点计时器 ImageOptim：图片压缩工具； LSUnusedResources：扫描项目中未使用到的无用资源，一键清除； LinkMap：检测出每个类在最终的可执行文件中占据的大小； FHHFPSIndicator：debug 模式下实时显示页面的滑动帧率； 测试环境 真机：iPhone 6 plus 系统：iOS 11.4 模式：release 1. 启动时间 启动时间是从用户点击 App 图标开始，到用户看到第一个界面总耗费的时间。 iOS App 的启动时间可以分为一下两个部分： preMain 耗时 main 函数调用到第一个 ViewController 的 viewDidAppear 调用耗时 #1.1 preMain 耗时测量preMain 耗时可以在 XCode -&gt; Product -&gt; Scheme -&gt; Edit Shchem -&gt; Run -&gt; Environment Variables -&gt; + -&gt; 添加 name 为 DYLD_PRINT_STATISTICS，Value 为 1 的环境变量。 在控制台就可以打印出 preMain 耗时的相关信息 信息解读 main()函数之前总共使用了 533.97 ms； 在 533.97 ms中，加载动态库用了 108.68ms，指针重定位使用了 74.48ms，ObjC 类初始化使用了56.81ms，各种初始化使用了 293.49 ms； 在初始化耗费的 293.49ms 中，用时最多的五个初始化是 libSystem.B.dylib、libBacktraceRecording.dylib、libMainThreadChecker.dylib、libglInterpose.dylib以及 hdx； 说明：preMain 时间在小于 400ms 是最佳的，因为从点击图标到显示启动图，再到启动图消失这段时间是 400ms。同时启动时间不可以大于 20s，否则会被系统杀掉。 #1.2 main 函数调用之到第一个 ViewController 的 viewDidAppear 调用耗时测量 手写统计耗时代码 使用打点计时器工具进行打点 工作原理： 只需要在 main 函数中开启 start 方法计时，然后在 didFinishLaunchingWithOptions 方法中对启动时调用的相关方法做打点，最后在首页控制器 viewDidAppear 中结束打点计时，从而可以根据每个节点，统计出打点方法的调用时间以及总时间。 #1.3 测量数据统计分析 总共测试 5 次。 次数 preMain mian 到首屏控制器 viewDidAppear 第一次 584.76ms 4.276s 第二次 628.80ms 4.173s 第三次 815.88ms 4.334s 第四次 610.94ms 4.331s 第五次 590.88ms 4.357s 平均值 646.25ms 4.294s #1.4 优化方向 preMain preMain 时间在小于 400ms 是最佳的，因为从点击图标到显示启动图，再到启动图消失这段时间是 400ms。同时启动时间不可以大于 20s，否则会被系统杀掉。 这里面主要做了一些 iOS 系统动态库的链接、App 中 objc 类的加载。 针对这里的优化： 合并自己添加的动态库，减少动态库的数量，目前我们没有使用自己添加的动态库； 合并 Category 和功能类似的类，这个确实存在不少； 删除无用的方法和类； 用 initialize 方法替代 load，减少每个类的 load 方法的执行时间； main()函数 -&gt; 第一个页面渲染完成，用户看到界面的时间。这里可以做的优化有： 从几次测试数据可以看出，主要的耗时一个是在第三方 SDK 的初始化上，耗时超过 1s，另一个是根控制器极其相关控制器的初始化上。所以优化性价比最高的地方应该是这两个地方 能延迟执行的就延迟执行。比如 SDK 的初始化，界面的创建，将页面请求加载数据、渲染等操作转移到viewWillAppear 方法中去； 不能延迟执行的，尽量放到后台执行，比如一些读取沙盒用户偏好缓存的数据操作； 2. 安装包体积#2.1 包体积检测和分析打包后的 ipa 包体积： 解压缩后右键显示包内容： 可以看到安装包主要构成： 其中，主要的体积消耗在： 二进制代码：31.2 M .car 资源文件：11.2 M 图片等资源文件：4.7 M #2.2 包体积优化 图片优化：使用 ImageOptim 图片压缩工具对工程中的图片做一次压缩处理； 清除无用的资源：使用 LSUnusedResources 工具，清除掉工程中未使用到的资源文件； 可以看到无用的资源文件特别多。 二进制文件优化：使用 LinkMap 工具检测出每个类或者库在最终的可执行文件中所占用的空间大小（代码段+数据段），进行针对性的优化； 编译后 arm 7 架构下每个库或者类在最终的可执行文件中所占用的空间大小： 一些编译选项优化的开关开启； 3. 内存 Xcode Analyze 静态分析工具分析可疑泄露点，有些真的存在，有些不存在，可以通过结合 Instruments 动态分析工具以及代码上下文排除解决 主要包含以下几个部分： 面向用户的文本应该使用本地化; 无效数据监测; 逻辑错误：访问空指针或未初始化的变量等； 内存管理错误：如内存泄漏等； 声明错误：从未使用过的变量； API 调用错误：未包含使用的库和框架; Xcode Instruments 动态分析工具中的 Leaks 和 Allocations 跟踪模板进行动态跟踪分析, 确认这些点是否真的泄漏, 或者是否有新的泄漏点出现 #3.1. 内存方面可做的优化一般在占用系统内存超过 20% 的时候会有内存警告，而超过 50% 的时候，就很容易被系统 Crash。 iOS 中内存问题主要包含两个部分: 循环引用 Delegate：检查所有用到的代理对象属性是否是使用weak内存管理策略 NSTimer：使用 GCD 定时器代替 NSTimer，GCD 定时器的优点是时间误差小，不会发生循环引用； Block: 检查所有用到 Block 的地方，是否存在循环引用问题； NSNotificationCenter：检查 NSNotification addObserver 后是否有移除； 大量数据加载及使用导致的内存警告 处理每个单独页面以及整个 App 收到的内存警告，及时释放掉相关的资源； 4. 页面卡顿根据苹果官方说法，当 FPS 低于 45 的时候，用户就会察觉到到滑动有卡顿 日常开发时，做好 FPS 实时监控，可使用 FHHFPSIndicator 工具在 debug 模式下运行，在出现掉帧的页面，可做如下优化： 清除在主线程中进行的耗时操作 建立缓存机制，如缓存表格视图中 cell 的高度； 避免离屏渲染，尽量避免使用 layer 的 border、corner、shadow、mask 等属性，在后台线程预先绘制好对应内容； 性能优化原则过早的优化是万恶之源。优化要站在实际的需求角度出发，不能为了优化而优化，应该优化那些真正的性能瓶颈，体验落后，性价比最高、最值得优化的地方，同时又要站在整体的角度，做一些取舍和权衡，比如为了卡顿优化，往往需要缓存一些数据到内存中，从而会引起内存增长，如果内存中缓存的数据过多，内存就容易出现性能瓶颈，为了更好更快的监控一些数据，往往会集成一些第三方 SDK，这就又会导致安装包体积的增加。 具体应该通过检测到的性能数据指标来做具体优化，可以使用苹果自带的 instruments 工具来检测，找到突破点，优化一点，检测一下，观察性能数据的变化，如此反复。 性能优化原则 如何提高应用的质量1. 开发日常避免 制定代码规范，严格遵守 定期代码审查（code review） 编写单元测试 引入一些 debeg 模式下的工具，如内存泄漏监控，FPS 等，在开发调试阶段将问题暴露出来； 定期进行代码重构，及时清理删除一些没有使用到的资源和代码； 2. 测试保障体系 将一些关键性能指标纳入测试上线标准 引入一些自动化测试，自动化打包，自动化代码集成的工具脚本，提高日常开发测试工作效率 3. 线上APM监控 自研或者借助第三方的 APM 工具。对线上应用进行监控、预警、快速修复。 参考资料 即刻 iOS App 启动速度研究实践 腾讯 wifi 管家 iOS App 启动性能优化- 今日头条 iOS 客户端启动速度优化 今日头条 iPhone 安装包的优化 iOS 内存泄漏监测自动化]]></content>
      <categories>
        <category>iOS</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记最近几次的面试]]></title>
    <url>%2F2018%2F06%2F16%2F%E8%AE%B0%E6%9C%80%E8%BF%91%E5%87%A0%E6%AC%A1%E7%9A%84%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前言最近部门被裁员了，虽然不情愿，但这并不以我的意志为转移，生活还要继续，于是重新写简历，找工作。 记录一下最近几次面试遇到的一些问题。 国内某电商大厂电话面试很意外，收到投递简历的邀请，下午 5 点投递，20 分钟后杭州的电话就打过来了，直接说晚上电话面试，很强势。说是要组建一个全新的研发部，要将国内的电商成功模式复制到东南亚，大量招人。 这些大厂的面试确实面试官都会提前准备，如提前下载好你的项目 App，阅读你简历上写的博客中的文章，提问也是由浅入深，从你做过的项目入手，然后根据你的回答情况再提问，主要分为项目经验和 iOS 基础部分。虽然结果也是 gg 了，但今年能收到这些大公司的面试邀请也算是看到了一点希望呢！再努努力也许能够得着！ 说一下做过的项目中最有难度的一个技术点？ Google 的 Flutter 的原理有了解过吗？和 RN 的区别？ 原生 App 中的网页容器？RN 这些有了解过吗？ Runloop 是什么？你是怎么理解的？ RunTime 是什么？在项目中具体那些地方用到过吗？ GPU 渲染和 CPU 渲染的区别？ tableview 如何做性能优化？ 平常项目中怎么切圆角？ MVC 和 MVVM 这些架构模式有了解过吗？MVVM 的双向绑定是怎么做的？ 安装包瘦身是怎么做的？用到的相关清理工具的原理是什么？ 某图片美化公司该公司海外事业部的技术总监电话面试。没有问到很具体的技术问题，主要是聊了下工作和项目经历，主要有两个问题，一个是项目中最有挑战性的一个技术点，另外一个是项目中遇到过的多线程相关的问题？聊外直接约公司面试了。 二面，三面 手写算法实现找出两个视图实例的公共父视图，有则输出，没有则输出nil？ 手写算法实现找出一个视图所有的子视图？ 手写算法实现冒泡、条件、选择、堆排序中的一种？ 代码纠错，一段代码中的纠错？ tableview 的优化？ 算法实现一个字符串中最长的不重复的子串的长度？ 你做过最有技术难点的一个项目？ 你做过最复杂的一个业务是什么？ 算法面试官评价：表现在候选人里面很平均。技术负责人评价：技术面较窄。 某南极动物厂电话面试首先，非常感谢以前公司的老大帮我内推简历，于是在某一个晚上如愿收到了相关技术部门打来的面试电话。面试结果过当然是没过了，一方面个人能力确实有欠缺，达不到人间的要求，另一方面，也确实没准备好，无准备之仗肯定是要失败的，面试官挺厉害的，能够根据一个知识点由浅至深一步一步提问，又问到的问题大概有： 加载大量内存怎么优化？ 说一下 http 的状态码？ 怎么切圆角？ Sd webimage 的缓存清理策略？ load 和 initialles 方法的区别？ 连续动画怎么做？ 清理多余图片资源使用的工具的清理原理是什么？ 全景图原理是什么？ 用过什么系统的原生库吗？ coredata 用过吗？ 某智能家居上市公司还是有点收获的，虽然不多。 一串二进制中取中间三位二进制的最优代码？ 列举栈和队列在实际开发中的使用场景？ 本地数据持久化使用过吗？怎么做数据迁移？ 画出最近一个项目中登录的时序图？ 画出分页请求的时序图？ OC 原生支持多继承吗？有什么方案可以让 OC 支持多继承？ 原生和 JS 之间的交互遇到过哪些问题？ 使用 pageSize 字段处理分页重新刷新一下把原来的数据覆盖掉这个怎么处理？ 登录授权过期怎么处理？维护登录态？ 某社交/金融/在线教育创业公司收获很多，面试官很厉害。 说一下 OC 消息发送流程？基于这个流程可以做哪些事情？ frame 和 bounds 的区别？修改父视图 bounds 的 origin，对子视图有什么影响？ UIView 和 CAlayer 的区别？ 描述响应链条的过程？经过了哪些关键的方法？ 有 10 个下载请求，如何控制他们的先后顺序？有哪些方案？ GCD 的栅栏函数有了解吗？有什么作用？ 如何判断队列是否是主队列？ GCD 中的 targetQueue ？ GCD 定时器相比 NSTimer 定时器的优势？ GCD 的 source 用过哪些？ GCD 中信号量的使用有哪些？ 知道 iOS 中锁有哪几种吗？自旋锁是什么作用？ Swift 中 open 和 public 关键字的区别？ swift 中的操作符有哪些？map 和 flapMap 的区别？ KVC 如何存储结构体？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[男衣库 App_iOS 性能优化实践总结]]></title>
    <url>%2F2018%2F05%2F16%2F%E7%94%B7%E8%A1%A3%E5%BA%93%20App-iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言随着业务开发的不停迭代，如果没有很严格的执行代码开发规范、性能监控、测试覆盖等。容易引发一些 App 的性能问题，如崩溃率高、内存占用过高，安装包体积过大、启动时间过长，页面卡顿等一些性能问题，进而影响 App 的整体使用体验。 其中，主要优化的几个常见场景如下： 业务优化 未使用到的业务代码，以前旧版本的一些业务逻辑，没有及时删除。 内存优化 内存泄漏和大量数据加载导致收到系统内存警告 卡顿优化 监控页面实时滑动帧率 FPS 布局优化 大量的布局重复运算，没有适当的缓存设计 电量优化 一些硬件的操作、持续后台定位等 安装包体积优化 无用资源、如图片、文档等数据，无用的代码，图片未压缩处理 启动时间优化 大量的业务逻辑代码堆积在启动的时候执行 网络优化 网络安全 现状以下所有测试都是使用 iphone 6/iOS 8.3 版本测试真机在 release 环境下测试的。 crash App Store 统计数据，过去 90 天，主包的崩溃次数，89 次 具体崩溃详情 启动时间启动时间是用户点击 App 图标，到第一个界面展示的时间。 iOS App 的启动时间分为两个部分，一个是 main 函数执行之前的 preMain 时间，另一个是 main()函数 -&gt; 第一个页面渲染完成，用户看到界面的时间。 preMain 时间 main 函数之前总共使用了 730 ms; 在 307ms 中，加载动态库用了 307ms，指针重定位使用了 85 ms，ObjC 类初始化使用了 172 ms，各种初始化使用了 165 ms; 在初始化耗费的 165 ms 中，用时最多的初始化是 AFNetworking，用时 110 ms; main 函数 -&gt; 第一个页面渲染完成，用户看到界面的时间，这一个阶段通过在相关函数执行的地方打点计时可以测量出来： 这个阶段主要有第三方 SDK 的初始化，获取系统的配置，初始化页面tabbar，总共耗时 0.481s; 启动总耗时：0.73 s + 0.481 s = 1.211 s 内存 Xcode Analyze 静态分析工具分析可疑泄露点，有些真的存在，有些不存在，可以通过结合 Instruments 动态分析工具以及代码上下文排除解决 663 个隐藏泄露点，主要包含以下几个部分： 面向用户的文本应该使用本地化; 无效数据监测; 逻辑错误：访问空指针或未初始化的变量等； 内存管理错误：如内存泄漏等； 声明错误：从未使用过的变量； API 调用错误：未包含使用的库和框架; Xcode Instruments 动态分析工具中的 Leaks 和 Allocations 跟踪模板进行动态跟踪分析, 确认这些点是否真的泄漏, 或者是否有新的泄漏点出现 使用 Instruments 中 Time Profile 工具检测耗时严重的方法 页面刷新帧率 首页、买家秀列表页快速滑动的时候有轻微出现掉帧现象。 安装包体积 安装包构成 二进制代码文件 资源（图片、文档） 配置文件 工程中没有使用到的资源文件 编译后 arm64 架构各个类所占空间大小： 子线程 UI 操作在子线程中操作 UI 可能会引发一些未知的 bug，比如一些动画丢失问题，因此需要将所有有关 UI 的操作都放在主线程中进行，目前男衣库有一些页面的 UI 操作是在子线程中进行的，这些通过苹果iOS 9 系统上的 libMainThreadChecker.dylib 动态库都能检测出来。 目前男衣库 iOS App 中有多处存在子线程刷新 UI 的情况，分别在首页，个人中心都存在。 布局约束警告使用 Autolayout 进行页面布局，目前男衣库 App 存在多处约束警告，约束警告指对控件或者视图添加了重复或者多余的约束，不处理的话有可能引起页面显示错乱，多次重复布局等不必要的 CPU 操作等问题。 优化方案和目标过早的优化是万恶之源。优化要站在实际的需求角度出发，不能为了优化而优化，应该优化那些真正的性能瓶颈，体验落后，性价比最高、最值得优化的地方，同时又要站在整体的角度，做一些取舍和权衡，比如为了卡顿优化，往往需要缓存一些数据到内存中，从而会引起内存增长，如果内存中缓存的数据过多，内存就容易出现性能瓶颈，为了更好更快的监控一些数据，往往会集成一些第三方 SDK，这就又会导致安装包体积的增加。 具体应该通过检测到的性能数据指标来做具体优化，可以使用苹果自带的 instruments 工具来检测，找到突破点，优化一点，检测一下，观察性能数据的变化，如此反复。 第一步目标 首先解决 crash，将现有的线上崩溃都清理解决掉。 子线程 UI 操作，约束警告全部解决掉； 静态分析工具分析出来的可能泄露点的地方逐一排除修复； 第二步目标1. 启动时间 preMain 时间 preMain 时间在小于 400ms 是最佳的，因为从点击图标到显示启动图，再到启动图消失这段时间是 400ms。同时启动时间不可以大于 20s，否则会被系统杀掉。 这里面主要做了一些 iOS 系统动态库的链接、App 中 objc 类的加载。 针对这里的优化： 合并自己添加的动态库，减少动态库的数量，目前我们没有使用自己添加的动态库； 合并 Category 和功能类似的类，这个确实存在不少； 删除无用的方法和类； 用 initialize 方法替代 load，减少每个类的 load 方法的执行时间，经符号断点检测，也有一些类是这样的； main()函数 -&gt; 第一个页面渲染完成，用户看到界面的时间。这里可以做的优化有： 能延迟执行的就延迟执行。比如 SDK 的初始化，界面的创建，将页面请求加载数据、渲染等操作转移到viewWillAppear 方法中去； 不能延迟执行的，尽量放到后台执行，比如一些读取沙盒用户偏好缓存的数据操作； 3. 页面卡顿根据苹果官方说法，当 FPS 低于 45 的时候，用户就会察觉到到滑动有卡顿，男衣库 App 在这一块并不是很明显 日常开发时，做好 FPS 实时监控，在出现掉帧的页面，可做如下优化： 清除在主线程中进行的耗时操作 建立缓存机制，如缓存表格视图中 cell 的高度； 避免离屏渲染，尽量避免使用 layer 的 border、corner、shadow、mask 等属性，在后台线程预先绘制好对应内容； 4. 内存一般在占用系统内存超过 20% 的时候会有内存警告，而超过 50% 的时候，就很容易被系统 Crash。 iOS 中内存问题主要包含两个部分: 循环引用 Delegate：检查所有用到的代理对象属性是否是使用weak内存管理策略 NSTimer：使用 GCD 定时器代替 NSTimer，GCD 定时器的优点是时间误差小，不会发生循环引用； Block: 检查所有用到 Block 的地方，是否存在循环引用问题； NSNotificationCenter：检查 NSNotification addObserver 后是否有移除； 大量数据加载及使用导致的内存警告 处理每个单独页面以及整个 App 收到的内存警告，及时释放掉相关的资源； 5. 包体积 图片优化：使用 ImageOptim 图片压缩工具对工程中的图片做一次压缩处理； 清除无用的资源：使用 LSUnusedResources 工具，清除掉工程中未使用到的资源文件； 二进制文件优化：使用LinkMap 工具检测出每个类在最终的可执行文件中占据的大小，进行针对性的优化； 一些编译选项优化的开关开启； 其他 TestFight preRelease 测试，App 性能指标专项测试 多个包管理，Xcode 多 target 管理 git flow 工作流 自动化打包，CI 持续集成环境 参考资料iOS App 启动性能优化&amp;version=12020110&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=IDZVtt6EyfPD9ZLcACRVJZYH8WaaMPtT%2BF3nfv7yZUQBCMKM4H1rDCbevGd7bXoG)iOS-Performance-Optimization[iOS]一次立竿见影的启动时间优化实现60fps的网易云音乐首页]]></content>
      <categories>
        <category>iOS</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Developing iOS 11 Apps with Swift》学习笔记（四）]]></title>
    <url>%2F2018%2F02%2F09%2F%E3%80%8ADeveloping-iOS-11-Apps-with-Swift%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言这套课程是苹果官方推荐的入门 iOS 开发的学习课程。之前也听过，Paul 老爷子讲的非常好，这次准备重看一遍，顺便把 swift 和 iOS 相关的一些基础知识点复习一遍。文章会按照视频的次序写笔记，记录重点以及自己的理解。 课程地址 Demo 示例地址 参考资料一：官方文档参考资料二：官方文档中文翻译 这节课主要讲述了 Swift 中 protocols(协议) 和 Closures（闭包）、NSAttributedString 的语法和注意点。 mutating 关键字 在值类型中，如果方法需要改变值类型，那么就需要在方法声明中使用 mutating 关键字标识。 未使用 mutating 关键字 使用 mutating 关键字 protocols(协议)protocols(协议)是一组属性和没有实现的方法的集合，是一种用来表达 API 更加简洁的方式。使用 protocols(协议)，可以让调用者传递他们想要的任何Class类/struct结构体、enum枚举，但是通常调用者需要实现协议规定的方法和属性。 注意1：protocols(协议)中可以通过给方法使用 @objc 关键字标记，标识这个方法可以可选实现。其中使用 @objc 关键字是为了向后兼容backwards compatibility。注意2：任何有实现可选协议的 class类，都必须继承自 NSObject。这种可选协议常常用来实现 iOS 中的代理delegation。 protocols(协议) 语法#声明一个protocols(协议)123456protocol SomeProtocol : InheritedProtocol1, InheritedProtocol2 &#123; var someProperty: Int &#123; get set &#125; func aMethod(arg1: Double, anotherArgument: String) -&gt; SomeType mutating func changeIt() init(arg: Type)&#125; 注意1：如果要实现 SomeProtocol 协议，就必须实现 SomeProtocol 继承的父协议InheritedProtocol1 和 InheritedProtocol2。注意2：必须指定一个协议中的每个属性是只有 get，还是 get 和 set 都有。注意3：如果协议被结构体或者枚举实现，如果协议方法存在需要改变结构体或者枚举的，必须在协议方法前面使用 mutating 关键字标识。注意4：可以指定实现者实现协议指定的构造方法initializer。注意5：协议中的类型属性使用 static 关键字标识。注意6：协议中的方法方法参数不能使用默认值。 #指定协议只能被类实现，使用 AnyObject 关键字标识:123protocol SomeProtocol : AnyObject, InheritedProtocol1, InheritedProtocol2 &#123; &#125; #实现一个protocols(协议)&lt;!--类实现--&gt; class SomeClass : SuperclassOfSomeClass, SomeProtocol, AnotherProtocol { // implementation of SomeClass here // which must include all the properties and methods in SomeProtocol &amp; AnotherProtocol required init(...) } &lt;!--结构体实现--&gt; struct SomeStruct : SomeProtocol, AnotherProtocol { // implementation of SomeStruct here // which must include all the properties and methods in SomeProtocol &amp; AnotherProtocol } &lt;!--枚举实现--&gt; enum SomeEnum : SomeProtocol, AnotherProtocol { // implementation of SomeEnum here // which must include all the properties and methods in SomeProtocol &amp; AnotherProtocol } 注意1：必须实现协议以及他所有继承的父协议中的所有的属性和方法。并且任意数量的协议都可以被类，结构体，枚举实现。注意2：在类实现中，协议的初始化方法需要加上 required 关键字。否则子类可能不遵守。 protocols(协议) 应用场景1. 像 Type 一样使用 protocols(协议)123456789101112131415161718192021222324252627282930protocol Moveable &#123; mutating func move(to point: CGPoint)&#125;class Car : Moveable &#123; func move(to point: CGPoint) &#123; ... &#125; func changeOil()&#125;struct Shape : Moveable &#123; mutating func move(to point: CGPoint) &#123; ... &#125;func draw() &#125; let prius: Car = Car()let square: Shape = Shape() var thingToMove: Moveable = priusthingToMove.move(to: ...)thingToMove.changeOil()thingToMove = square let thingsToMove: [Moveable] = [prius, square]func slide(slider: Moveable) &#123; let positionToSlideTo = ... slider.move(to: positionToSlideTo)&#125; slide(prius)slide(square)func slipAndSlide(x: Slippery &amp; Moveable)slipAndSlide(prius) 2. 代理 Delegation一种典型的使用 Procotol 的场景是 MVC 模式中 View 和 Controller 的通信。步骤是： View 定义了代理协议； View 的 API 中包含了一个 weak 修饰的 delegation protocol 类型的 delegate property； View 使用 delegate 来获取/做一些 View 自己做不到的事情； Controller 声明遵守协议； Controller 设置 View 的 delegate 属性为自己； Controller 实现协议； 这里举了 UIScrollViewDelegate 的例子 12345678910111213141516// UIScrollViewweak var delegate: UIScrollViewDelegate?@objc protocol UIScrollViewDelegate &#123; optional func scrollViewDidScroll(scrollView: UIScrollView) optional func viewForZooming(in scrollView: UIScrollView) -&gt; UIView... and many more ...&#125;// Controllerclass MyViewController : UIViewController, UIScrollViewDelegate &#123; ... &#125;scrollView.delegate = self 3. 其他用法当做 Dictionary 的 keyDictionary 的 key 是遵循了 Hashable 协议的，而同时 Hashable 协议是继承自 Equatable 的。 123456789protocol Hashable: Equatable &#123; var hashValue: Int &#123; get &#125;&#125;// Equatableprotocol Equatable &#123; static func ==(lhs: Self, rhs: Self) -&gt; Bool&#125; 在 Demo 中，可以直接使用 Card 结构体当做 cards 字典的 key，只需要 Card 结构体遵循 Hashable 协议： 4. 高级使用多继承 CountableRange : 实现了很多协议 Sequence: 迭代器，for in 等 Collection：下标访问等 苹果创造了一种泛型代码（generic code），使得对于所有的 Collection 都能生效。 使用 extension 提供 prococol 的实现extension 能够被用来给 prococol 添加默认实现，例如 Sequences 协议，实际上只需要实现迭代器方法 next()，但是却免费获得了其他的如：contains()、forEach()、joined(separator:)、min()、max()，甚至是filter()、map()的实现，所有的这些都是通过对 prococol 的 extension 来实现的。 1234extension Sequence &#123; func contains(_ element: Element) -&gt; Bool &#123; &#125; // etc.&#125; Funtional ProgrammingSwift 语言中 value type、var、let、procotol、generic、extension 的设计，使得 Swift 语言也支持函数式编程范式。 通过将 procotol 和 generic 以及 extension 等特性组合在一起，Swift 代码可以更加聚焦于数据结构的行为上。 String 字符串#character character 是人类能够觉察到的 String 最小的组成单位字符，而其实 character 是由Unicodes 所组成的，因此即使是单个 character 字符，也有可能由多个 Unicodes 所组成。 Unicodes 能够代表地球上所有的字符。 Unicodes 包含有口音 Unicode，如：café 有可能是 4 个 Unicodes (c-a-f-é) 或者有可能是 5 个 Unicodes (c-a-f-e-’)。因此使用 Int 类型的 index 来标识字符串的索引会造成歧义，而使用 String.index 类型来专门表示字符串的索引index。 #String的一些方法12345678910let pizzaJoint = "café pesto"// 字符串起始索引let firstCharcterIndex = pizzaJoint.startIndex// 索引偏移let fourthCharcterIndex = pizzaJoint.index(firstCharcterIndex, offsetBy: 3)// 下标访问let fourthCharcter = pizzaJoint[fourthCharcterIndex] #String是 value type1234567891011121314151617var str = "Hello, playground"str.insert("d", at: str.startIndex)str.remove(at: str.startIndex)str.append("p")var str = "Hello, playground"str.insert("d", at: str.startIndex) // str.remove(at: str.startIndex)str.append("p")str.hasPrefix("Hello")str.hasSuffix(",")str.lowercased()str.uppercased() #demo 中将纸牌的emojis又数组结构改成字符串 NSAttributedStringNSAttributedString 是一个字符串中的每一个字符 character 都有一个相关联的属性字典，关联着character的字体，颜色等一些绘制到屏幕的时候将要生效的特性。 NSAttributedString 是来自于 Objective-C 中的 NSStirng 构造的 NSAttributedString 是引用类型，不是值类型，所以使用可变的时候需要使用 NSMutableAttributedString 对象 Closures 闭包闭包是一种 Function Type，可以当做一种数据类型一样使用，同时闭包是引用类型，可以捕获周围的变量到堆里去，供闭包使用，并随着闭包的生命周期结束。 1234567var operation: (Double) -&gt; Doubleoperation = &#123; -$0 &#125;let result = operation(4.0) // result will be -4.0// 捕获var ltuae = 42operation = &#123; ltuae * $0 &#125; // “captures” the ltuae var because it’s needed for this closure arrayOfOperations.append(operation) 应用场景#常常当做方法的参数 一些异步方法，完成时出现错误需要做些什么 让一个方法重复执行一个函数 #Array、Dictionary、String、Set 等遵循 Collection 协议的一些高阶函数，如：map、filter、reduce等1234let primes = [2.0, 3.0, 5.0, 7.0, 11.0]let negativePrimes = primes.map(&#123; -$0 &#125;) // [-2.0, -3.0, -5.0, -7.0, -11.0]let invertedPrimes = primes.map() &#123; 1.0/$0 &#125; // [0.5, 0.333, 0.2, etc.]let primeStrings = primes.map &#123; String($0) &#125; // [“2.0”,”3.0”,”5.0”,”7.0”,”11.0”] #初始化属性是懒加载123var someProperty: Type = &#123;// construct the value of someProperty here return &lt;the constructed value&gt;&#125;() #Demo 中应用 对 Collection 协议扩展，添加一个属性 然后修改为仅用一行代码：]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Developing iOS 11 Apps with Swift》学习笔记（三）]]></title>
    <url>%2F2018%2F02%2F09%2F%E3%80%8ADeveloping-iOS-11-Apps-with-Swift%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言这套课程是苹果官方推荐的入门 iOS 开发的学习课程。之前也听过，Paul 老爷子讲的非常好，这次准备重看一遍，顺便把 swift 和 iOS 相关的一些基础知识点复习一遍。文章会按照视频的次序写笔记，记录重点以及自己的理解。 课程地址Demo 示例地址 参考资料一：官方文档参考资料二：官方文档中文翻译 这一节课主要讲的是 Swift 的一些语法。如 Tuples(元组)、Computed Propertys (计算属性)、Access Control(访问控制)、Assertions(断言)、extensions(扩展)、enum(枚举）以及一些界面布局相关的 UIStackView 、 autolayout（自动布局）知识点。 索引UIStackViewRange（区间）Tuples（元组）Computed Properties（计算属性）Access Control（访问控制）Assertions(断言))Extensions（扩展）enum(枚举))Optionals(可选))Memory Management(内存管理)) UIStackViewUIStackView 是 iOS 9 推出的一项用于自动布局的技术。只要将需要布局的控件放入到 UIStackView 容器中，容器里面的控件的约束就不需要管理了，UIStackView 会自动管理。 设置 UIStackView 属性 Range（区间）Swift 中没有 C 语言的那种 for 循环。 1for(i = 0.5; i &lt;= 15.25; i += 0.3) 而 0.5...15.25 只是一个Range（区间），不是 CountableRange，不能直接用来循环。CountableRange是可以用来循环的区间，每隔多少单位循环一次。 在 Swift 中，有一个全局函数，可以用来创建一个 CountableRange 的循环区间。 12for i in stride(from:0.5, through:15.25, by:0.3) &#123;&#125; 注意1：在这里，through:表示的是一个闭区间，包括 15.25 这个数，如果将 through: 换成 to:，将表示是一个左闭右开区间，不包括最后的 15.25。注意2：CountableRange是个 generic Type(泛型)，不只适用于 Ints，同样适用于 String 等其他类型. Tuples（元组）Tuples（元组）是一种轻量级的数据类型，里面只有值，没有属性，也没有方法。可以在任何地方使用元组： 1234let x: (String, Int, Double) = (“hello”, 5, 0.85) // the type of x is “a tuple”let (word, number, value) = x // this names the tuple elements when accessing the tuple print(word) // prints helloprint(number) // prints 5print(value) // prints 0.85 元组中的元素在声明之后也能够通过变量名访问： 1234let x: (w: String, i: Int, v: Double) = (“hello”, 5, 0.85) print(x.w) // prints helloprint(x.i) // prints 5print(x.v) // prints 0.85let (wrd, num, val) = x // this is also legal (renames the tuple’s elements on access) Tuples（元组）非常适合在函数和方法中有多个返回值时使用： 12345func getSize() -&gt; (weight: Double, height: Double) &#123; return (250, 80) &#125;let x = getSize()print(“weight is \(x.weight)”) // weight is 250... or ...print(“height is \(getSize().height)”) // height is 80 Computed Properties（计算属性）在 Swift 中，属性可以分为存储属性（Stored property）和计算属性(Computed Properties)。 1234567891011&lt;!--存储属性--&gt; var foo: Double&lt;!--计算属性--&gt; var foo: Double &#123; get &#123; // return the calculated value of foo &#125; set(newValue) &#123; // do something based on the fact that foo has changed to newValue &#125; &#125; &#125; 注意：如果计算属性，只有实现了 get，而没有实现 set，那么该计算属性是只读的（read only）。 计算属性的作用 Access Control（访问控制） internal: 默认。表示可以仅在这个 App、或者框架framework 都能够访问。 private: 私有。表示仅在这个对象作用域内才能访问。 private(set): 私有set。表示这个属性在这个对象外部是只读的。 fileprivate: 文件私有。表示仅在这个源文件内都能够访问。 public: 框架framework专有。表示在框架外面也能够访问到。 open: 框架framework专有。框架外面不只能够访问，还能继承。 Assertions(断言)Assertions(断言) 是一个函数，可以用来在开发中保护 API，调试定位程序的 bug。 Extensions（扩展）在 Swift 语法中，可以为 Struct、Class、Enum 添加方法、属性，即使不知道 Struct、Class、Enum 的实现。 enum(枚举)enum(枚举) 是一种出 struct 和 class 外另一种常用的数据结构。enum(枚举) 和 struct 一样是值类型。 #用来分离不同状态。123456enum FastFoodMenuItem &#123; case hamburger case fries case drink case cookie &#125; #关联值（Associated Data）枚举的每一种状态都可以关联各自的值 1234567891011enum FastFoodMenuItem &#123; case hamburger(numberOfPatties: Int) case fries(size: FryOrderSize) case drink(String, ounces: Int) // the unnamed String is the brand, e.g. “Coke” case cookie &#125;enum FryOrderSize &#123; case large case small &#125; #给枚举设置值12let menuItem: FastFoodMenuItem = FastFoodMenuItem.hamburger(patties: 2) var otherItem: FastFoodMenuItem = FastFoodMenuItem.cookie 注意：如果枚举有关联值，必须同时设置关联值，这是唯一一次设置关联值得时刻。 #类型推断1234Swift can infer the type on one side of the assignment or the other (but not both) ...let menuItem = FastFoodMenuItem.hamburger(patties: 2)var otherItem: FastFoodMenuItem = .cookie错误 var yetAnotherItem = .cookie // Swift can’t figure this out #检测一个枚举的状态，使用 switch，switch 也可以类型推断，所以也可以不写类型1234567var menuItem = FastFoodMenuItem.hamburger(patties: 2)switch menuItem &#123; case FastFoodMenuItem.hamburger: print(“burger”) case FastFoodMenuItem.fries: print(“fries”) case FastFoodMenuItem.drink: print(“drink”) case FastFoodMenuItem.cookie: print(“cookie”)&#125; #使用 break 跳过其中的一个枚举状态1234567891011121314151617var menuItem = FastFoodMenuItem.hamburger(patties: 2)switch menuItem &#123; case .hamburger: break case .fries: print(“fries”) case .drink: print(“drink”) case .cookie: print(“cookie”)&#125;``` ### #使用 `default` 表示余下的所有状态```swiftvar menuItem = FastFoodMenuItem.cookieswitch menuItem &#123; case .hamburger: break case .fries: print(“fries”) default: print(“other”)&#125; 注意：必须列举完一个枚举的所有状态。 #switch 中一个 case 可以写多行代码，并且不会 fall through(贯穿)到下一个 case12345678910var menuItem = FastFoodMenuItem.fries(size: FryOrderSize.large)switch menuItem &#123; case .hamburger: print(“burger”) case .fries: print(“yummy”) print(“fries”)case .drink: print(“drink”) case .cookie: print(“cookie”)&#125; #可以使用 let 来访问枚举关联的关联值1234567var menuItem = FastFoodMenuItem.drink(“Coke”, ounces: 32)switch menuItem &#123; case .hamburger(let pattyCount): print(“a burger with \(pattyCount) patties!”) case .fries(let size): print(“a \(size) order of fries!”) case .drink(let brand, let ounces): print(“a \(ounces)oz \(brand)”) case .cookie: print(“a cookie!”)&#125; 注意：和元组一样。关联值变量，可以重命名，不需要和定义时的变量名称一样。 #方法、计算属性枚举和 struct 、class 一样，可以在内部定义方法和计算属性，不能定义存储属性，存储值可以使用关联值。123456789enum FastFoodMenuItem &#123; ... func isIncludedInSpecialOrder(number: Int) -&gt; Bool &#123; switch self &#123; case .hamburger(let pattyCount): return pattyCount == number case .fries, .cookie: return true // a drink and cookie in every special order case .drink(_, let ounces): return ounces == 16 // &amp; 16oz drink of any kind &#125; &#125; &#125; 一个 switch case 可以并列多个枚举状态，中间用,好隔开。 在枚举内部，可以使用 self 来检测枚举的状态123456789enum FastFoodMenuItem &#123; ... func isIncludedInSpecialOrder(number: Int) -&gt; Bool &#123; switch self &#123; case .hamburger(let pattyCount): return pattyCount == number case .fries, .cookie: return true // a drink and cookie in every special order case .drink(_, let ounces): return ounces == 16 // &amp; 16oz drink of any kind &#125; &#125; &#125; 可以使用 _ 忽略不关心的关联值。 在枚举内部，可以使用 mutating 关键字的方法来修改枚举的状态123456enum FastFoodMenuItem &#123; ... mutating func switchToBeingACookie() &#123; self = .cookie // this works even if self is a .hamburger, .fries or .drink &#125;&#125; 为什么要加 mutating 关键字？因为枚举是值类型，在传递的时候是写时复制，当值发生改变了，才会真正的复制，所以需要标识这个有改变枚举值的方法，就使用 mutating 关键字。struct 中有修改 到 struct 的方法也一样。 Optionals(可选)#Optionals(可选) 就是一种枚举。有两个状态，一种是没有设置值 none，一种有设置值 some()。1234enum Optional&lt;T&gt; &#123; // a generic type, like Array&lt;Element&gt; or Dictionary&lt;Key,Value&gt; case none case some(&lt;T&gt;) // the some case has associated data of type T &#125; #可选链使用 ？对多个可选值链式调用，当其中一个可选解包失败，整个表达式就会返回 nil。 Memory Management(内存管理)#ARC（自动引用计数） 引用类型的数据存储在堆（heap）里面。 每个引用类型，都有一个与之关联的引用计数，当引用计数为 0 是，系统就会回收。这些都是自动的。 #影响引用计数(使用一些关键字声明来影响一个引用类型的 ARC) strong: ARC 默认关键字，只有有一个 strong 类型的指针指向引用类型，该引用类型就不会被回收，就一直在内存堆（heap）里面。 weak: weak 关键字，对引用类型的 ARC 不发生作用。表示只要有一个其他的 strong 指针指向了该引用类型，该应用类型就 weak 指针变量访问，如果没有一个其他的 strong 指针指向了该引用类型，该引用类型就是从内存堆（heap）里面释放，同时将该 weak 指针变量指 nil。weak 关键字 只修饰可选的引用类型，最常用到 weak 关键字的地方一个是 Outlet，一个是 delegate。 unownd: 无主引用表示像 strong 一样指向引用类型，但是不影响引用计数。并且告诉系统，当该引用类型回收后，保证不再访问该引用类型。通常用在解决循环引用的问题上，在 闭包 中常用。]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Developing iOS 11 Apps with Swift》学习笔记（二）]]></title>
    <url>%2F2018%2F02%2F08%2F%E3%80%8ADeveloping-iOS-11-Apps-with-Swift%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言这套课程是苹果官方推荐的入门 iOS 开发的学习课程。之前也听过，Paul 老爷子讲的非常好，这次准备重看一遍，顺便把 swift 和 iOS 相关的一些基础知识点复习一遍。文章会按照视频的次序写笔记，记录重点以及自己的理解。 课程地址 Demo 示例地址 参考资料一：官方文档参考资料二：官方文档中文翻译 这一节课主要将的是 MVC 设计模式，以及优化上节课的翻纸牌游戏 demo，在优化 Demo 中讲解了 Swift 中的几个语法。Initialization(构造器)、struct（结构体）和 class（类）、static methods（静态方法）和 properties（属性）、optionals（可选）Dictionary&lt;KeyType,ValueType&gt;(字典)、UIStackView 、 autolayout（自动布局） 索引MVC 设计模式struct（结构体）和 class（类）static methods（静态方法）和 properties（属性）_ 忽略下标数组拼接元素lazy 懒加载并列表达式空合运算符 ?? MVC 设计模式 MVC 是苹果官方推荐的构建 App 的一种设计模式。它由三个角色组成。View、Controller、Model 组成。各个角色的分工如下： View：展示给用户的界面，例如用户看到的所有 UI 元素、按钮、标签、表格等等。 Controller：主管逻辑。控制 Model 层的数据怎样显示到 View 上。 Model：负责数据部分，和 UI 独立，View 视图显示的数据。 通信： View 和 Model 不能直接相互通信。 Controller 和 View Controller 持有 View，可以主动和 View 通信，但 View 不能直接和 Controller 通信。 View 上发生一些用户响应想要告诉 Controller 可以通过 action/target 的方式，将 Controller 和 view 进行绑定。除此之外，view 还可以通过 delegate（代理）的方式，让 Controller 成为自己的代理，实现代理的协议方法，View 将自己发生的一些变化告诉自己的代理。其中给 View 提供数据的 delegate（代理）叫做 DataSource. Controller 和 Model Controller 持有模型，可以直接主动和 Model 通信，获取 Model 的数据，但 Model 不能直接和 Controller 通信。Model 发生数据改变想要主动告诉 Controller，Controller 可以通过KVO 监听 Model 属性的方式。 MVCS： 单个页面可以是 MVC，一个 App 通常有多个页面，这些 MVC 组合成一起，就是 MVCS。 struct（结构体）和 class（类） 相同点： 都能定义变量和方法。 不同点： struct（结构体）没有继承。 struct（结构体）是值类型（Value Type），class（类）是引用类型（refrence Type）。Swift 中大部分的数据类型都是值类型，除了类和闭包。值类型的数据传递是通过复制进行的，但不是每次传递都会真正的复制，Swift 有一种智能的机制，只有当值真正被修改了才会被复制传递，这种机制叫做写时复制（copy on write）。引用类型是一种存储在堆（heap）里面，使用指针指向的数据类型，传递值时，是传递该值的引用指针，也即时传递的是值的地址。 static methods（静态方法）和 properties（属性）在结构体中可以定义static methods（静态方法） 和静态变量，用 static 关键字修饰,静态方法和静态变量只有结构体的类型才有的方法，不是实例拥有的，只有该结构体的类型才能调用。 _ 忽略下标 当遍历一个 sequence 的下标，不需要用到该下标值。 省略函数的外部参数（external parameter） 数组拼接元素直接通过+运算符就可以对数组进行拼接操作。 lazy 懒加载用时加载，没有使用到时不加载。 并列表达式可以将多个条件表达式并列在一起写，用 , 隔开，表示这几个表达式的逻辑值都要为真。 空合运算符 ??和三目运算符相似。?? 前面是一个可选类型的值，表示解包这个可选值，如果解包成功，就返回可选类型的值，如果解包失败就返回 ?? 后面的默认值。]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Developing iOS 11 Apps with Swift》学习笔记（一）]]></title>
    <url>%2F2018%2F02%2F08%2F%E3%80%8ADeveloping-iOS-11-Apps-with-Swift%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言这套课程是苹果官方推荐的入门 iOS 开发的学习课程。之前也听过，Paul 老爷子讲的非常好，这次准备重看一遍，顺便把 swift 和 iOS 相关的一些基础知识点复习一遍。文章会按照视频的次序写笔记，记录重点以及自己的理解。 课程地址 Demo 示例地址 参考资料一：官方文档参考资料二：官方文档中文翻译 第一节课主要是介绍了 iOS 开发的一些基本知识点，iOS 系统的框架层级，Swift 语言的基础知识以及一个翻卡片游戏的 demo。 索引iOS 框架层级iOS 开发平台组件翻纸牌游戏 demo iOS 框架层级分为四层，分别是 Core OS、Core Services、Media 以及 Cocoa Touch 层。其中最底层最接近硬件，最顶层最接近用户。 Core OS（系统核心层） 由于 iOS 是有 Unix 分出来的，所以这一层的大部分都是一些用 C 语言写的 UNIX 操作系统的接口，主要有系统内核、Mach 3.0、BSD、Sockets（套接字）、Security（安全）、Power Managerment（电量管理）、Keychain Access（钥匙串访问）、Certificates（证书）、File System（文件管理）、Bonjour。 Core Services（系统服务层） 这层是面向对象的，iOS 开发中经常用到的。主要封装有 Collections（集合类型）、Core Location(核心定位)、Address Book(地址簿)、Net Services(网络服务)、Networking(网络)、Theading (线程)、File Access(文件访问)、Preferences(偏好设置)、SQLite(数据库)、URL 实体等。 Media（媒体层） 这层主要封装有 Core Audio(核心音频) JPEG,PNG,TIFF(不同图片格式)、OpenAL、PDF（文档）、Audio Mixing(音频合成)、Quartz(2D)(绘图)、Audio Recording(录音)、Core Animation(核心动画)、Video Playback(视频播放)、OpenGL ES（图形渲染） Cocoa Touch（用户界面层） 最顶层是用户直接接触的，是 UI 用户界面层。所有的视图、view、控件、地图、本地化、相机相册、多点触控等都是在这一层，日常的界面开发就是在这一层。 iOS 开发平台组件 工具：Xocde（IDE）、Instrument(辅助调试、内存溢出什么的) 语言：Objective-C、Swift、C、C++ 框架：Foundation、UIKit 设计模式：MVC、MVP、MVVM 翻纸牌游戏 demo 字符串常量拼接变量 类型推断自动推断出变量的类型 计算属性监听属性的赋值操作 可选绑定给一个可选类型解包]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习笔记-理论入门（一）]]></title>
    <url>%2F2017%2F11%2F23%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%90%86%E8%AE%BA%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[人工智能/机器学习/神经网络/深度学习关系 人工智能为什么会崛起？##]]></content>
  </entry>
  <entry>
    <title><![CDATA[UIApplication && UIViewController && UIView 生命周期]]></title>
    <url>%2F2017%2F06%2F02%2FUIApplicationDelegate%20%26%20UIViewController%20%26%20UIView%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[UIApplicationDelegate几个角色： UIApplication 对象 处理用户与 iOS 设备交互时产生的事件（Multitouch Events，Motion Event，Remote Control Event）交由 UIApplication 对象来分发给 UIControl 对应的 target 对象来处理并且管理整个事件，而一些关于 App 运行时重要事件委托给 App delegate 来处理。 负责初始化并显示 UIWindow，并负责加载应用程序的第一个 UIView 到 UIWindow 窗体中。 帮助管理应用程序的生命周期，通过 UIApplicationDelegate 代理类来实现，UIApplication 对象接收这些生命周期事件，UIApplicationDelegate 决定如何响应这些事件(应用程序的生命周期事件（比如程序启动和关闭）、系统事件（比如来电、记事项警告）) App delegate 对象 遵循 UIApplicationDelegate 协议，响应 app 运行时重要事件（App 启动、App 内存不足、App 终止、切换到另一个 App、切回 App），主要用于在 App 启动时初始化一些重要的数据结构，如：初始化 UIWindow，设置一些属性，为 window 添加 rootViewController（self.window.rootViewController = [[XXXViewController alloc] init] 相当于 [self.window addSubview: [[XXXViewController alloc] init].view]）。 UIWidow 对象 UIWidow 对象位于 view 层次结构中的最顶层，充当一个基本容器但不显示内容的角色，如显示内容要添加一个 content view 到 window。 View、Control、Layer 对象 View：通过 addSubview 和 removeFromSuperView 等方法管理 view 的层次结构，使用 layoutSubviews、layoutIfNeeded 和 setNeedsLayout 等方法布局 view 的层次结构，通过重写 drawRect 方法或通过 layer 属性来构造更复杂的图形界面和动画，UIView 继承自 UIResponder，同样能够处理用户事件。 Control：通常是处理特定类型用户交互的 View，常用有 button、switch、textField 等。 Layer：Core Animation 框架的 Layer 对象，可以用来渲染 view 的界面和构建复杂的动画。 ViewController 对象 ViewController 有一个 view 属性是 view 层次结构中的根 view，可以添加子 view 来构建复杂的 view，ViewController 的一些 ViewDidLoad、ViewWillAppear、ViewDidAppear、ViewWillDisAppear、ViewDidDisAppear、LoadView 方法来管理 view 的生命周期，ViewController 还继承自 UIResponser，还可以响应和处理用户事件。 应用程序启动： 应用程序启动 -&gt; 执行 main 函数 -&gt; 执行 UIApplicationMain 函数 -&gt; 初始化 UIApplication 对象（创建和设置代理对象，开启主线程 ranloop）-&gt; 代理对象监听系统事件（程序加载完毕、程序获取焦点、程序进入后台、程序失去焦点、程序从后台回到前台、内存警告、程序即将退出）-&gt; 结束程序 应用程序的状态和多任务：应用程序有好几种状态，当按下 Home 键，锁屏、电话打来，切换 App 等中断情况时都会造成应用程序的状态发生改变。 Not running：App 还没运行 Inactive：App 运行在前台但没有接收事件 Active：App 运行在前台和正在接收事件 Running：App 运行在后台和正在执行代码 Suspended：App 运行在后台但没有执行代码 123456789101112131415161718192021222324252627282930313233343536373839// 这个方法是在程序启动时的第一次机会执行代码- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSLog(@"程序将要启动完成%s", __func__); return YES;&#125;// 这个方法允许在显示 app 给用户之前执行最后的初始化操作- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSLog(@"程序启动完成%s", __func__); return YES;&#125;// app 将要从前台切换到后台时需要执行的操作- (void)applicationWillResignActive:(UIApplication *)application &#123;&#123; NSLog(@"程序将要失去焦点%s", __func__);&#125;// app 已经进入后台后需要执行的操作- (void)applicationDidEnterBackground:(UIApplication *)application &#123;&#123; NSLog(@"程序已经进入后台%s", __func__);&#125;// app 将要从后台切换到前台需要执行的操作，但 app 还不是 active 状态- (void)applicationWillEnterForeground:(UIApplication *)application &#123; NSLog(@"程序即将进入前台%s", __func__);&#125;// app 已经切换到 active 状态后需要执行的操作- (void)applicationDidBecomeActive:(UIApplication *)application &#123; NSLog(@"程序已经获得焦点%s", __func__);&#125;// app将要结束时需要执行的操作， 可以做一些数据保存工作- (void)applicationWillTerminate:(UIApplication *)application &#123; NSLog(@"程序将要退出%s", __func__);&#125; App 启动和 active/inactive App 一启动，由 Not running 状态变成 Inactive 状态，调用 application didFinishLaunchingWithOptions 方法，然后由 Inactive 状态变成 Active 状态，调用 applicationDidBecomeActive 方法 当 App 由于一些原因（来电等系统事件）发生中断时，由 Active 状态变成 Inactive 状态，调用 `applicationWillResignActive` 方法。 ![](https://liangjinggege.com/5588d56cdc36a.gif) 来回切换App 当 App 切换到另一个 App 时，先由 Active 状态变成 Inactive 状态，调用 applicationWillResignActive 方法，然后再从 Inactive 状态变成 running 状态，调用 applicationDidEnterBackground 方法。 当切换回本 App 时，先由 running 状态变为 Inactive 状态，调用 applicationWillEnterForeground 方法，然后由 Inactive 状态变为 Active 状态，调用 applicationDidBecomeActive 方法。 锁屏 锁屏时，先由 Active 状态变成 Inactive 状态，调用 applicationWillResignActive 方法，然后由 Inactive 状态变为 Running 状态，调用 applicationDidEnterBackground 方法。 应用程序终止 当应用程序由于内存警告或长时间驻留后台等一些原因需要被操作系统终止时，系统还在应用程序终止前调用一次 applicationWillTerminate 方法，用来保存用户的一些重要数据以便于下次启动时恢复到 app 原来的状态。 UIViewControllerUIView 的加载 控制器 view 的加载时懒加载的，只用用到时才会去加载，首先调用的 loadView 方法， UIView 的卸载 1. 通过 XIB 加载通过 XIB 这种方式加载视图，需要调用 UIViewController 类的initWithNibName:bundle: 方法 12TestVC_XIB *vc = [[TestVC_XIB alloc] initWithNibName:@"TestVC_XIB" bundle:nil];[self.navigationController pushViewController:vc animated:YES]; 打印结果： 1234567892017-06-07 16:10:45.971 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12890:696585] -[TestVC_XIB initWithNibName:bundle:]2017-06-07 16:10:45.973 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12890:696585] -[TestVC_XIB loadView]2017-06-07 16:10:45.973 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12890:696585] -[TestVC_XIB viewDidLoad]2017-06-07 16:10:45.974 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12890:696585] -[TestVC_XIB viewWillAppear:]2017-06-07 16:10:45.978 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12890:696585] -[TestVC_XIB viewWillLayoutSubviews]2017-06-07 16:10:45.978 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12890:696585] -[TestVC_XIB viewDidLayoutSubviews]2017-06-07 16:10:45.979 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12890:696585] -[TestVC_XIB viewWillLayoutSubviews]2017-06-07 16:10:45.979 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12890:696585] -[TestVC_XIB viewDidLayoutSubviews]2017-06-07 16:10:46.551 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12890:696585] -[TestVC_XIB viewDidAppear:] 2. 通过 StoryBoard 加载通过这种方式创建 UIViewController 对象的话，首先生成 UIStoryboard 类型的对象，然后调用这个对象的instantiateViewControllerWithIdentifier:` 方法 123UIStoryboard *sb = [UIStoryboard storyboardWithName:@"TestVC_SB" bundle:nil]; TestVC_SB *sbVC = [sb instantiateViewControllerWithIdentifier:@"TestVC_SB"]; [self.navigationController pushViewController:sbVC animated:YES]; 打印结果： 123456789102017-06-07 16:13:40.326 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12957:699432] -[TestVC_SB initWithCoder:]2017-06-07 16:13:40.326 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12957:699432] -[TestVC_SB awakeFromNib]2017-06-07 16:13:40.328 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12957:699432] -[TestVC_SB loadView]2017-06-07 16:13:40.329 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12957:699432] -[TestVC_SB viewDidLoad]2017-06-07 16:13:40.329 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12957:699432] -[TestVC_SB viewWillAppear:]2017-06-07 16:13:40.334 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12957:699432] -[TestVC_SB viewWillLayoutSubviews]2017-06-07 16:13:40.335 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12957:699432] -[TestVC_SB viewDidLayoutSubviews]2017-06-07 16:13:40.335 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12957:699432] -[TestVC_SB viewWillLayoutSubviews]2017-06-07 16:13:40.335 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12957:699432] -[TestVC_SB viewDidLayoutSubviews]2017-06-07 16:13:40.894 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12957:699432] -[TestVC_SB viewDidAppear:] 3. 通过 NSCoding 协议加载4. 通过代码加载123456789102017-06-07 16:07:03.799 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12823:692994] -[TestVC_Code initWithNibName:bundle:]2017-06-07 16:07:03.800 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12823:692994] -[TestVC_Code init]2017-06-07 16:07:03.802 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12823:692994] -[TestVC_Code loadView]2017-06-07 16:07:03.803 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12823:692994] -[TestVC_Code viewDidLoad]2017-06-07 16:07:03.803 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12823:692994] -[TestVC_Code viewWillAppear:]2017-06-07 16:07:03.809 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12823:692994] -[TestVC_Code viewWillLayoutSubviews]2017-06-07 16:07:03.809 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12823:692994] -[TestVC_Code viewDidLayoutSubviews]2017-06-07 16:07:03.809 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12823:692994] -[TestVC_Code viewWillLayoutSubviews]2017-06-07 16:07:03.810 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12823:692994] -[TestVC_Code viewDidLayoutSubviews]2017-06-07 16:07:04.373 UIApplicationDelegate &amp; UIViewController &amp; UIView 生命周期[12823:692994] -[TestVC_Code viewDidAppear:] UIView1. 通过 Xib 加载2. 通过代码加载参考资料iOS UIApplicationDelegate与UIViewController生命周期UIView的生命周期总结深度解析iOS应用程序的生命周期UIViewController和UIView不同加载方式的生命周期函数iOS-控制器View的创建和生命周期UIView的生命周期]]></content>
      <categories>
        <category>iOS</category>
        <category>UIApplication</category>
        <category>UIViewController</category>
        <category>UIView</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线性表（数组和链表）]]></title>
    <url>%2F2017%2F05%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构#什么是数据结构？ 数据对象在计算机中的组织方式 逻辑结构 物理结构 数据对象必定与一些列加在其上的操作相关联 完成这些操作所用的方法就是算法 解决问题方法的效率跟数据的组织方式有关解决问题方法的效率跟空间的占用有关解决问题方法的效率和算法的巧妙运用有关#抽象数据类型（Abstract Data Type） 数据类型 数据对象集 数据集合相关联的操作类 抽象：描述数据类型的方法不依赖于具体实现 与存放数据的机器无关 与数据存储的物理结构无关 与实现操作的算法和编程语言无关 只描述数据对象集合相关操作集“是什么”，并不涉及“如何做到”的问题 #举例：“矩阵”的抽象数据类型定义 类型名称：矩阵（Matrix） 数据对象集：一个 M × N 的矩阵。由 M × N 个三元组(a, i, j)构成，其中 a 是矩阵元素的值，i 是元素所在的行号，j 是元素所在的列号。 操作集：对于任意 A、B、C ∈ Matrix，以及整数 i, j, m, n 返回一个 M × N 的矩阵：Matrix Creat(int M, int N); 返回矩阵的总行数：int GetMatrixRow(Matrix A); 返回矩阵 A 的第 i 行，第 j 列的元素：ElementType GetEntry(Matrix A, int i, int j); 矩阵相加，如果 A 和 B 行列数一致，返回 C = A + B，否则返回错误标志：Matrix Add(Matrix A, Matrix B); 矩阵相乘，如果 A 的列数等于 B 的行数，返回 C = AB，否则返回错误标志：Matrix Multiply(Matrix A, Matrix B); 算法#什么是好的算法？ 空间复杂度 S(n) 根据算法写成的程序在执行的时候占用存储单元的长度。这个长度往往与输入的数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。 时间复杂度 T(n) 根据算法写成的程勋在执行时耗费的时间的长度。这个往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致永远都等不到执行结果。 在分析一般算法的效率时，经常关注的是下面两种复杂度 - 最坏情况复杂度 T_worst(n) - 平均复杂度 T_avg(n) - T_avg(n) &lt;= T_worst(n) 复杂度的渐进表示法 T(n) = O(f(n)) 表示存在常数 C &gt; 0， n_0 &gt; 0 使得当 n &gt; n_0 时有 T(n) &lt;= C·f(n) T(n) = Ω(g(n)) 表示存在常数 C &gt; 0， n_0 &gt; 0 使得当 n &gt; n_0 时有 T(n) &gt;= C·g(n) T(n) = Θ(h(n)) 表示同时有 T(n) &lt;= C·f(n) 和 T(n) &gt;= C·g(n) 复杂度分析: 如果两段算法分别复杂度 T_1(n) = O(f_1(n)) 和 T_2(n) = O(f_2(n))， 则 T_1(n) + T_2(n) = max(O(f_1(n)), O(f_2(n))) T_1(n) × T_2(n) = O(f_1(n) × f_2(n)) 如果 T(n) 是关于 n 的 k 阶多项式，那么 T(n) = Θ(n^k) 一个 for 循环的时间复杂度等于循环次数乘以循环体代码的复杂度 if-else 结构的复杂度取决于 if 的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大 线性表线性表(Linear List)：由同类型数据元素构成有序序列的线性结构 表中元素的个数称为线性表的长度 线性表没有元素时，称为空表 表起始位置称为表头，表结束位置称为表尾 线性表的抽象数据类型描述 类型名称：线性表(List)数据对象集：线性表是 n(&gt;=0) 个元素构成的有序序列（a_1, a_2,…, a_n）操作集：线性表 L ∈ List，整数 i 表示位置，元素 X ∈ ElementType，线性表基本操作主要有： 初始化一个空的线性表：List MakeEmpty(); 根据位序 k,返回相应的元素：ElementType FindKth(int K, List L); 在线性表 L 中查找 X 元素第一次出现的位置：int Find(ElementType X, Lsit L); 在位序 i 处插入一个新元素 X：void Insert(ElementType X, int i, List L); 删除指定位序 i 的元素：void Delete(int i, List L); 返回线性表 L 的长度 n：int Length(List L); #1. 线性表的顺序存储实现 利用数组的连续存储空间顺序存放线性表的各元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 定义一个线性表结构体#define kListMaxSize 100typedef struct&#123; int data[kListMaxSize]; // 数组 int last; // 数组最后一个元素下标索引&#125;List;// 在末尾追加元素void add(List *PtrL, int X)&#123; // 如果是空表 if (PtrL-&gt;last &lt; 0) &#123; PtrL-&gt;data[0] = X; &#125; else &#123; // 不是空表，往表尾追加 PtrL-&gt;data[PtrL-&gt;last + 1] = X; &#125; // 更新最大下标 PtrL-&gt;last++;&#125;// 1. 初始化（建立空的线性表）List *MakeEmpty()&#123; List *PtrL; // 定义一个指针，指向线性表 PtrL = (List *)malloc(sizeof(List)); // 分配空间 PtrL-&gt;last = -1; // 初始化数组最大下标为 -1，即：空数组 printf("创建线性表成功！"); return PtrL;&#125;// 2. 根据位序 k,返回相应的元素int FindKth(int k, List *PtrL)&#123; // 保证下标不越界 if (0 &lt;= k &amp;&amp; k &lt;= PtrL-&gt;last) &#123; return PtrL-&gt;data[k]; &#125; else &#123; // 如果越界，就返回第一个元素 return PtrL-&gt;data[0]; &#125;&#125;// 3. 在线性表 L 中查找 X 元素第一次出现的位置int Find(List *PtrL, int X)&#123; int i = 0; while (i &lt;= PtrL-&gt;last &amp;&amp; PtrL-&gt;data[i] != X) &#123; i++; &#125; if (i &gt; PtrL-&gt;last) &#123; return -1; // 没找到，返回 -1 &#125; else &#123; return i; &#125;&#125;// 4. 在下标 i 出插入一个新元素 Xvoid Insert(int X, int i, List *PtrL)&#123; int j; if (PtrL-&gt;last == kListMaxSize) &#123; printf("表满了！"); return; &#125; if (i &lt; 0 || i &gt; PtrL-&gt;last) &#123; printf("位置不合法！"); return; &#125; for (j = PtrL-&gt;last; j &gt;= i; j--) &#123; // 先移动。把 i 后面的元素全部向后移动一位 PtrL-&gt;data[j + 1] = PtrL-&gt;data[j]; &#125; // 再插入 PtrL-&gt;data[i] = X; // 新的最大下标索引加一 PtrL-&gt;last++;&#125;// 5. 删除指定下标 i 的元素void delete(int i, List *PtrL)&#123; int j; if (i &lt; 0 || i &gt; PtrL-&gt;last) &#123; printf("不存在%d元素",i); return; &#125; for (j = i + 1; j &lt;= PtrL-&gt;last; j ++) &#123; // 将 i 后面的所有元素都向前移动一位 PtrL-&gt;data[j - 1] = PtrL-&gt;data[j]; &#125; // 新的最大下标索引减一 PtrL-&gt;last--;&#125;// 6. 返回线性表 L 的长度 nint Length(List *PtrL)&#123; return PtrL-&gt;last + 1;&#125; 测试： 1234567891011121314151617181920212223242526272829303132333435363738// 1. 初始化线性表List *PtrL = MakeEmpty(); // 2. 追加元素add(PtrL, 10);add(PtrL, 20);add(PtrL, 5);add(PtrL, 30); for (int i = 0; i &lt; PtrL-&gt;last + 1; i++)&#123; printf("\n%d", PtrL-&gt;data[i]);&#125;// 3. 查找指定位置的元素printf("\n第3位置的元素是%d\n", FindKth(3, PtrL));// 4. 查找指定元素的位置printf("\n%d元素在第%d位置\n", 5, Find(PtrL, 5)); // 5. 插入Insert(100, 2, PtrL);for (int i = 0; i &lt; PtrL-&gt;last + 1; i++)&#123; printf("\n插入后：%d", PtrL-&gt;data[i]);&#125; printf("\n%d元素在第%d位置\n", 100, Find(PtrL, 100)); // 6. 删除delete(2, PtrL);for (int i = 0; i &lt; PtrL-&gt;last + 1; i++)&#123; printf("\n删除后：%d", PtrL-&gt;data[i]);&#125; // 7. 表长度printf("\n表元素个数为：%d", Length(PtrL));printf("\n"); 打印： 12345678910111213141516171819202122创建线性表成功！1020530第3位置的元素是305元素在第2位置插入后：10插入后：20插入后：100插入后：5插入后：30100元素在第2位置删除后：10删除后：20删除后：5删除后：30表元素个数为：4Program ended with exit code: 0 #2. 线性表的链式存储实现 不要求逻辑上相邻的两个元素在物理上也相邻，通过 链 建立起数据元素之间的逻辑关系。插入和删除不需要移动数据元素，只需要修改 链. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136typedef struct Node &#123; int Data; // 数据域 struct Node *Next; // 指针域，指向下一个节点&#125;List;// 1. 求表长int Length(List *PtrL)&#123; List *p = PtrL; // p 指向表的第一个元素地址 int j = 0; // 用来记录表元素的个数 // 循环终止条件：P 为 null 了 while (p) &#123; p = p-&gt;Next; j++; &#125; return j;&#125;// 2. 查找(按序号查找)List * FindKth(int K, List *PtrL)&#123; List *p = PtrL; int i = 1; while (p != NULL &amp;&amp; i &lt; K) &#123; p = p-&gt;Next; i++; &#125; if (i == K) &#123; return p; // 找到第 K 个，返回指针 &#125; else &#123; return NULL; // 没找到，返回 NULL &#125;&#125;// 2. 查找(按值查找)List * Find(int X, List *PtrL)&#123; List *p = PtrL; // 循环终止条件：p = NULL，或者 p-&gt;Data = X while (p != NULL &amp;&amp; p-&gt;Data != X) &#123; p = p-&gt;Next; &#125; return p;&#125;// 3. 插入元素(在第 i-1(i &lt;= i &lt;= n +1) 个节点后插入一个值为 X 的新节点)// 先构造一个新节点，用 s 指向// 再找到第 i-1 个节点，用 p 指向// 然后修改指针，插入节点（p 之后插入新节点是 s）List * Insert(int X, int i, List *Ptrl)&#123; List *p, *s; // 如果插入的是表头 if (i == 1) &#123; s = (List *)malloc(sizeof(List)); s-&gt;Data = X; s-&gt;Next = Ptrl; return s; &#125; p = FindKth(i - 1, Ptrl); if (p == NULL) &#123; printf("参数 i 错误！"); return NULL; &#125; else &#123; // 把新节点插入到第 i-1 个节点的后面 s = (List *)malloc(sizeof(List)); s-&gt;Data = X; s-&gt;Next = p-&gt;Next; p-&gt;Next = s; return Ptrl; &#125;&#125;// 4. 删除元素(删除链表第 i (1 &lt;= i &lt;= n) 个位置的节点)// 先找到链表第 i-1 个节点，用 p 指向// 在用指针 s 指向要删除的节点（p 的下一各节点）// 然后修改指针，删除 s 所指的节点// 最后释放 s 所指节点的空间List * Delete(int i, List *PtrL)&#123; List *p, *s; // 如果删除的是表头节点 if (i == 1) &#123; s = PtrL; // s 指向第一个节点 if (PtrL != NULL) &#123; PtrL = PtrL-&gt;Next; // 从链表中删除 free(s); return PtrL; &#125; else &#123; return NULL; &#125; &#125; p = FindKth(i - 1, PtrL); // 查找第 i -1 个节点 if (p == NULL) &#123; printf("第%d个节点不存在", i -1); return NULL; &#125; else if (p-&gt;Next == NULL) &#123; printf("第%d个节点不存在", i); return NULL; &#125; else &#123; s = p-&gt;Next; // s 指向第 i 个节点 p-&gt;Next = s-&gt;Next; // 从聊表中删除第 i 个节点 free(s); // 释放被删除的节点 return PtrL; // 返回新的链表 &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1. 创建表List *L; // 2. 插入元素printf("开始插入元素\n");L = Insert(10, 1, L);L = Insert(20, 2, L);L = Insert(5, 3, L);L = Insert(30, 4, L);printf("结束插入元素\n"); // 3. 求表长度int length = Length(L);printf("表的长度 = %d\n", length); for (int i = 1; i &lt;= length; i++)&#123; // 4. 按序号查找节点 List *findL = FindKth(i, L); printf("第 %d 位的元素 = %d\n", i, findL-&gt;Data);&#125; // 4. 按元素值查找节点List *xL = Find(5, L);printf("元素为 5 的节点的元素值 = %d\n", xL-&gt;Data);// 5. 删除节点printf("删除节点\n");L = Delete(1, L);length = Length(L);for (int i = 1; i &lt;= length; i++)&#123; // 按序号查找节点 List *findL = FindKth(i, L); printf("删除后：第 %d 位的元素 = %d\n", i, findL-&gt;Data);&#125;printf("删除节点\n");L = Delete(2, L);length = Length(L);for (int i = 1; i &lt;= length; i++)&#123; // 按序号查找节点 List *findL = FindKth(i, L); printf("删除后：第 %d 位的元素 = %d\n", i, findL-&gt;Data);&#125; 打印： 12345678910111213表的长度 = 4第 1 位的元素 = 10第 2 位的元素 = 20第 3 位的元素 = 5第 4 位的元素 = 30元素为 5 的节点的元素值 = 5删除节点删除后：第 1 位的元素 = 20删除后：第 2 位的元素 = 5删除后：第 3 位的元素 = 30删除节点删除后：第 1 位的元素 = 20删除后：第 2 位的元素 = 30 源代码代码地址]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 网络编程-Socket 通信]]></title>
    <url>%2F2017%2F05%2F18%2FiOS-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Socket-%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[通信三个要素 IP 地址（主机名） 网络中设备的标识 可以用主机名 本地主机地址：127.0.0.1 主机名：localhost 端口号（port） 用于标识应用程序的逻辑地址，不同进程的标识 有效端口号 0~65535 其中 0~1024 为系统使用或者保留端口，开发中不要使用，使用 1024 以下的端口 传输协议 TCP UDP 一些常见协议 HTTP：超文本传输协议，端口：80 HTTPS：HTTP + SSL，HTTP 的安全版，端口：443 FTP：文件传输协议，端口：20，21，990 POP3：邮局协议，端口：110 SMIP：简单邮件传输协议，端口：25 telnet：远程终端协议，端口：23 网络通信模型 OSI 七层网络模型 应用层 ：HTTP 协议 表示层 会话层 传输层 ：socket（TCP/UDP） 网络层 ：IP 协议 路由器（网络传输路径） 数据链路层 ：交换机\网卡 将数据打包成数据帧格式，从什么时间段到什么时间段的数据。 物理层 ：网线（将二进制数据转换为电信号） HTTP 协议对应于应用层，TCP 协议对应于传输层，IP 协议对应于网络层，HTTP 协议是基于 TCP 连接的，三者本质上没有可比性。 TCP/IP 是传输层协议，主要解决数据如何在网络中传输；而 HTTP 是应用层协议，主要解决如何包装数据。Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，是它的一组接口。 UDP 和 TCP UPD（用户数据报协议） 只管发送，不确认对方是否收到 将数据及源和目的封装成数据包，不需要简历连接 每个数据包的大小限制在 64k 之内 因为无需连接，所以是不可靠 不需要建立连接，速度快 应用场景：网络视频播放、聊天、游戏 TCP（传输控制协议） 建立连接，形成传输数据的通道 在连接中进行大数据传输（数据大小不受限制） 通过三次握手完成连接，是可靠协议，安全送达 必须建立连接，效率会稍低 TCP 连接三次握手 建立起一个TCP连接需要经过“三次握手”： 第一次握手：客户端发送 syn 包(syn=j) 到服务器，并进入 SYN_SEND 状态，等待服务器确认； 第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态； 第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。 三次握手(Three-way Handshake)即建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时,将触发三次握手。 TCP 断开连接四次握手 TCP 连接的拆除需要发送四个包，因此称为四次握手(four-way handshake)。在 socket 编程中，任何一方执行 close() 操作即可产生握手（有地方称为“挥手”）操作。 SocketSocket：套接字层、插座 Socket 是为网络服务提供的一种机制 在 Unix 中，网络即是 Socket，并不局限在 TCP/UDP Socket 可以用于自定义协议 通信的两端都是 Socket 网络通信其实就是 Socket 间的通信 数据在两个 Socket 间通过 IO 传输 Socket 是纯 C 语言的，跨平台 Socket 通信示意图 Socket 库函数 导入系统库 &lt;sys/socket.h&gt;、 &lt;netinet/in.h&gt;、&lt;arpa/inet.h&gt; 创建 socket 建立连接 发送数据 读取数据 关闭连接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 1. 创建socket// 参数一 domin：协议域，AF_INET -&gt; ipv4// 参数二 Socket 类型： SOCK_STREAM(TCP)/SOCK_DGRAM(报文UDP)// 参数三 protocol 通信协议：IPPROTO_TCP ,填 0，表示自动选择，根据 Socket 类型// 返回值：一个 socketself.clientSocket = socket(AF_INET, SOCK_STREAM, 0);NSLog(@"%d", self.clientSocket); // 2. 建立连接// 参数一：客户端 socket// 参数二：指向结构体 sockaddr 的指针，包括目的 IP 地址和端口// 参数三：结构体数据长度// int 类型， 0：成功；其他：错误代码 // 服务器地址struct sockaddr_in severAddr;// 端口号severAddr.sin_port = htons(port); // 20480，高位地位互换// IP 地址：inet_addr：将 IP 地址转成一个数字severAddr.sin_addr.s_addr = inet_addr(address.UTF8String);/* struct sockaddr_in &#123; __uint8_t sin_len; sa_family_t sin_family; // IPV4 还是 IPV6 in_port_t sin_port; // 端口号 struct in_addr sin_addr; // IP 地址 char sin_zero[8]; &#125;; */// $ nc -lk 12345 监听本地计算机 12345 端口// Netcat: 终端下用于调试和检查网络的工具包，可以用于创建 TCP/IP 连接int connectResult = connect(self.clientSocket, (const struct sockaddr *)&amp;severAddr, sizeof(severAddr));if (0 == connectResult)&#123; NSLog(@"连接成功！");&#125;else&#123; NSLog(@"连接失败 %d", connectResult);&#125;// 3. 发送数据// 参数一：客户端socket// 参数二：发送内容地址(指针）// 参数三：发送内容长度// 参数四：发送方式标志// 返回值：成功：返回发送的字节数，失败：返回 SOCKET_ERROR// const char *sentMessage = "GET / HTTP/1.1\n""Host:www.sinaX.com\n\n";const char *sendMsg = msg.UTF8String;ssize_t sendLen = send(self.clientSocket, sendMsg, strlen(sendMsg), 0);NSLog(@"发送了 %ld 个字节", sendLen);// 4. 读取数据// 参数一：客户端socket// 参数二：接收内容缓冲区地址// 参数三：接受内容缓冲区长度// 参数四：接收方式，0：阻塞，必须等待服务器返回数据// 返回值：成功：返回读入的字节数，失败：返回 SOCKET_ERRORuint8_t buffer[1024]; // 空间，准备装二进制数据ssize_t recvLen = recv(self.clientSocket, buffer, sizeof(buffer), 0);NSLog(@"接收了 %ld 个字节", recvLen); // 获取到服务器数据NSData *data = [NSData dataWithBytes:buffer length:recvLen];NSString *recvString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];NSLog(@"recvString = %@", recvString);// 5. 关闭连接// 长连接：建立一个连接，不断开// 短连接：连接完毕就断开close(self.clientSocket);NSLog(@"关闭连接");]]></content>
      <categories>
        <category>iOS</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>网络编程</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC & KVO 学习]]></title>
    <url>%2F2017%2F05%2F11%2FKVC-KVO-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[KVCKVC：Key-value coding）键值编码。通过 key 值，来获取对象的属性，而不是通过明确地存取方法来获取。（通过一系列的方法和规则） 苹果系统通过给 NSObject 类添加一个 NSKeyValueCoding 分类来实现了 KVC，所以对于所有继承了 NSObject 的类都能使用 KVC，KVC 的使用主要是下面四个方法： 123456789// 通过 key 来取值- (nullable id)valueForKey:(NSString *)key;// 通过 key 来设置- (void)setValue:(nullable id)value forKey:(NSString *)key;// 通过 keyPath 来取值- (nullable id)valueForKeyPath:(NSString *)keyPath;// 通过 keyPath 来设置- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; 其他的一些方法：1234567891011121314151617181920// 默认返回 YES，表示如果没有找到 Set&lt;Key&gt; 方法的话，会按照 _key，_iskey，key，iskey 的顺序搜索成员变量，设置成 NO 就不这样搜索+ (BOOL)accessInstanceVariablesDirectly;// KVC 提供属性值确认的 API，它可以用来检查 set 的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;// 这是集合操作的 API，里面还有一系列这样的 API，如果属性是一个 NSMutableArray，那么可以用这个方法来返回- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;// 如果 Key 不存在，且没有 KVC 无法搜索到任何和 Key 有关的字段或者属性，则会调用这个方法，默认是抛出异常- (nullable id)valueForUndefinedKey:(NSString *)key;// 和上一个方法一样，只不过是设值- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;// 如果在 SetValue 方法时面给 Value 传 nil，则会调用这个方法- (void)setNilValueForKey:(NSString *)key;// 输入一组 key,返回该组 key 对应的 Value，再转成字典返回，用于将 Model 转到字典。- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys; valueForKey: 第一，判断是否有无 getter 方法，如果有，依次按照（NSString 类型查找方式）找 getKey&gt; -&gt; key -&gt; isKey 的 getter 方法查找（属性也是通过存取方法来查找的，属性在编译时默认生成了 getter 方法和 setter 方法的代码）。其中，如果是 BOOL 或者 int 等值类型， 会做 NSNumber 类型转换。 第二，如果没有找到，继续按照数组类型规则查找方式，查找 countOf、objectInAtindex、AtIndexes 格式的方法。如果 countOf 和另外两个方法中的一个找到，那么就会返回一个可以响应 NSArray 所有方法的代理集合的 NSArray 消息方法。 123456789101112131415161718192021222324252627282930313233343536// countOf&lt;Key&gt; 方法- (NSUInteger)countOfName&#123; return 2;&#125;//// objectIn&lt;Key&gt;AtIndex 方法//- (id)objectInNameAtIndex:(NSUInteger)index//&#123;// if (0 == index)// &#123;// return @"zhangsan";// &#125;// else// &#123;// return @"lisi";// &#125;//&#125;// &lt;Key&gt;AtIndexes 方法- (NSArray *)nameAtIndexes:(NSIndexSet *)indexes&#123; NSMutableArray *array = [NSMutableArray array]; [indexes enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL * _Nonnull stop) &#123; if (idx == 0) &#123; [array addObject:@"zhangsan"]; &#125; else &#123; [array addObject:@"chenliangjing"]; &#125; &#125;]; return array;&#125; 打印结果： 第三，还没找到，继续按照集合类型规则查找方式，查找 countOf、enumeratorOf、memberOf 格式的方法。如果这三个方法都找到，那么就返回一个可以响应 NSSet 所有方法的代理集合。 第四，判断是否实现了 + (BOOL)accessInstanceVariablesDirectly 这个方法，这个方法默认是 YES，如果返回 YES，那么就按照 _key -&gt; _isKey -&gt; key -&gt; isKey 的顺序查找对应实例变量的值并返回，如果该方法返回 NO，那么继续往下一个规则查找。 第五，如果以上都没有找到对应的 key，那么会调用 - (id)valueForUndefinedKey:(NSString *)key 方法，做异常处理. 第六，如果没有实现第四步中的方法，那么应用程序会崩溃。 setValue:forKey: 第一，查找 setter 方法，判断有无相应的 - (void)set&lt;key&gt;:(NSString *)&lt;key&gt; setter 方法，如果有，则通过 setter 方法来设置值。（属性也是通过 setter 默认生成的 setter 方法来设置值的）。其中 - (void)set&lt;key&gt;:(NSString *)&lt;key&gt; 优先级大于 - (void)set&lt;isKey&gt;:(NSString *)&lt;iskey&gt;。 第二，如果没有找到相应的 setter 方法，那么再判断 + (BOOL)accessInstanceVariablesDirectly 是否实现，默认返回 YES，如果返回 YES，那么去查找实例变量，依次按照 _key -&gt; _isKey -&gt; key -&gt; isKey 的顺序查找设置值。如果返回 NO 或者实例对应的实例变量没有找到，那么继续走下一个步骤。 第三，如果以上步骤都没有设置值成功，那么会调用 - (void)setValue:(id)value forUndefinedKey:(NSString *)key 方法，进行异常处理， 第四，如果没有实现第三步中的方法，那么应用程序将会崩溃. setValue:forKeyPath:通过 keyPath 路径搜索值，当成员属性是自定义类型时，可以通过搜索 keyPath 路径的方法去查找自定义的成员属性的成员属性。 搜索机制：用过小数点来分离 key，然后再按照 KVC 搜索 key 方式的机制按顺序搜索下去。 123456789101112131415161718192021222324252627282930_p = [Person new]; // 1. 人的名字id name = [_p valueForKeyPath:@"name"]; // 2. 狗的生日，包括年月日id dogBirthday = [_p valueForKeyPath:@"dog.birthday"];NSValue *value = (NSValue *)dogBirthday; // 从 value 中取出结构体变量DogBirthday birthday;[value getValue:&amp;birthday]; // 3. 狗的身高id dogHeight = [_p valueForKeyPath:@"dog.height"]; // 4. 狗要吃的食物名称id dogFoodName = [_p valueForKeyPath:@"dog.food.foodName"]; // 打印人名/数据类型NSLog(@"name = %@ %@", name, [name class]); // name = chenliangjing __NSCFConstantString // 打印狗的生日/数据类型NSLog(@"dogBirthday = %@ %@", dogBirthday, [dogBirthday class]); // dogBirthday = &lt;e1070000 00000000 05000000 00000000 0f000000 00000000&gt; NSConcreteValue// 打印狗的生日(年、月、日)NSLog(@"year = %lu mouth = %lu day = %lu", birthday.year, birthday.mouth, birthday.day); // year = 2017 mouth = 5 day = 15// 打印狗的身高/数据类型NSLog(@"dogHeight = %@ %@", dogHeight, [dogHeight class]); // dogHeight = 1.3 __NSCFNumber// 打印狗的事物名称/数据类型NSLog(@"dogFoodName = %@ %@", dogFoodName, [dogFoodName class]); // dogFoodName = 狗粮 __NSCFConstantString 对于结构体类型的属性，KVC 会包装成 NSValue 类型的。如果需要转为结构体，需要用到 NSValue 的对象方法 getValue:。 对于其他非 OC 对象类型，如：CGFloat/int/BOOL/double 等，KVC 会将这些类型转化为 NSNumber。 keyPath 通过 key.key.key...这样的形式，可以读写更深层次的属性。 KVC 对集合类型的操作集合运算符（Collection Operators）是一个特殊的 Key Path，可以作为参数传递给 valueForKeyPath：方法。 运算符是一个以@开头的特殊字符串，格式如下图所示： 集合操作符分为三种： 简单的集合操作: 返回 NSString(可以使用 @count，@max，@min，@sum 四种)、NSNumber（全部可以使用）、NSDate（可以使用 @count，@max，@min 三种）. 简单集合运算符共有 @avg，@count，@max，@min，@sum 5 种。除了 @count，其他都需要有右边的 keyPath(一般为属性名)。 #如果数组或者集合的元素由 NSNumber 类型组成，可以使用 `@keyPath.self `的方式来操作集合 #如果数组或者集合的元素由对象类型组成 对象操作符返回: NSArray. @distinctUnionOfObjects: 返回一个由操作符右边的 key path 所指定的对象属性组成的数组，不对数组去重 @unionOfObjects: 返回一个由操作符右边的 key path 所指定的对象属性组成的数组，并对数组去重 数组或集合操作符: 返回 NSArray、NSSet. @distinctUnionOfArrays 和 @unionOfArrays: 返回 NSArray，distinct 版本会对数组取重。 @distinctUnionOfSets: 返回一个 NSSet 对象，因为 Sets 中的元素本身就是唯一的，所以没有对应的 @unionOfSets 运算符。 键值验证（Key-Value Validation）KVC 提供了属性值，用来验证 key/keyPath 对应的 Value 是否可用的方法。 123- (BOOL)validateValue:(inout id _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError * _Nullable __autoreleasing *)outError;- (BOOL)validateValue:(inout id _Nullable __autoreleasing *)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError * _Nullable __autoreleasing *)outError; 重写方法： 123456789101112- (BOOL)validateValue:(inout id _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError * _Nullable __autoreleasing *)outError&#123; NSString *value = *ioValue; if ([inKey isEqualToString:@"name"] &amp;&amp; [value isEqualToString:@"chenliangjing"]) &#123; return NO; &#125; else &#123; return YES; &#125;&#125; KVC 异常处理如果不小心使用了错误的 Key，或者在设值中不小心传递了 nil 的，就要进行异常处理，保证程序运行的稳定。 如果给一个非对象属性设置了一个 nil 值，会调用 setNilValueForKey: 这个方法，只需要重写这个方法即可 KVC 和字典 KVC 实现原理实现代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226// .h 声明#import &lt;Foundation/Foundation.h&gt;@interface NSObject (KVCImplecation)// 设置值- (void)clj_setValue:(id)value forKey:(NSString *)key;// 取值- (id)clj_valueForKey:(NSString *)key;// 是否从成员变量获取+ (BOOL)clj_accessInstanceVariablesDirectly;// 设置值异常处理：找不到key- (void)clj_setValue:(id)value forUndefinedKey:(NSString *)key;// 取值异常处理：找不到key- (id)clj_valueForUndefinedKey:(NSString *)key;// 处理value 为 nil 的情况- (void)clj_setNilValueForKey:(NSString *)key;@end// .m 实现#import "NSObject+KVCImplecation.h"#import &lt;objc/runtime.h&gt;@implementation NSObject (KVCImplecation)- (void)clj_setValue:(id)value forKey:(NSString *)key&#123; // 1. 判断 key 是否异常 if (key == nil || key.length == 0) &#123; return; &#125; // 2. 对非对象类型判断 value 是否为 nil if ([value isKindOfClass:[NSNull class]]) &#123; [self clj_setNilValueForKey:key]; // return; &#125; // 3. 判断是否为对象类型 if (![value isKindOfClass:[NSObject class]]) &#123; // @throw @"must be NSObject Type"; return; &#125; // 4. 判断是否实现了 setter (set&lt;Key&gt; -&gt; setIs&lt;key&gt;)方法，如果有 setter 方法，那么直接执行 setter 方法 NSString *funcName1 = [NSString stringWithFormat:@"set%@", key.capitalizedString]; SEL sel1 = NSSelectorFromString(funcName1); if ([self respondsToSelector:sel1]) &#123; [self performSelector:sel1 withObject:value]; return; &#125; NSString *funcName2 = [NSString stringWithFormat:@"setIs%@", key.capitalizedString]; SEL sel2 = NSSelectorFromString(funcName2); if ([self respondsToSelector:sel2]) &#123; [self performSelector:sel2 withObject:value]; return; &#125; // 5. 判断是否允许访问成员变量 if ([[self class] clj_accessInstanceVariablesDirectly]) &#123; // 访问成员变量（_key -&gt; _isKey -&gt; key -&gt; isKey） unsigned int count; Ivar* ivars = class_copyIvarList([self class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; Ivar ivar = ivars[i]; NSString *ivarName = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding]; NSString *keyName = ivarName; BOOL findKeySuccessed = NO; // 5.1 先找 _key 成员变量 if ([keyName isEqualToString:[NSString stringWithFormat:@"_%@", key]]) &#123; // 给成员变量设置值 object_setIvar(self, ivar, value); findKeySuccessed = YES; break; &#125; // 5.2. 找 _isKey 成员变量 if ([keyName isEqualToString:[NSString stringWithFormat:@"_is%@", key.capitalizedString]]) &#123; object_setIvar(self, ivar, value); findKeySuccessed = YES; break; &#125; // 5.3 找 key 的成员变量 if ([keyName isEqualToString:key]) &#123; object_setIvar(self, ivar, value); findKeySuccessed = YES; break; &#125; // 5.4. 找 isKey 成员变量 if ([keyName isEqualToString:[NSString stringWithFormat:@"is%@", key.capitalizedString]]) &#123; NSLog(@"isKey = %@", [NSString stringWithFormat:@"is%@", key.capitalizedString]); findKeySuccessed = YES; break; &#125; // 5.5. 如果还是没有找到相关的成员变量 if (!findKeySuccessed) &#123; [self clj_setValue:value forUndefinedKey:key]; &#125; &#125; &#125; else &#123; [self clj_setValue:value forUndefinedKey:key]; &#125;&#125;- (id)clj_valueForKey:(NSString *)key&#123; // 1. 判断 key 是否为空 if (key == nil || key.length == 0) &#123; return nil; &#125; // 2. 判断是否存在相应的 getter 方法（getKey&gt; -&gt; key -&gt; isKey） NSString *funcName1 = [NSString stringWithFormat:@"get%@", key.capitalizedString]; SEL sel1 = NSSelectorFromString(funcName1); if ([self respondsToSelector:sel1]) &#123; return [self performSelector:sel1]; &#125; SEL sel2 = NSSelectorFromString(key); if ([self respondsToSelector:sel2]) &#123; return [self performSelector:sel2]; &#125; NSString *funcName3 = [NSString stringWithFormat:@"is%@", key.capitalizedString]; SEL sel3 = NSSelectorFromString(funcName1); if ([self respondsToSelector:sel3]) &#123; return [self performSelector:sel3]; &#125; // 3. 判断是否允许访问成员变量 if ([[self class] clj_accessInstanceVariablesDirectly]) &#123; // 4. 访问成员变量（_key -&gt; _isKey -&gt; key -&gt; isKey） unsigned int count; Ivar* ivars = class_copyIvarList([self class], &amp;count); for (int i = 0; i &lt; count; i ++) &#123; Ivar ivar = ivars[i]; NSString *ivarName = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding]; NSString *keyName = ivarName; BOOL findKeySuccessed = NO; // 4.1. 先找 _key 成员变量 if ([keyName isEqualToString:[NSString stringWithFormat:@"_%@", key]]) &#123; findKeySuccessed = YES; return object_getIvar(self, ivar); break; &#125; // 4.2. 找 _isKey 成员变量 if ([keyName isEqualToString:[NSString stringWithFormat:@"_is%@", key.capitalizedString]]) &#123; findKeySuccessed = YES; return object_getIvar(self, ivar); break; &#125; // 4.3. 找 key 成员变量 if ([keyName isEqualToString:key]) &#123; findKeySuccessed = YES; return object_getIvar(self, ivar); break; &#125; // 4.4. 找 isKey 成员变量 if ([keyName isEqualToString:[NSString stringWithFormat:@"is%@", key.capitalizedString]]) &#123; findKeySuccessed = YES; return object_getIvar(self, ivar); break; &#125; if (!findKeySuccessed) &#123; [self clj_valueForUndefinedKey:key]; &#125; &#125; &#125; else &#123; [self clj_valueForUndefinedKey:key]; &#125; return nil;&#125;+ (BOOL)clj_accessInstanceVariablesDirectly&#123; NSLog(@"category"); return YES;&#125;@end 调用： 应用场景 动态地取值和设值 访问和修改私有变量 字典模型装换 修改控件的内部属性 操作集合 高阶消息传递 KVO KVC DemoKVO1. KVO 基本用法添加观察者： 1234567_p = [Person new];// 第一个参数 Observer：观察者// 第二个参数 KeyPath：观察的属性（字符串键）// 第三个参数 options：观察的选项// 第四个参数：context：上下文 [_p addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:nil]; 监听回调方法： 123456789// 方法功能：监听回调// 第一个参数 KeyPath：观察的属性（字符串键）// 第二个参数 Object：观察的对象// 第三个参数 change：&lt;字典&gt; 观察的属性值变化信息// 第四个参数 context：上下文- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; NSLog(@"object = %@ keyPath = %@ change = %@", object, keyPath, change);&#125; 移除观察者： 1234- (void)dealloc&#123; [_p removeObserver:self forKeyPath:@"name"];&#125; 2. 属性依赖12345// 属性依赖。一旦监听到 lComponent 值发生变化，就相当于属性 redComponent 也发生变化，同样会发送通知出去+ (NSSet *)keyPathsForValuesAffectingRedComponent&#123; return [NSSet setWithObject:@"lComponent"];&#125; 意思就是：如果设置 A 属性依赖 B 属性，给 A 属性添加观察者后，一旦 B 属性的值发生变化， A 属性的观察者也能够监听到。 3. 自动通知和手动通知默认 KVO 是自动通知的，如果需要关闭自动通知，改为手动通知，可以重写 + (BOOL)automaticallyNotifiesObserversOf&lt;key&gt; 方法，并且在属性的 setter 方法赋值的前后手动调用 willChangeValueForKey: 和 didChangeValueForKey: 方法。 12345678910111213141516171819// 是否对观察的属性 name 自动接收通知。默认是 YES+ (BOOL)automaticallyNotifiesObserversOfName;&#123; return NO;&#125;// 手动开启。// 注意：如果在其他地方修改了成员变量，也需要这样手动调用一下。- (void)setName:(NSString *)name&#123; if (_name == name) &#123; return; &#125; [self willChangeValueForKey:@"name"]; _name = name; [self didChangeValueForKey:@"name"];&#125; 3. KVO 和 context设置一个类唯一的 context，可以保证子类都是正确的，子类和父类都能安全的观察同样的键值而不会冲突。 设置观察者为自己： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static int const PrivateKVOContext;@interface Student ()@property(nonatomic, strong) id target;@property(nonatomic, assign) SEL sel;@property (nonatomic, copy) NSString *keyPath;@end@implementation Student// 初始化方法- (instancetype)initWithKeyPath:(NSString *)keyPath target:(id)target selector:(SEL)sel options:(NSKeyValueObservingOptions)options&#123; NSParameterAssert(target != nil); NSParameterAssert([target respondsToSelector:sel]); self = [super init]; if (self) &#123; self.target = target; self.sel = sel; self.keyPath = keyPath; // 将自己本身当做观察者 [self addObserver:self forKeyPath:keyPath options:options context:&amp;PrivateKVOContext]; &#125; return self;&#125;// 移除观察者- (void)dealloc&#123; [self removeObserver:self forKeyPath:self.keyPath];&#125;// 通知响应- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; if (context == &amp;PrivateKVOContext) &#123; [self didChange:change]; &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125;// 将消息传递出去- (void)didChange:(NSDictionary *)change&#123; id strongTarget = self.target; // 消除警告#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks" [strongTarget performSelector:self.sel withObject:change];#pragma clang diagnostic pop&#125; 调用 5. NSKeyValueObservingOptions NSKeyValueObservingOptionInitial：设置 NSKeyValueObservingOptionInitial 选项，可以监听 addObserver: forKeyPath:options:context:方法调用时的通知以及属性值改变通知。 NSKeyValueObservingOptionPrior：设置该观察选项，可以监听到属性值改变前以及改变后的两次通知。并通过字典 change 中的 key 值进行判断是设置属性值之前，还是之后。 12345678if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) &#123; // 改变之前&#125; else&#123; // 改变之后&#125; NSKeyValueObservingOptionOld：属性值被改变之前接收到监听通知。获取旧值：id oldValue = change[NSKeyValueChangeOldKey]; NSKeyValueObservingOptionNew：属性值被改变之后接收到监听通知。获取新值：id newValue = change[NSKeyValueChangeNewKey]; 5. 索引如果属性是一个集合类，那么 KVO 会监听集合对象的增加，删除，替换等属性值改变操作，并在 change 字典里返回会包含键值变化的类型（添加、删除和替换）对于有序的集合，change 字典会包含受影响的 index。 123-mutableArrayValueForKey:-mutableSetValueForKey:-mutableOrderedSetValueForKey: 6. KVO 和线程KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。手动或者自动调用 - didChangeValueForKey: 会触发 KVO 通知。 KVO 能够保证属性值在 setter 方法调用之前，该属性的观察者就就能够被通知到。 7. KVO Demo#画板效果如下： 主要是通过 KVO 监听画板线条数组的变化，从而刷新撤销按钮、回退按钮、全部删除按钮的 UI 状态。 示例代码 #LAB 色彩空间该 demo 主要是利用了 KVO 的对属性的监听，以及属性依赖，另外还有自定义一个观察者辅助类文件。实现了属性值改变，UI 视图即时响应。 LabColor：lab 颜色的生成，通过 RGB 的颜色的转换。 KeyValueObserver：观察者辅助类，方便添加和移除观察者，以及通知监听。 ViewController：视图控制器，控制视图和数据的交互逻辑。 效果 示例代码 源代码代码地址 参考资料KVC 和 KVOiOS开发-KVO的奥秘KVC/KVO原理详解及编程指南KVO与KVCiOS开发技巧系列—详解KVC]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>KVC</tag>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime 学习]]></title>
    <url>%2F2017%2F05%2F10%2Fruntime-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[runtime 简介消息机制OC 方法的底层实现就是消息机制。 方法调用流程： 通过 isa 指针找到对应的类对象或者元类对象（实例方法保存在类对象中，类方法保存在元类对象中） 通过方法名注册方法编号 根据方法编号查找对应的方法 找到最终函数实现地址，根据地址去内存方法区找到对应的函数 内存 5 大区 栈 堆 静态区 常量区 方法区 消息机制原理:对象根据方法编号 SEL 去映射表查找对应的方法实现 12345678910111213141516// 1. 获取一个类对象id cls = objc_getClass("Person"); // 2. 注册方法编号SEL alloc = sel_registerName("alloc"); // 3. 给类对象发送消息// 参数一：消息接受者// 参数二：消息的实现方法// 参数三：方法的参数Person *p = objc_msgSend(cls, alloc); // 4. 给实例对象发送消息// 4.1. 注册方法编号SEL init = sel_registerName("init");p = objc_msgSend(p, init); 注意：1. 导入头文件 &lt;objc/message.h&gt; 注意：2. 动态方法解析消息转发动态加载获取方法123456789// 1. 获取实例方法// 参数一：类对象// 参数二：方法名// class_getInstanceMethod(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#SEL name#&gt;) // 2. 获取类方法Method oldMethod = class_getClassMethod([NSURL class], sel_registerName("URLWithString:"));Method currentMethod = class_getClassMethod([NSURL class], @selector(clj_urlWithString:)); 交换方法实现系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。 通过交换方法的实现，去拦截监系统方法。比如拦截 NSURL 类的 URLWithString：类方法，判断 url 是否存在。只需要添加一个分类，在类的 load 中和自己写的自定义方法交换。 123456// 1. 获取类方法Method oldMethod = class_getClassMethod([NSURL class], sel_registerName("URLWithString:"));Method currentMethod = class_getClassMethod([NSURL class], @selector(clj_urlWithString:)); // 2. 交换两个方法的实现method_exchangeImplementations(oldMethod, currentMethod); 动态添加方法如果一个给一个对象发送一条没有实现的消息，那么应用程序将会崩溃，利用 runtime 可以给对象动态的添加方法。 如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用 runtime 动态给某个类，添加方法解决。 注意：class_addMethod(Class cls, SEL name, IMP imp, const char *types) 方法最后一个参数 types 的字符对应可参照这里。 给类添加关联对象123456789// 1. 存// 参数一：要关联的源对象// 参数二：key 键值// 参数三：关联对象// 参数四：关联对象值得内存管理策略objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)// 2. 取objc_getAssociatedObject(id object, const void *key) 应用场景：给系统类动态添加属性 123456789- (void)setButtonClickBlock:(void (^)(UIBarButtonItem *))buttonClickBlock&#123; objc_setAssociatedObject(self, @selector(buttonClickBlock), buttonClickBlock, OBJC_ASSOCIATION_COPY);&#125;- (void (^)(UIBarButtonItem *))buttonClickBlock&#123; return objc_getAssociatedObject(self, @selector(buttonClickBlock));&#125; 获取类中的所有成员属性1234567891011121314151617// 参数一：从哪个类中获取// 参数二：这个类有多少成员属性，传入一个无符号 int，会自动给这个变量赋值// 返回值：Ivar *，表示一个 Ivar 数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到unsigned int count;Ivar *ivarList = class_copyIvarList([obj class], &amp;count); for (int i = 0; i &lt; count; i++)&#123; // 根据下标获取对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];&#125; 定义一个类12345678// 定义一个类// 第一个参数：继承自哪个类// 第二个参数：类的名称// 第三个参数：Class cls = objc_allocateClassPair([self class], newClassName, 0);// 注册新类objc_registerClassPair(cls); 修改 isa 指针12// object_setClass(self, cls); 自动生成属性代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354+ (void)resolveDict:(NSDictionary *)dict&#123; // 拼接属性定义 NSMutableString *strM = [NSMutableString string]; // 遍历字典 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 记录数据类型 NSString *type; if ([obj isKindOfClass:NSClassFromString(@"__NSCFString")]) &#123; type = @"NSString"; &#125; else if ([obj isKindOfClass:NSClassFromString(@"__NSCFArray")]) &#123; type = @"NSArray"; &#125; else if ([obj isKindOfClass:NSClassFromString(@"__NSCFBoolean")]) &#123; type = @"BOOL"; &#125; else if ([obj isKindOfClass:NSClassFromString(@"__NSCFNumber")]) &#123; type = @"NSNumber"; &#125; else if ([obj isKindOfClass:NSClassFromString(@"__NSCFDictionary")]) &#123; type = @"NSDictionary"; &#125; // 属性字符串 NSString *property; if ([type containsString:@"NS"]) &#123; if ([type isEqualToString:@"NSString"]) &#123; property = [NSString stringWithFormat:@"@property(nonatomic, copy) %@ *%@;", type, key]; &#125; else &#123; property = [NSString stringWithFormat:@"@property(nonatomic, strong) %@ *%@;", type, key]; &#125; &#125; else &#123; property = [NSString stringWithFormat:@"@property(nonatomic, assign) %@ %@;", type, key]; &#125; [strM appendFormat:@"\n%@\n", property]; &#125;]; NSLog(@"%@", strM);&#125; 调用: 12345NSString *path = [[NSBundle mainBundle] pathForResource:@"status.plist" ofType:nil];NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];NSDictionary *dic = [dict[@"statuses"] firstObject]; [StatusModel resolveDict:dic]; 打印： 扩展：进一步的话，可以考虑写一个自动生成模型属性的小工具，通过后台返回的 JSON 等数据格式转化为模型属性，并直接写入到模型 .h 文件中，自动对应数据类型，内存管理策略，以及添加注释。 KVO 底层实现KVO 监听对象属性的变化其实是监听对象属性的 Setter 方法。 内部是通过 runtime 动态的添加一个一个类，继承自监听的对象，然后通过 runtime 重写了属性的 setter 方法，通过监听对象属性的 setter 方法实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#import "NSObject+KVO.h"#import &lt;objc/message.h&gt;static NSString *const kObserver = @"kObserver";@implementation NSObject (KVO)- (void)clj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context&#123; // 1. 自定义一个继承自观察对象的子类CLJ_KVO_Object // 1.1. 动态生成一个类 NSString *oldClassName = NSStringFromClass([self class]); const char *newClassName = [[@"CLJ_KVO_" stringByAppendingString:oldClassName] UTF8String]; // 定义一个类 // 第一个参数：继承自那个类 // 第二个参数：类的名称 // 第三个参数： Class cls = objc_allocateClassPair([self class], newClassName, 0); // 注册新类 objc_registerClassPair(cls); // 2. 重写被观察属性的 setter 方法，在内部恢复父类的做法，通知观察者 // 添加setter方法 class_addMethod(cls, @selector(setName:), (IMP)setName, "v@:@"); // 3. 修改 self 的 isa 指针，指向子类对象 object_setClass(self, cls); // 4. 将观察者保存到当前对象 // 参数一：要关联的源对象 // 参数二：key 键值 // 参数三：关联对象 // 参数四：关联对象值得内存管理策略 objc_setAssociatedObject(self, &amp;kObserver, observer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;void setName(id self, SEL _cmd, NSString *newName)&#123; NSLog(@"newName = %@", newName); // 保存当前类型 id class = [self class]; // 改变 isa 指针 object_setClass(self, class_getSuperclass(class)); // 调用父类的 set 方法，设置新值 objc_msgSend(self, @selector(setName:), newName); // 取出观察者对象 id observer = objc_getAssociatedObject(self, &amp;kObserver); // 通知观察者 objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:), @"name", self, nil, nil); // 返回子类类型 object_setClass(self, class);&#125; 调用 12345678910111213141516171819202122232425262728293031323334#import "ViewController.h"#import "Person.h"#import "NSObject+KVO.h"@interface ViewController ()@property(nonatomic, strong) Person *p;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p = [[Person alloc] init]; // [p addObserver:self forKeyPath:@"_name" options:NSKeyValueObservingOptionNew context:nil]; [p clj_addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:nil]; _p = p; &#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; NSLog(@"对象%@的%@被改变为%@", object, keyPath, change);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; _p.name = @"chenliangjing";&#125; 打印： 字典转模型1. KVC 实现 KVC 字典转模型弊端： 必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]报key找不到的错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖，就能继续使用KVC，字典转模型了。 12345678910111213141516171819+ (instancetype)statusWithDict:(NSDictionary *)dict&#123; StatusModel *model = [[StatusModel alloc] init]; [model setValuesForKeysWithDictionary:dict]; return model;&#125;// 重写该方法，如果找不到 key- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123; // 让 “idstr” 这个 key 的 value 设置给 “idst” 属性 if ([key isEqualToString:@"idstr"]) &#123; [self setValue:value forKey:@"idst"]; &#125;&#125; 调用和打印： 2.runtime 实现 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找 key，取出对应的值，给模型的属性赋值。 步骤：提供一个 NSObject 分类，专门字典转模型，以后所有模型都可以通过这个分类转。 .h 文件 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;@protocol ModelDelegate &lt;NSObject&gt;@optional// 提供一个协议，只要遵守这个协议的类，都能把数组中的字典转模型// 用在三级数组转换+ (NSDictionary *)arrayContainModelClass;@end@interface NSObject (PropertyRuntime)/// 字典转模型+ (instancetype)modelWithDict:(NSDictionary *)dict;@end .m 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#import "NSObject+PropertyRuntime.h"#import &lt;objc/runtime.h&gt;@implementation NSObject (PropertyRuntime)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 1. 遍历model所有的属性列表 // 1.1. 创建对应的对象 id obj = [[self alloc] init]; // 获取类中的所有成员属性 // 参数一：从哪个类中获取 // 参数二：这个类有多少成员属性，传入一个无符号 int，会自动给这个变量赋值 // 返回值：Ivar *，表示一个 Ivar 数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到 unsigned int count; Ivar *ivarList = class_copyIvarList([obj class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据下标获取对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 从第 1 个下标开始截取 NSString *key = [ivarName substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 去掉转义字符。生成的是这种@"@\"User\"" 类型 -》 @"User" 在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符 type = [type stringByReplacingOccurrencesOfString:@"\"" withString:@""]; type = [type stringByReplacingOccurrencesOfString:@"@" withString:@""]; // 二级转换：如果字典中还有字典，也需要把对应的字典转换成模型 // 数据是字典类型以及是自定义数据类型才需要再做一层字典转模型 if ([value isKindOfClass: [NSDictionary class]] &amp;&amp; ![type hasPrefix:@"NS"]) &#123; // 继续字典转模型 // 根据字符串类名生成类对象 Class modelCalss = NSClassFromString(type); // 有对应模型才需要转 if (modelCalss) &#123; value = [modelCalss modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中对应字典的模型 NSString *modelType = [idSelf arrayContainModelClass][key]; // 生成模型 Class modelClass = NSClassFromString(modelType); if (modelClass) &#123; NSMutableArray *arrM = [NSMutableArray array]; for (NSDictionary *dict in value) &#123; id model = [modelClass modelWithDict:dict]; [arrM addObject:model]; &#125; value = arrM; &#125; &#125; &#125; // 给模型中的属性赋值 if (value) &#123; [obj setValue:value forKey:key]; &#125; &#125; return obj;&#125; 带有数组字典的模型中实现字典数组转模型数组的协议 1234+ (NSDictionary *)arrayContainModelClass&#123; return @&#123;@"pic_urls" : @"PictureModel"&#125;;&#125; 调用：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD 实现定时器]]></title>
    <url>%2F2017%2F05%2F09%2FGCD-%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[NSTimer 实现定时器12345678910111213141516171819202122232425262728293031323334353637383940414243// 在主线程中实现定时器- (void)OCTimerInMainThread&#123; // 1. NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; NSLog(@"我是OCTimer"); &#125;]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; // 2.// [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;// NSLog(@"我也是OCTimer");// &#125;];&#125;&lt;!-- more --&gt;// 在子线程中实现定时器- (void)OCTimerInBackgroudThread&#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // // 1. // [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;// NSLog(@"我是OCTimerInBackgroudThread");// &#125;];// // // 启动子线程 RunLoop// [[NSRunLoop currentRunLoop] run]; // 2. NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; NSLog(@"我是OCTimerInBackgroudThread"); &#125;]; // 将 timer 加入到当前子线程 RunLoop [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; // 启动子线程 RunLoop [[NSRunLoop currentRunLoop] run]; NSLog(@"我是子线程 = %@", [NSThread currentThread]); &#125;);&#125; GCD 实现定时器123456789101112131415161718192021222324252627282930313233343536// 开启定时器- (IBAction)startTimer:(id)sender&#123; [self gcdTimer];&#125;// 取消定时器- (IBAction)cacelTimer:(id)sender&#123; dispatch_cancel(self.timer); self.timer = nil;&#125;- (void)gcdTimer&#123; // 1. 创建定时器源对象 // 注意：dispatch_source_t 是一个局部变量，本质是一个 OC 对象，需要用一个强引用 self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0)); // 2. 设置定时器间隔时间 // 第一个参数：源对象 // 第二个参数：从什么时候开始 // 第三个参数：间隔时间 // 第四个参数：传 0 dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC, 0); // 3. 设置定时器处理事件 dispatch_source_set_event_handler(self.timer, ^&#123; NSLog(@"我是GCD定时器！"); NSLog(@"current Thread = %@", [NSThread currentThread]); &#125;); // 4. 开启定时器 dispatch_resume(self.timer); &#125; 总结NSTimer 定时器受 RunLoop 的 Mode 影响，而 GCD 的定时器不受 RunLoop 的 Mode 影响。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop 学习]]></title>
    <url>%2F2017%2F05%2F09%2FRunLoop-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[介绍RunLoop：运行循环，每个线程对应一个 RunLoop，主线程的 RunLoop 默认启动，子线程的 RunLoop 需要手动启动。 作用： 使程序一直运行并接受用户输入 决定程序在何时应该处理那些事件 调用解耦（Message Queue） 节省 CPU 时间 RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面事件循环的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 构成元素 CFRunLoopRef ：在 CoreFoundation 框架内的，提供了纯 C 函数的 API，所有这些 API 都是线程安全的。 NSRunLoop ：基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 说明：一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个 Mode 被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef：事件产生的地方。有 Source0 和 Source1 两个版本。 Source0：只包含了一个回调（函数指针），并不能主动触发事件。使用时，需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。处理 App 累不时间，App 自己负责管理，如 UIEvent、CFSocket Source1：包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。能主动唤醒 RunLoop 的线程。由 RunLoop 内核管理，Mach port 驱动，如 CFMachPort、CFMessagePort CFRunLoopTimerRef：基于时间的触发器，和 NSTimer 是 toll-free bridged 的，可以混用。包含一个时间长度和一个回调（函数指针）。当加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调。 CFRunLoopObserverRef：观察者。每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接收到这个变化。可以观测的时间点有： 1234567891011121314151617181920212223/* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; /// 即将进入 Loop kCFRunLoopEntry = (1UL &lt;&lt; 0), /// 即将处理 Timer kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), /// 即将处理 Source kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), /// 即将进入休眠 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), /// 刚从休眠中醒来 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), /// 即将退出 Loop kCFRunLoopExit = (1UL &lt;&lt; 7), /// RunLoop 所有活动状态 kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; RunLoop 内部逻辑 每次运行 Run Loop， 线程的 Run Loop 都会自动处理之前未处理的的消息，并通知相关的观察者。 通知观察者 Run Loop 已经启动 通知观察者任何即将要开始的定时器 通知观察者任何即将启动的 Source0(非基于端口的源) 通知观察者任何准备好的 Source0(非基于端口的源) 如果 Source1 （基于端口的源）准备好并处于等待状态，立即启动，并进入步骤 9 通知观察者线程进入休眠 将线程置于休眠直到任一下面的事件发生： 某一事件到达 Source1 （基于端口的源） 定时器启动 Run Loop 设置的时间已经超时 Run Loop 被显式唤醒 通知观察者线程将被唤醒 处理未处理的事件 如果用户定义的定时器启动，处理定时器事件并重启 Run Loop，进入步骤 2 如果输入源启动，传递相应的消息 如果 Run Loop 被显式唤醒并且时间还没超时，重启 Run Loop，进入步骤 2 通知观察者 Run Loop 结束。 CFRunLoopMode NSDefaultRunLoopMode：默认状态，空闲状态。App的默认 Mode，通常主线程是在这个 Mode 下运行的 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode：刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，私有。 NSRunLoopCommonModes：UITrackingRunLoopMode 和 NSDefaultRunLoopMode 常用方法1. 获取主线程 RunLoopCFRunLoopRef mainRunLoop = CFRunLoopGetMain(); 2. 获取当前线程 RunLoopCFRunLoopRef currentRunLoop = CFRunLoopGetCurrent() 3. 对 Mode 的管理接口1234567// 添加常用 CommonMode// CFRunLoopRef ： RunLoop 实例对象// CFRunLoopMode : mode 名称CFRunLoopAddCommonMode(CFRunLoopRef rl, CFRunLoopMode mode) /// RunLoop 运行在什么模式中CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds&gt;, Boolean returnAfterSourceHandled) 4. Mode 对 mode item 的接口管理// 添加 Source/Timer/Observer CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName); CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName); CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); // 移除 Source/Timer/Observer CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName); CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName); CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 说明：只能通过 mode name 来操作内部的 mode，当传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop 会自动创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 5. 添加观察者，监听 RunLoop 活动状态的改变 注意：CF 对象的内存管理 凡是带有 Creat、Copy、Retain 的关键字的函数，都需要在最后做一次 release 操作 release 函数：CFRealease(对象) 使用场景#1. 定时器 #2. 子线程异步通知源代码地址 通知的特点 通知默认同步执行的 当前发送通知的线程在那条线程，通知执行就会在那条线程。 #3. 创建常驻线程（线程保活）子线程默认没有开启 Run Loop，开启子线程后，当任务一结束，子线程就会立即销毁。有时候需要子线程一直存在，做一些事情，这种情况下就可以使用 Run Loop 创建常驻线程。 #4. 自动释放池 第一次创建：启动 Run Loop 时 最后一次销毁： Run Loop 退出的时候 其他时候的创建和销毁：当 Run Loop 即将睡眠的时候销毁之前的释放池，重新创建一个新的释放池 #5. ImageView 显示指定 ImageView 视图不在 UITrackingRunLoopMode 模式下设置。 #6. PerformSelector12// 指定在哪个 RunLoop 模式下执行方法[self performSelector:@selector(run) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO modes:@[UITrackingRunLoopMode]]; 总结 runloop 应用场景？ 开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来的消息，处理其他事件） 在子线程中开启一个定时器 在子线程中进行一些长期监控 可以控制定时器在那种模式下运行 可以设置某些事件（行为、任务）在特定模式下执行 可以添加 Observer 监听 RunLoop 的状态，比如监听点击事件的处理，在所有点击事件之前做一些事情。 学习资料苹果官方文档CFRunLoopRef 源代码iOS线下分享《RunLoop》by 孙源@sunnyxx深入理解RunLoop]]></content>
      <categories>
        <category>iOS</category>
        <category>RunLoop</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage 源码学习]]></title>
    <url>%2F2017%2F05%2F03%2FSDWebImage-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言SDWebImage 是用来做图片异步加载以及图片缓存的第三方库，用一行代码就能集成图片的多级缓存以及异步下载，功能强大，好用方便。之前学习多线程 NSOperation 时，实现过一个简单的图片异步下载，代码在这里。现在想了解一下 SDWebImage 的实现机制和工作原理，通过过阅读他的源代码。我这里的版本是 SDWebImage 4.0.0。 使用方法 1.通过 UIImageView+WebCache 分类，给一个 UIImageView 视图下载并设置图片。 1234// 方法：根据一个 url 给一个 UIImageView 视图下载并设置图片// URL：图片资源地址// placeholderImage：占位图片[cell.imageView sd_setImageWithURL:[NSURL URLWithString:a.icon] placeholderImage:[UIImage imageNamed:@"placeHolder"]]; 2.通过 UIImageView+WebCache 分类，获取下载过程回调，下载完成回调 1234567891011// 给 UIImageView 视图下载并设置图片// 参数一 URL：图片资源路径// 参数二 placeholderImage ：占位图片// 参数三 options ：选择枚举，图片下载选项操作// 参数四 progress： 图片下载过程进度回调（receivedSize ： 已下载的图片数据大小，expectedSize：图片真实的数据大小，targetURL：图片资源目标路径）// 参数五 completed：图片下载完毕回调（image ：图片，error：错误信息，cacheType：枚举，缓存类型，imageURL：图片目标路径）[cell.imageView sd_setImageWithURL:[NSURL URLWithString:a.icon] placeholderImage:[UIImage imageNamed:@"placeHolder"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123; &#125; completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123; &#125;]; 说明1：SDWebImageOptions 选项 123456789101112131415161718192021222324252627282930313233343536373839/// 下载图片操作选项枚举typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; /// 下载失败后重新下载。默认情况下,如果一个 url 在下载的时候失败了,那么这个url 会被加入黑名单并且 library 不会尝试再次下载。如果设置这个选项，那么即使某个 url 下载失败了，还是会尝试再次下载 SDWebImageRetryFailed = 1 &lt;&lt; 0, /// 低优先级下载。默认情况下，图片会在发生交互时下载，比如 tableView 滑动时。如果设置了这个选项，那么在应用发生交互的情况下会停止下载，交互结束后又重新下载 SDWebImageLowPriority = 1 &lt;&lt; 1, /// 禁止磁盘缓存,只有内存缓存 SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, /// 显示图片下载进度 SDWebImageProgressiveDownload = 1 &lt;&lt; 3, /// 刷新缓存。如果选择这个选项，一个图片即使被缓存了，还是会去重新下载，并重新缓存 SDWebImageRefreshCached = 1 &lt;&lt; 4, /// 继续在后台下载。如果图片正在下载中，程序进入后台，设置这个选项会在后台继续下载图片 SDWebImageContinueInBackground = 1 &lt;&lt; 5, /// 可以控制存在NSHTTPCookieStore的cookies SDWebImageHandleCookies = 1 &lt;&lt; 6, /// 允许不安全的SSL证书,在正式环境中慎用 SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, /// 高优先级，优先下载图片。默认情况下,image 在下载的时候是按照他们在队列中的顺序下载的(就是先进先出).设置这个选项会把他们移动到队列的前端,并且立刻下载,而不是等到当前队列装载的时候再装载. SDWebImageHighPriority = 1 &lt;&lt; 8, /// 默认情况下,占位图片会在图片下载的时候显示.设置这个选项会延迟占位图显示的时间,等到图片下载完成之后才会显示占位图 SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11, SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12&#125;; 说明2：SDImageCacheType 枚举 123456789101112/// 图片缓存类型typedef NS_ENUM(NSInteger, SDImageCacheType) &#123; /// 没有缓存，图片来自下载 SDImageCacheTypeNone, /// 图片来自磁盘缓存 SDImageCacheTypeDisk, /// 图片来自内存缓存 SDImageCacheTypeMemory&#125;; 3.通过 SDWebImageManager 类单例，获取下载的图片，不进行设置（依然有内存&amp;磁盘缓存） 12345[[SDWebImageManager sharedManager] loadImageWithURL:[NSURL URLWithString:@"http://image.tianjimedia.com/uploadImages/2015/162/22/4GU4301NQGWW.jpg"] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123; &#125; completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) &#123; self.imageView.image = image;&#125;]; 4.通过 SDWebImageDownloader 类单例，直接下载，不做内存以及磁盘缓存。 [[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:@&quot;http://p.3761.com/pic/20131413167658.jpg&quot;] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) { } completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, BOOL finished) { // 注意：这里是在子线程 [[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.imageView.image = image; }]; }]; 设置 gif 图片设置动态 GIF 图片。SDWebImage 4.0.0 以后设置 gif 图片的方式就改了，需要额外 pod ‘SDWebImage/GIF’ ，并且显示图片的 UIImageView 要改成 FLAnimatedImageView 类。 123456// 设置动态 gif 图片- (void)setupGifImage&#123; NSData *data = [NSData dataWithContentsOfFile:@"/Users/chenliangjing/Downloads/23b8c47499b23d19c7129085b9e2aca7.gif"]; self.imageView.animatedImage = [FLAnimatedImage animatedImageWithGIFData:data];&#125; 注意：需要导入头文件 #import &lt;FLAnimatedImage.h&gt; 处理内存警告123456789101112131415161718// 内存警告- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application&#123; // 1. 清空缓存 // 直接删除，然后重新创建 [[SDWebImageManager sharedManager].imageCache clearDiskOnCompletion:^&#123; &#125;]; // 清除过期缓存，计算当前缓存的大小，和设置的最大缓存数量作比较，如果超出，继续删除（根据文件创建的时间先后顺序） // kDefaultCacheMaxCacheAge : 1 week [[SDWebImageManager sharedManager].imageCache deleteOldFilesWithCompletionBlock:^&#123; &#125;]; // 2. 取消当前所有操作 [[SDWebImageManager sharedManager].imageDownloader cancelAllDownloads];&#125; 最大并发数量在 SDWebImageDownloader 类的 initWithSessionConfiguration: 初始化方法里面设置为 6 12345678910- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration &#123; if ((self = [super init])) &#123; // 队里里面任务执行顺序，默认先进先出 _executionOrder = SDWebImageDownloaderFIFOExecutionOrder; _downloadQueue = [NSOperationQueue new]; // 队列最大并发数 = 6 _downloadQueue.maxConcurrentOperationCount = 6; &#125; return self;&#125; 缓存文件的保存名称处理方式拿到图片的 URL 路径，对路径进行 MD5 加密存储。 12345678910111213- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key &#123; const char *str = key.UTF8String; if (str == NULL) &#123; str = ""; &#125; unsigned char r[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), r); NSString *filename = [NSString stringWithFormat:@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@", r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15], [key.pathExtension isEqualToString:@""] ? @"" : [NSString stringWithFormat:@".%@", key.pathExtension]]; return filename;&#125; 对内存警告的处理方式通过接收应用活动状态的通知，进行内存警告的处理，如果应用出现内存警告，就清除内存缓存。 123456789101112131415161718// Subscribe to app events/// 应用出现内存警告时调用[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(clearMemory) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];/// 应用被终止时调用[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deleteOldFiles) name:UIApplicationWillTerminateNotification object:nil];/// 应用进入后台时调用[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundDeleteOldFiles) name:UIApplicationDidEnterBackgroundNotification object:nil]; 缓存处理的方式使用 NSCache 类处理内存缓存使用沙盒 cache 处理磁盘缓存 1@property (strong, nonatomic, nonnull) NSCache *memCache; 判断图片的类型使用了一个 NSData+ImageContentType 分类，根据图片的二进制数据的第一个字节码来判断。 12345678910111213141516171819202122232425262728293031+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123; if (!data) &#123; return SDImageFormatUndefined; &#125; uint8_t c; [data getBytes:&amp;c length:1]; switch (c) &#123; case 0xFF: return SDImageFormatJPEG; // JPEG 类型 case 0x89: return SDImageFormatPNG; // PNG 类型 case 0x47: return SDImageFormatGIF; // GIF 类型 case 0x49: case 0x4D: return SDImageFormatTIFF; // TIFF 类型 case 0x52: // R as RIFF for WEBP if (data.length &lt; 12) &#123; return SDImageFormatUndefined; &#125; NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding]; if ([testString hasPrefix:@"RIFF"] &amp;&amp; [testString hasSuffix:@"WEBP"]) &#123; return SDImageFormatWebP; // WebP 类型 &#125; &#125; return SDImageFormatUndefined;&#125; 队列中任务的处理方式默认是：FIFO 123456789/// 队列中任务执行顺序typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123; /// 默认是先进先出 SDWebImageDownloaderFIFOExecutionOrder, /// 后进先出 SDWebImageDownloaderLIFOExecutionOrder&#125;; 如何下载图片通过发送网络请求来下载图片，使用 NSURLSession 请求超时的时间默认是 15 秒。 12345678910111213/// 网络请求超时时间_downloadTimeout = 15.0;sessionConfiguration.timeoutIntervalForRequest = _downloadTimeout;/** * Create the session for this task * We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate * method calls and completion handler calls. */self.session = [NSURLSession sessionWithConfiguration:sessionConfiguration delegate:self delegateQueue:nil]; 调用顺序UIImageView+WebCache 的分类方法，给一个 UIImageView 下载设置图片: 然后调用： 接着调用 UIView+WebCache 类中方法： 其实就是单例类 SDWebImageManager 中的下载方法： 最终调用 SDWebImageDownloader 类中的下载方法，通过 NSUrlSeesion 类进行网络下载： 源码源码地址]]></content>
      <categories>
        <category>iOS</category>
        <category>源码学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 架构模式之 MVP 模式]]></title>
    <url>%2F2017%2F04%2F27%2FiOS-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8B-MVP-%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言在 iOS 项目开发中，有很中架构模式，最经典的是 MVC 模式，M 代表数据层，V 代表视图 UI 层，C 代表控制器层，主管业务逻辑，负责把 M 层的数据显示到 V 视图层上，还有其他的一些架构模式，如 MVVM，还有今天介绍的 MVP。由于是第一次接触 MVP，只记录学到的一个案例。 源码 Objective-C 版本 Swift 版本 MVP 简介 MVP 架构模式 M：数据层（网络、数据库、文件等）数据相关 V：UIView 以及子类 + UIViewController 及子类 P：中介（用于关联 M 和 V） 特点：将数据层和 UI 层完全隔离。V 层：只负责创建 UI 和显示 UI，刷新 UI。 模拟场景通常一个业务开发的流程是这样的，进入一个页面 –&gt; 请求数据 –&gt; 网络加载 –&gt; 渲染 UI。下面就模拟一下这样一个业务场景，请求数据渲染一个列表视图，通过 MVP 架构模式来编写代码，看看会发生什么？ 第一步编写一个网络请求工具类，通过传递请求路径，请求参数，请求方式能够从网上请求数据并回调出去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// get 请求+ (void)getRequsetWithUrl:(NSString *)urlString callBack:(callBack)callBack&#123; // 1. 创建请求 URL NSURL *url = [NSURL URLWithString:urlString]; // 2. 创建请求参数集合 NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; // 3. 设置请求方式 request.HTTPMethod = @"GET"; // 4. 创建请求会话 NSURLSession *seesion = [NSURLSession sharedSession]; // 5. 创建一个请求任务 [SVProgressHUD show]; NSURLSessionDataTask *task = [seesion dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 7. 处理请求结果 if (error != nil) &#123; [SVProgressHUD setStatus:@"请求失败"]; NSLog(@"请求失败 --- error = %@", error); &#125; else &#123; [SVProgressHUD dismiss]; NSLog(@"请求成功"); NSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error]; if (error) &#123; NSLog(@"error = %@", error); NSLog(@"json 解析失败！"); &#125; else &#123; // 8. 回调请求结果 callBack(jsonDict); &#125; &#125; &#125;]; // 6. 执行请求 [task resume];&#125; 第二步新建一个列表数据的 Model，用来装载数据，在里面做一些数据转换的操作，把字典数组转成模型数组，并回调出去。 1234567891011// 请求分类列表数据- (void)requestCategoryDataWithName:(NSString *)name pwd:(NSString *)pwd callBack:(void(^)(id response))callBack&#123; NSLog(@"name = %@, pwd = %@", name, pwd); [HttpUtils getRequsetWithUrl:@"http://api.budejie.com/api/api_open.php?a=category&amp;c=subscribe" callBack:^(NSDictionary *dict) &#123; NSDictionary *dic = dict[@"list"]; // 将字典数组转成模型数组 id response = [NSArray yy_modelArrayWithClass:[self class] json:dic]; callBack(response); &#125;];&#125; 第三步新建一个协议，让 V 层遵守这个协议，一旦业务逻辑发起网络请求并回调，就响应这个协议。 12345@protocol CategroyTableViewDelegate &lt;NSObject&gt;- (void)onCategroyTableViewResult:(id)result;@end 第四步新建 P 层，关联 V 层和 M 层，并提供绑定 View 以及解除绑定 View 的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#import "CategoryPresenter.h"#import "CategoryModel.h"@interface CategoryPresenter ()@property(nonatomic, strong) CategoryModel *categoryM;@property(nonatomic, weak) id&lt;CategroyTableViewDelegate&gt; categoryT;@end@implementation CategoryPresenter- (instancetype)init&#123; self = [super init]; if (self) &#123; _categoryM = [[CategoryModel alloc] init]; &#125; return self;&#125;// 绑定view- (void)attachView:(id&lt;CategroyTableViewDelegate&gt;)categoryTableView&#123; _categoryT = categoryTableView;&#125;// 解除绑定View- (void)detachView&#123; _categoryT = nil;&#125;- (void)categoryTableViewRequestDataWithName:(NSString *)name pwd:(NSString *)pwd&#123; [_categoryM requestCategoryDataWithName:name pwd:pwd callBack:^(id response) &#123; if (_categoryT != nil &amp;&amp; [_categoryT respondsToSelector:@selector(onCategroyTableViewResult:)]) &#123; // 响应这个协议方法 [_categoryT onCategroyTableViewResult:response]; &#125; &#125;];&#125; 第五步在控制器里面遵守并实现这个协议，并发起数据请求。 1234567891011121314151617181920212223242526272829303132333435363738@interface ViewController () &lt;CategroyTableViewDelegate&gt;@property (nonatomic, strong) CategoryPresenter *catePresenter;@property (weak, nonatomic) IBOutlet CategroyTableView *categoryTableView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _catePresenter = [[CategoryPresenter alloc] init]; // 绑定 P [_catePresenter attachView:self]; // 发起数据请求 [_catePresenter categoryTableViewRequestDataWithName:@"chenlaingjing" pwd:@"123456"];&#125;- (void)viewDidDisappear:(BOOL)animated&#123; [super viewDidDisappear:animated]; // 解除绑定 [_catePresenter detachView];&#125;#pragma mark - CategroyTableViewDelegate- (void)onCategroyTableViewResult:(id)result&#123; NSLog(@"result = %@", result); dispatch_async(dispatch_get_main_queue(), ^&#123; self.categoryTableView.dataArray = (NSArray *)result; &#125;);&#125; 第六步最后一步，数据请求成功后去刷新表格视图 1234567#pragma mark - setter- (void)setDataArray:(NSArray *)dataArray&#123; _dataArray = dataArray; [self reloadData];&#125; 总结方法调用顺序：一进入到这个控制器的视图，先会创建 P 层，并绑定控制器，然后调用 P 层的发起网络请求方法 categoryTableViewRequestDataWithName:，将请求参数传递进去，然后来到 P 层方法实现，调用 M 层的数据请求方法，M 层给网络请求工具类传递请求路径，请求方式，请求参数， HttpUtils 网络请求层请求完成后回调给 M 层，M 层做一个数据处理的工作，这里讲字典数据转成模型数据传递到 P 层，P 层拿到数据后先判断是否有绑定 V 层，并且是否代理响应了协议方法，如果是，就响应协议方法，并把 P 层拿到的模型数据数据传递出去，由于 V 层遵守了代理，实现了协议方法，所以一旦网络请求完成回调，就会执行协议方法，并传递模型数组数据，V 层一拿到数据，就去刷新表格视图。]]></content>
      <categories>
        <category>iOS</category>
        <category>架构模式</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>架构模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 语言基础（五、Foundation 框架）]]></title>
    <url>%2F2017%2F04%2F26%2FObjective-C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%E3%80%81Foundation-%E6%A1%86%E6%9E%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Foundation 简介Foundation 框架是 Mac/iOS 中其他框架的基础，Foundation 框架包含了很多开发中常用的数据类型（结构体、枚举、类） 字符串源码地址一源码地址二 1.NSString#创建字符串12345678// 1. 通过字符串常量创建，存储在`常量区`中NSString *str1 = @"张三"; // 2. 通过对象方法创建NSString *str2 = [[NSString alloc] initWithFormat:@"李四"]; // 2. 通过类工厂方法创建NSString *str3 = [NSString stringWithFormat:@"李四"]; 通过不同的方式创建的字符串，字符串对象存储的位置不一样 通过字符串常量创建：字符串对象存储在常量区中，并且如果多个字符串对象，多个字符串对象指向同一块存储空间。 通过对象方法以及类工厂方法创建：字符串对象存储在堆区中。 注意：不同平台存储的方式也不一样，如果是 MAC 平台，系统会对字符串对象进行优化，如果是 iOS 平台就是两个对象。 #字符串读写文件读直接读写文件中的字符1234567891011121314151617181920212223242526272829303132// 字符串读取// 1. 从文件中读取字符串/** file：文件路径，绝对路径 encoding: 字符编码，一般写 UTF-8 */NSError *error = nil;NSString *str = [NSString stringWithContentsOfFile:@"/Users/chenliangjing/Desktop/test.txt" encoding:NSUTF8StringEncoding error:&amp;error];if (error == nil)&#123; NSLog(@"str = %@",str);&#125;else&#123; NSLog(@"error = %@", [error localizedDescription]);&#125;// 2. 将字符串写入文件中NSDate *now = [NSDate date];NSString *str = [NSString stringWithFormat:@"%@", now]; // atomically:如果YES，字符串写入文件的过程如果没有写完，那么不会生成文件// 如果NO，字符串写入文件的过程如果没有写完，会生成文件[str writeToFile:@"/Users/chenliangjing/Desktop/test.txt" atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];if (error == nil)&#123; NSLog(@"str = %@",str);&#125;else&#123; NSLog(@"error = %@", [error localizedDescription]);&#125; 根据 URL 加载文件中的字符串12345678910111213141516// 根据 URL 从文件中读取字符串// 1. 创建 URL// 协议头 + 主机地址 + 文件路径NSString *path = @"file://192.168.0.100/Users/chenliangjing/Desktop/test.txt";NSURL *url = [NSURL URLWithString:path]; // 2. 根据 URL 加载文件中的字符串NSString *str = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];if (error == nil)&#123; NSLog(@"str = %@", str);&#125;else&#123; NSLog(@"error = %@", [error localizedDescription]);&#125; 如果资源是在本机地址获取的，那么 URL 的主机地址可以省略，上述的路径可以写为： 12// 前面的 `/` 不能省略，代表根路径 NSString *path = @"file:/Users/chenliangjing/Desktop/test.txt"; 如果是通过 fileURLWithPath: 方法创建 URL，则协议头也不用写，系统会自动添加协议头（file://） 12NSString *path = @"/Users/chenliangjing/Desktop/test.txt"; NSURL *url = [NSURL fileURLWithPath:path]; 注意：如果 URL 中含有中文，通过 fileURLWithPath: 方法创建 URL 会自动将中文进行百分号编码，而如果通过 UrlWithString: 方法，不会自动进行中文的处理，需手动进行中文百分号编码： 文件写1234567891011// 文件写入NSString *str = @"chenliangjing";NSString *path = @"/Users/chenliangjing/Desktop/test.txt";NSError *error = nil;[str writeToURL:[NSURL fileURLWithPath:path] atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];if (error) &#123; NSLog(@"写入失败"); NSLog(@"error = %@", error);&#125; else &#123; NSLog(@"写入成功");&#125; 注意：如果多次往同一个文件中写入内容，那么最后一次写入的内容会覆盖掉以前的内容。 #字符串比较比较两个字符串的“内容”是否相同123// 1. 比较两个字符串的“内容”是否相同bool flag = [str1 isEqualToString:str2];NSLog(@"flag = %i", flag); 比较两个字符串的”地址“是否相同12// 2. 比较两个字符串的”地址“是否相同flag = (str1 == str2); 比较两个字符串大小，比较的 ACCIC 码值 NSOrderedAscending 升序，前面的小于后面的 NSOrderedSame, 相等 NSOrderedDescending 降序，前面的大于后面的 1234567891011121314151617181920212223242526272829303132// 1. 不忽略大小写比较switch ([str1 compare:str2]) &#123; case NSOrderedAscending: NSLog(@"str1 小于 str2"); break; case NSOrderedSame: NSLog(@"str1 等于 str2"); break; case NSOrderedDescending: NSLog(@"str1 大于 str2"); break; default: break;&#125;; // 2. 忽略大小写比较NSString *str3 = @"zhangsan";NSString *str4 = @"ZHANGSAN";switch ([str3 caseInsensitiveCompare:str4]) &#123; case NSOrderedAscending: NSLog(@"str3 小于 str4"); break; case NSOrderedSame: NSLog(@"str3 等于 str4"); break; case NSOrderedDescending: NSLog(@"str3 大于 str4"); break; default: break;&#125;; #字符串搜索判断是否以什么开头12345678910 NSString *str = @"http://www.baidu.com";// 1. 判断是否以什么开头if ([str hasPrefix:@"http://"])&#123; NSLog(@"是一个 url");&#125;else&#123; NSLog(@"不是一个 url");&#125; 判断以什么结尾12345678if ([str hasSuffix:@".gif"])&#123; NSLog(@"动态图片");&#125;else&#123; NSLog(@"不是动态图片");&#125; 判断字符串中是否包含“某个字符串”1234567891011121314// 只要 str 中包含“某个字符串”，就会返回该字符串在字符串中的起始位置和长度NSRange range = [str rangeOfString:@"baidu"];NSLog(@"range.location = %lu, range.length = %lu", range.location, range.length); // range.location = 11, range.length = 5// 如果 str 中没有需要查找的字符串，那返回的 range 的length = 0，location = NSNotFoundNSRange range2 = [str rangeOfString:@"google"];if (range2.location != NSNotFound)&#123; NSLog(@"在 str 中找到 “baidu”");&#125;else&#123; NSLog(@"在 str 中没有找到 “baidu”"); NSLog(@"range2.length = %lu", range2.length); // 0&#125; #字符串截取123456789101112131415161718192021222324NSString *str = @"&lt;hea&gt;陈良静&lt;/hea&gt;";// 默认从第一个字符开始找NSUInteger location = [str rangeOfString:@"&gt;"].location + 1;// NSBackwardsSearch，从最后一个字符开始找NSUInteger length = [str rangeOfString:@"&lt;" options:NSBackwardsSearch].location - location;NSRange range = NSMakeRange(location,length);// 1. 在 range 范围内截取NSString *newStr = [str substringWithRange:range];NSLog(@"str = %@, newStr = %@", str, newStr); // str = &lt;hea&gt;陈良静&lt;/hea&gt;, newStr = 陈良静// 2. 从什么位置开始截取，一直截取到最后// 默认从第一个字符开始找NSUInteger fromLocation = [str rangeOfString:@"&gt;"].location + 1;NSString *newStr = [str substringFromIndex:fromLocation];NSLog(@"str = %@, newStr = %@", str, newStr); // &lt;hea&gt;陈良静&lt;/hea&gt;, newStr = 陈良静&lt;/hea&gt;// 3. 从开头开始截取，一直截取到什么位置NSUInteger toLocation = [newStr rangeOfString:@"&lt;"].location;newStr = [newStr substringToIndex:toLocation];NSLog(@"str = %@, newStr = %@", str, newStr); // &lt;hea&gt;陈良静&lt;/hea&gt;, newStr = 陈良静 #字符串替换用制定字符串替换字符串中的子串1234NSString *str = @"http://www.baidu.com";// 将“baidu”替换为“sina”NSString *newStr = [str stringByReplacingOccurrencesOfString:@"baidu" withString:@"sina"];NSLog(@"str = %@, newStr = %@", str, newStr); // str = http://www.baidu.com, newStr = http://www.sina.com 去除空格123NSString *str = @" http://ww w.baidu.c om ";NSString *newStr = [str stringByReplacingOccurrencesOfString:@" " withString:@""];NSLog(@"str = %@, newStr = %@", str, newStr); // http://ww w.baidu.c om , newStr = http://www.baidu.com 替换首尾1234567891011NSString *str = @" ht tp://ww w.b ai du.com ";// 去除首尾的空格NSCharacterSet *set = [NSCharacterSet whitespaceCharacterSet];NSString *newStr = [str stringByTrimmingCharactersInSet:set];NSLog(@"str = %@, newStr = %@", str, newStr); // str = ht tp://ww w.b ai du.com , newStr = ht tp://ww w.b ai du.com // 将首尾的大写字符全部取出掉str = @"HTTP://www.baidu.com";NSCharacterSet *set2 = [NSCharacterSet uppercaseLetterCharacterSet];newStr = [str stringByTrimmingCharactersInSet:set2];NSLog(@"str = %@, newStr = %@", str, newStr); // str = HTTP://www.baidu.com, newStr = ://www.baidu.com #字符串和路径判断是否是一个绝对路径12345678910// 本质是判断字符串是否以“/”开头bool flag = [str isAbsolutePath];if (flag)&#123; NSLog(@"str 是一个绝对路径"); // str 是一个绝对路径&#125;else&#123; NSLog(@"str 不是一个绝对路径");&#125; 获取文件路径中的最后一个目录123// 本质是获取路径中最后一个/后面的内容NSString *lastDir = [str lastPathComponent];NSLog(@"lastDir = %@", lastDir); // lastDir = test.txt 删除文件路径中的最后一个目录1234// 本质是删除最后一个"/"以及后面的内容NSString *newStr = [str stringByDeletingLastPathComponent];NSLog(@"str = %@, newStr = %@", str, newStr); // str = /Users/chenliangjing/Desktop/test.txt, newStr = /Users/chenliangjing/Desktop 给文件路径添加一个目录1234// 如果原路径后面已经有了"/"，则不会在添加“/”，如果有没有，怎会添加“/”，如果有多个"/",则会删除多余的"/"，只保留一个"/"NSString *addDir = @"chenliangjing.tex";newStr = [str stringByAppendingPathComponent:addDir];NSLog(@"str = %@, newStr = %@", str, newStr); // str = /Users/chenliangjing/Desktop/test.txt, newStr = /Users/chenliangjing/Desktop/test.txt/chenliangjing.tex 获取路径中的文件扩展名123// 本质是从字符串的末尾开始查找，截取第一个"."后面的内容NSString *extName = [str pathExtension];NSLog(@"extName = %@", extName); // extName = txt 删除路径中的文件扩展名123// 本质是从字符串的末尾开始查找，删除第一个"."后面的内容newStr = [str stringByDeletingPathExtension];NSLog(@"str = %@, newStr = %@", str, newStr); // str = /Users/chenliangjing/Desktop/test.txt, newStr = /Users/chenliangjing/Desktop/test 给文件路径天机一个扩展名123NSString *addExtName = @"gif";newStr = [newStr stringByAppendingPathExtension:addExtName];NSLog(@"newStr = %@", newStr); // newStr = /Users/chenliangjing/Desktop/test.gif #字符串转换将字符串装换为大写NSString *str = @&quot;chenLiangJing&quot;; NSString *newStr = [str uppercaseString]; NSLog(@&quot;str = %@, newStr = %@&quot;, str, newStr); // str = chenLiangJing, newStr = CHENLIANGJING 将字符串装换为小写newStr = [str lowercaseString]; NSLog(@&quot;str = %@, newStr = %@&quot;, str, newStr); // henLiangJing, newStr = chenliangjing 将字符串的首字符转换为大写newStr = [str capitalizedString]; NSLog(@&quot;str = %@, newStr = %@&quot;, str, newStr); // str = chenLiangJing, newStr = Chenliangjing 字符串与基本数据类型的转换NSInteger a = 10; NSInteger b = 10; newStr = [NSString stringWithFormat:@&quot;%ld&quot;, a + b]; // newStr = 20 NSLog(@&quot;newStr = %@&quot;, newStr); NSString *str1 = @&quot;30&quot;; // 要确保装换的字符串确实可以转成想要的基本数据类型，否则会结果错误 NSString *str2 = @&quot;50&quot;; NSInteger result = [str1 integerValue] + [str2 integerValue]; NSLog(@&quot;result = %ld&quot;, result); // result = 80 C 语言字符创和 Objective-C 字符串之间的转换123456789// C 转 OCchar *cStr = "clj";NSString *ocStr = [NSString stringWithUTF8String:cStr];NSLog(@"cStr = %s, ocStr = %@", cStr, ocStr); // cStr = clj, ocStr = clj // OC 转 CocStr = @"chenliangjing";const char *newcStr = [ocStr UTF8String];NSLog(@"ocStr = %@, newcStr = %s", ocStr, newcStr); // ocStr = chenliangjing, newcStr = chenliangjing 2.NSMutableString#NSMutableString 基本概念 NSMutableString 是 NSString 类的子类，NSString 类中提供的所有方法在 NSMutableString 类中都可以使用，NSMutableString 类似一个字符串链表，可以任意的在字符串中添加、删除字符串，在指定位置插入字符串，用来操作字符串更加灵活。 可变和不可变 不可变指的是字符串在内存中占用的存储空间固定，并且存储的内容不能发生变化 可变指的是字符串在内存中占用的存储空间可以不固定，并且存储的内容可以被修改 #NSMutableString 常用方法在字符串后面添加字符串[mStr appendString:@&quot;liangjing&quot;]; NSLog(@&quot;mStr = %@&quot;, mStr); // mStr = chenliangjing [mStr appendFormat:@&quot;&apos;s age is %i&quot;, 25]; NSLog(@&quot;mStr = %@&quot;, mStr); // mStr = chenliangjing&apos;s age is 25 删除字符串NSRange delRange = [mStr rangeOfString:@&quot;&apos;s age is 25&quot;]; [mStr deleteCharactersInRange:delRange]; NSLog(@&quot;mStr = %@&quot;, mStr); // chenliangjing 插入字符串NSRange insRange = [mStr rangeOfString:@&quot;liangjing&quot;]; [mStr insertString:@&quot;_&quot; atIndex:insRange.location]; NSLog(@&quot;mStr = %@&quot;, mStr); // mStr = chen_liangjing 替换字符串123456789101112131415// 调用父类 NSString 的替换字符串方法，返回一个新的字符串，不修改原来的字符串NSString *newStr = [mStr stringByReplacingOccurrencesOfString:@"_" withString:@""];NSLog(@"mStr = %@, newStr = %@", mStr, newStr); // chen_liangjing, newStr = chenliangjing // 调用 NSMutableString 的替换方法NSRange repRange = [mStr rangeOfString:@"_liangjing"]; // OccurrencesOfString: 需要替换的字符串// withString: 用什么字符串替换// options: 替换是的搜索方式// range: 搜索的范围// 返回值: 表示替换了多少个字符串NSUInteger count = [mStr replaceOccurrencesOfString:@"_" withString:@"" options:0 range:repRange];NSLog(@"mStr = %@", mStr); // mStr = chenliangjingNSLog(@"count = %ld", count); // count = 1 数组源码地址 1. NSArrayNSArray 基本概念 能存放任意 OC 对象，而且是有序的 不能存储非 OC 对象，比如 int\float\char\stuct 等 不可变。一旦初始化完毕，他里面的内容就永远是固定的，不能添加，删除里面的元素 创建方式+ (instancetype)array; + (instancetype)arrayWithObject:(ObjectType)anObject; + (instancetype)arrayWithObjects:(const ObjectType [])objects count:(NSUInteger)cnt; + (instancetype)arrayWithObjects:(ObjectType)firstObj, ... NS_REQUIRES_NIL_TERMINATION; // 通过一个数组来创建 + (instancetype)arrayWithArray:(NSArray&lt;ObjectType&gt; *)array; - (instancetype)initWithObjects:(ObjectType)firstObj, ... NS_REQUIRES_NIL_TERMINATION; - (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array; - (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array copyItems:(BOOL)flag; + (nullable NSArray&lt;ObjectType&gt; *)arrayWithContentsOfFile:(NSString *)path; + (nullable NSArray&lt;ObjectType&gt; *)arrayWithContentsOfURL:(NSURL *)url; - (nullable NSArray&lt;ObjectType&gt; *)initWithContentsOfFile:(NSString *)path; - (nullable NSArray&lt;ObjectType&gt; *)initWithContentsOfURL:(NSURL *)url; // 常用创建方式，字面量语法 NSArray *arr = @[@&quot;obj1&quot;, @&quot;obj2&quot;]; 常用方法1234567891011121314151617181920212223242526272829NSArray *arr = @[@"obj1", @"obj2"]; // 1. 获取数组中元素的个数NSUInteger arrCount = [arr count];NSLog(@"arrCount = %lu", arrCount); // arrCount = 2 // 2. 获取最后一个元素NSString *lastObj = [arr lastObject];NSLog(@"lastObj = %@", lastObj); // lastObj = obj2 // 3. 获取第一个元素NSString *firstObj = [arr firstObject];NSLog(@"firstObj = %@", firstObj); // firstObj = obj1 // 4. 获取数组中指定位置的元素NSString *obj = [arr objectAtIndex:1];NSLog(@"obj[1] = %@", obj); // obj[1] = obj2// 5. 数组中是否包含某一个元素NSString *obj3 = @"obj3";BOOL flag = [arr containsObject:obj3];if (flag)&#123; NSLog(@"arr 中包含 %@", obj3);&#125;else&#123; NSLog(@"arr 中不包含 %@", obj3); // arr 中不包含 obj3&#125; 简写(推荐方式)// 1. 数组简写 NSArray *simpleArr = @[@&quot;zhangsan&quot;, @&quot;lisi&quot;, @&quot;wangwu&quot;, @15, @&quot;30&quot;]; // 2. 获取指定位置的数组中元素 id o = simpleArr[3]; NSLog(@&quot;o = %@&quot;, o); // o = 15 NSArray 遍历12345678910111213141516171819202122232425262728 NSArray *arr = @[@"zhangsan", @"lisi", @"wangwu"]; // 1. 常规遍历for (int i = 0; i &lt; arr.count; i ++ )&#123; NSLog(@"arr[%i] = %@", i, arr[i]);&#125; // 2. 增强 for 循环// 逐个取出 arr 中的元素，将元素赋值给 objfor (NSString *str in arr)&#123; NSLog(@"str = %@", str);&#125; // 3. 使用数组迭代器遍历(推荐使用)// 每取出一个元素就会调用一次block// 每次调用 block 都会将当前取出的元素和元素对应的索引传递出来// obj 就是当前取出的元素，idx 就是当前元素的对应索引// stop 用于控制什么时候停止遍历[arr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if (idx == 1) &#123; // 停止遍历 *stop = YES; &#125; NSLog(@"idx = %lu, obj = %@", idx, obj);&#125;]; 给 NSArray 中所有对象发消息Person *p1 = [Person new]; p1.food = @&quot;food1&quot;; Person *p2 = [Person new]; p2.food = @&quot;food2&quot;; Person *p3 = [Person new]; p3.food = @&quot;food3&quot;; Person *p4 = [Person new]; p4.food = @&quot;food4&quot;; NSArray *arr = @[p1, p2, p3, p4]; // 如果使用 OC 数组存储对象，可以调用数组的方法给数组中所有的元素都执行指定的方法 // selector: 要执行的方法 // withObject:方法的参数 [arr makeObjectsPerformSelector:@selector(eatWithFood:) withObject:@&quot;food&quot;]; 注意：如果数组中保存的不是相同类型的元素，并且没有相同的方法，那么程序运行会报错。 数组排序方法一：只能用于 OC 对象// compare: 排序方法只能用在数组中所有元素是 OC 对象时才能使用，如果数组中的对象时非 OC 对象，那么程序会运行报错 NSArray *newArr = [arr sortedArrayUsingSelector:@selector(compare:)]; NSLog(@&quot;newArr = %@&quot;, newArr); // newArr = (2, 3, 5, 10, 20, 100) 方法二：可用于自定义对象12345678910111213141516171819Person *p1 = [Person new];p1.age = 35;Person *p2 = [Person new];p2.age = 15;Person *p3 = [Person new];p3.age = 45;Person *p4 = [Person new];p4.age = 5; NSArray *arr2 = @[p1, p2, p3, p4];NSLog(@"arr2.age = %@", arr2); // 该排序方法默认会按照升序排序NSArray *newArr2 = [arr2 sortedArrayUsingComparator:^NSComparisonResult(Person *obj1, Person *obj2) &#123; // 每次调用该 block 都会取出数组中的两个元素出来 // 二分排序 return obj1.age &gt; obj2.age;&#125;];NSLog(@"newArr2 = %@", newArr2); NSArray 和 NSString 转换// 1. 将 NSArray 中的元素按照某个连接符拼接成一个字符串 NSArray *arr = @[@&quot;zhangsan&quot;, @&quot;lisi&quot;, @&quot;wangwu&quot;]; NSString *result = [arr componentsJoinedByString:@&quot;_&quot;]; NSLog(@&quot;result = %@&quot;, result); // result = zhangsan_lisi_wangwu // 2. 通过字符串中的某一个连接符截取出一个字符串数组，字符串切割 NSArray *newArr = [result componentsSeparatedByString:@&quot;_&quot;]; NSLog(@&quot;newArr = %@&quot;, newArr); // ewArr = (zhangsan, lisi, wangwu) NSArray 文件读写12345678910// 1. 将数组写入到文件中NSArray *arr = @[@"zhangsan", @"lisi", @"wangwu"]; // 如果将一个数组写入文件中，本质是写入了一个 XML 文件，一般情况下，会将 XML 文件的扩展名保存为 plist，因为比较方便查看bool flag = [arr writeToFile:@"/Users/chenliangjing/Desktop/temp.plist" atomically:YES];NSLog(@"flag = %i", flag); // 2. 从文件中读取一个数组NSArray *getArr = [NSArray arrayWithContentsOfFile:@"/Users/chenliangjing/Desktop/temp.plist"];NSLog(@"getArr = %@", getArr); // getArr = (zhangsan, lisi, wangwu) 注意：writeToFile:只能写入数组中保存的元素都是 Foundation 框架中的类创建的对象，如果保存的是自定义对象，那么不能写入。 2. NSMutableArray源代码地址 NSMutableArray 介绍 NSMutableArray 是 NSArray 的子类，是可变的数组，可以随时往里面增加，插入，删除，替换元素。 NSMutableArray 用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 1. 创建一个空数组NSMutableArray *arrM = [NSMutableArray array];NSLog(@"arrM = %@", arrM); // arrM = ( ) // 2. 添加元素[arrM addObject:@"zhangsan"];NSLog(@"arrM = %@", arrM); // arrM = (zhangsan)// 从指定数组中取出元素添加到 arrM 中[arrM addObjectsFromArray:@[@"lisi", @"wangwu"]];NSLog(@"arrM = %@", arrM); // arrM = (zhangsan, lisi, wangwu) // 把指定数组当做 arrM 中的一个元素添加[arrM addObject:@[@"lisi2", @"wangwu2"]];NSLog(@"arrM = %@", arrM); // arrM = (zhangsan, lisi, wangwu, (lisi2, wangwu2)) // 3. 插入元素// 往指定位置插入新元素[arrM insertObject:@"chenliangjing" atIndex:2];NSLog(@"arrM = %@", arrM); // arrM = (zhangsan, lisi, chenliangjing, wangwu, (lisi2, wangwu2)) // 插入一组数据，指定数组需要插入的位置，和要插入多少个元素NSIndexSet *set = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(2, 2)];[arrM insertObjects:@[@"A", @"B"] atIndexes:set];NSLog(@"arrM = %@", arrM); // arrM = (zhangsan, lisi, A, B, chenliangjing, wangwu, (lisi2, wangwu2)) // 4. 删除元素// 删除最后一个元素[arrM removeLastObject];NSLog(@"arrM = %@", arrM); // arrM = (zhangsan, lisi, A, B, chenliangjing, wangwu) // 从指定位置删除元素[arrM removeObjectAtIndex:4];NSLog(@"arrM = %@", arrM); // arrM = (zhangsan, lisi, A, B, wangwu) // 从指定的范围删除一个数组NSIndexSet *remSet = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(2, 2)];[arrM removeObjectsAtIndexes:remSet];NSLog(@"arrM = %@", arrM); // arrM = (zhangsan, lisi, wangwu) // 删除指定的元素[arrM removeObject:@"wangwu"];NSLog(@"arrM = %@", arrM); // arrM = (zhangsan, lisi) // 删除所有元素[arrM removeAllObjects];NSLog(@"arrM = %@", arrM); // arrM = ( ) // 5. 替换元素[arrM addObject:@"A"];[arrM replaceObjectAtIndex:0 withObject:@"B"];NSLog(@"arrM = %@", arrM); // // arrM = ( B ) // 6. 获取元素NSString *element = [arrM objectAtIndex:0];NSLog(@"element = %@", element); // element = B // 7. 简易用法// 获取NSString *element2 = arrM[0];NSLog(@"element2 = %@", element2); // element2 = B // 替换arrM[0] = @"C";NSLog(@"arrM[0] = %@", arrM[0]); // arrM[0] = C 字典源代码地址 1. NSDictionary 通过一个 key，能找到对应的 value NSDictionary 是不可变的，一旦初始化完毕，里面的内容就无法改变 字典创建12345678910// 1. 创建字典// key 和 value 是一一对应的NSDictionary *dic = [NSDictionary dictionaryWithObjects: @[@"chenliangjing", @"25"] forKeys: @[@"name", @"age"]];NSString *name = [dic objectForKey:@"name"];NSString *age = [dic objectForKey:@"age"];NSLog(@"name = %@, age = %@", name, age); // name = chenliangjing, age = 25 // 简易创建（推荐使用）NSDictionary *dic2 = @&#123;@"name" : @"chenliangjing", @"age" : @25&#125;;NSLog(@"dic2 = %@", dic2); // dic2 = &#123; age = 25; name = chenliangjing; &#125; 字典遍历NSDictionary *dic = @{@&quot;name&quot; : @&quot;chenliangjing&quot;, @&quot;age&quot; : @25, @&quot;height&quot; : @1.70}; // 迭代器 [dic enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) { NSLog(@&quot;key = %@, obj = %@&quot;, key, obj); }]; 字典文件读取1234567891011121314151617181920NSDictionary *dic = @&#123;@"name" : @"chenliangjing", @"age" : @25, @"height" : @1.70&#125;; // 1. 写入文件BOOL flag = [dic writeToFile:@"/Users/chenliangjing/Desktop/test.plist" atomically:YES];if (flag)&#123; NSLog(@"写入成功");&#125;else&#123; NSLog(@"写入失败");&#125; // 2. 从文件中读取NSDictionary *newDic = [NSDictionary dictionaryWithContentsOfFile:@"/Users/chenliangjing/Desktop/test.plist"];NSLog(@"newDic = %@", newDic); // newDic = &#123; age = 25; height = "1.7"; name = chenliangjing;&#125; 注意：字典和数组不一样，字典中保存的数据是无序的。 2. NSMutableDictionary源代码地址 1234567891011121314151617181920212223242526272829303132333435363738// 1. 创建一个空的字典NSMutableDictionary *mDic = [NSMutableDictionary dictionary];NSLog(@"mDic = %@", mDic); // mDic = &#123; &#125; // 2. 添加[mDic setObject:@"chenliangjing" forKey:@"name"];NSLog(@"mDic = %@", mDic); // mDic = &#123; name = chenliangjing; &#125; // 将字典中所有的键值对全部取出来添加到 mDic 中去[mDic setValuesForKeysWithDictionary:@&#123;@"age" : @25, @"height" : @1.70&#125;];NSLog(@"mDic = %@", mDic); // mDic = &#123; age = 25; height = "1.7"; name = chenliangjing;&#125; // 3. 获取NSString *name = mDic[@"name"]; // 推荐使用NSLog(@"name = %@", name); // name = chenliangjingNSNumber *height = [mDic objectForKey:@"height"];NSLog(@"height = %@", height); // height = 1.7 // 4. 删除// 通过 key 删除[mDic removeObjectForKey:@"name"];NSLog(@"mDic = %@", mDic); // mDic = &#123; age = 25; height = "1.7"; &#125; // 通过一个 key 的数组删除[mDic removeObjectsForKeys:@[@"height", @"age"]];NSLog(@"mDic = %@", mDic); // mDic = &#123; &#125;// 5. 修改[mDic setObject:@"zhangsan" forKey:@"name"];NSLog(@"mDic = %@", mDic); // mDic = &#123; name = zhangsan;&#125; // 通过 setObject: 给同名的 key 赋值，就可以覆盖掉以前的旧值[mDic setObject:@"lisi" forKey:@"name"];NSLog(@"mDic = %@", mDic); // mDic = &#123; name = lisi;&#125; // 通过字面量语法赋值mDic[@"name"] = @"wangwu";NSLog(@"mDic = %@", mDic); // mDic = &#123; name = wangwu;&#125; 注意事项：不能使用 @{} 来创建一个可变字典 注意事项：如果是不可变字典，那么 key 不能相同。如果是不可变字典出现了同名 key，那么后面的 key 对应的值不会被保存，如果可变数组出现了同名的 key，那么后面的值会覆盖掉前面的。 NSNumber源代码地址 12345678910111213141516171819202122232425int age = 25;float height = 1.70;BOOL isMale = YES; // 1. 将基本数据类型转换成对象类型NSNumber *ageN = [NSNumber numberWithInt:age];NSNumber *heightN = [NSNumber numberWithFloat:height];NSNumber *maleN = [NSNumber numberWithBool:isMale];NSLog(@"ageN = %@, heightN = %@, maleN = %@", ageN, heightN, maleN); // ageN = 25, heightN = 1.7, maleN = 1 // 2. 将对象类型转换成基本数据类型int ageT = [ageN intValue];float heightT = [heightN floatValue];BOOL isMaleT = [maleN boolValue];NSLog(@"ageT = %d, heightT = %f, isMaleT = %i", ageT, heightT, isMaleT); // ageT = 25, heightT = 1.700000, isMaleT = 1 // 3 .基本数据类型转成对象类型简写(推荐使用)NSNumber *intN = @29;NSNumber *doubleN = @29.897;NSNumber *boolN = @NO; // 注意：如果传入的是变量，需要将变量用 () 包装起来，如果传入的是常量， () 可以省略float temp = 24.89;NSNumber *floatN = @(temp);NSLog(@"intN = %@, doubleN = %@, boolN = %@, floatN = %@", intN, doubleN, boolN, floatN); // intN = 29, doubleN = 29.897, boolN = 0, floatN = 24.89 NSValue源代码地址 NSNumber 是 NSValue 的子类，但 NSNumber 只包装数值类型 NSValue 可以包装任意值 因此，可以将结构体包装成 NSValue 类型后，加入到 NSArray/NSDictionary 中去 1234567891011121314151617181920212223242526// 1. 包装常用结构体CGPoint point = CGPointMake(10.0, 20.0);NSValue *valueP = [NSValue valueWithPoint:point];NSArray *arr = @[valueP];NSLog(@"arr = %@", arr); // arr = ("NSPoint: &#123;10, 20&#125;") // 2. 包装自定义结构体typedef struct&#123; int age; char *name; double _height;&#125;Person; Person p = &#123;25, "chenliangjing", 17.0&#125;;// valueWithBytes: 接收一个指针，需要传递需要包装的结构体的变量的地址// objCType: 需要传递需要包装的数据类型NSValue *value = [NSValue valueWithBytes:&amp;p objCType:@encode(Person)];NSArray *arrV = @[value];NSLog(@"arrV = %@", arrV); // rrV = ("&lt;19000000 00000000 740f0000 01000000 00000000 00003140&gt;") // 从 value 中取出自定义的结构体变量Person result;[value getValue:&amp;result];NSLog(@"age = %d, name = %s, _height = %f", result.age, result.name, result._height); // age = 25, name = chenliangjing, _height = 17.000000 NSDate源代码地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1. 创建// date 方法创建的时期对象，对象中就保存了当前时间NSDate *now = [NSDate date];NSLog(@"now = %@", now); // 在 now 的时间基础上追加多少秒// NSDate *date = [now dateByAddingTimeInterval:8 * 60 * 60];// NSLog(@"date = %@", date); // 1.1 获取当前所处的时区NSTimeZone *zone = [NSTimeZone systemTimeZone];// 1.2 获取当前时区和指定时间的时间差NSInteger seconds = [zone secondsFromGMTForDate:now];NSDate *newDate = [now dateByAddingTimeInterval:seconds];NSLog(@"newDate = %@", newDate); // 2. 时间格式化// 创建时间格式化对象NSDateFormatter *fmt = [[NSDateFormatter alloc] init];// 指定时间的格式//yyyy : 年//MM : 月//dd : 日//HH : 时//mm : 分//ss : 秒// Z : 时区fmt.dateFormat = @"yyyy年MM月dd日 HH时mm分ss秒"; // 利用时间格式对象对时间进行格式化NSString *result = [fmt stringFromDate:[NSDate date]];NSLog(@"result = %@", result); // result = 2017年04月26日 21时43分14秒 // 3. 字符串转成时间对象NSString *str = @"2017年04月26日 21时43分14秒";NSDateFormatter *farmat = [[NSDateFormatter alloc] init]; // 注意：str 的时间格式要和指定的 dateFormat 保持一致farmat.dateFormat = @"yyyy年MM月dd日 HH时mm分ss秒";NSDate *date = [farmat dateFromString:str];NSLog(@"date = %@", date); // date = 2017-04-26 13:43:14 +0000 NSCalendar源代码地址 12345678910111213141516171819202122232425262728293031323334353637383940// 获取当前时间NSDate *now = [NSDate date];NSLog(@"now = %@", now); // 1. 日历NSCalendar *calendar = [NSCalendar currentCalendar];NSCalendarUnit type = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond; // 利用日历类从当前时间中获取单独的年、月，日，时，分，秒NSDateComponents *cmps = [calendar components:type fromDate:now];NSLog(@"year = %ld", cmps.year);NSLog(@"month = %ld", cmps.month);NSLog(@"day = %ld", cmps.day);NSLog(@"hour = %ld", cmps.hour);NSLog(@"minute = %ld", cmps.minute);NSLog(@"second = %ld", cmps.second); // 2. 比较两个时间之间的差值，比较相差多少年多少月多少日多少时多少分多少秒// 2.1 过去的一个时间NSString *str = @"2017年04月26日 21时43分14秒";NSDateFormatter *farmat = [[NSDateFormatter alloc] init]; // 注意：str 的时间格式要和指定的 dateFormat 保持一致farmat.dateFormat = @"yyyy年MM月dd日 HH时mm分ss秒";NSDate *date = [farmat dateFromString:str];NSLog(@"date = %@", date); // date = 2017-04-26 13:43:14 +0000 // 2.2 现在的一个时间NSDate *nowN = [NSDate date]; // 2.3 比较两个时间NSCalendar *calendarN = [NSCalendar currentCalendar];NSDateComponents *cmpsN = [calendarN components:type fromDate:date toDate:nowN options:0];NSLog(@"年：%ld, 月：%ld, 日：%ld, 时：%ld, 分：%ld, 秒：%ld", cmpsN.year, cmpsN.month, cmpsN.day, cmpsN.hour, cmpsN.minute, cmpsN.second); // 年：0, 月：0, 日：0, 时：0, 分：40, 秒：59 NSFileManager源代码地址 1. NSFileManager 类是单例1234// 1. NSFileManager 类是一个单例NSFileManager *manager1 = [NSFileManager defaultManager];NSFileManager *manager2 = [NSFileManager defaultManager];NSLog(@"manager1 = %p, manager2 = %p", manager1, manager2); // manager1 = 0x100205710, manager2 = 0x100205710 地址一样 2. 判断一个文件或者一个文件夹是否存在12345BOOL dirExist = [manager1 fileExistsAtPath:@"/Users/chenliangjing"];NSLog(@"dirExist = %i", dirExist); // dirExist = 1 ,文件夹存在 BOOL fileExist = [manager1 fileExistsAtPath:@"/Users/chenliangjing/Desktop/test.plist"];NSLog(@"fileExist = %i", fileExist); // fileExist = 0 ,文件不存在 3. 判断一个文件是否存在，并且判断它是否是一个文件夹12345BOOL dir = NO;// 返回值表示为：传入路径对应的文件或者文件夹是否存在// isDirectory：由于保存判断结果，如果是一个目录，那么就会给 dir 赋值为 YES，如果不是就赋值 NOBOOL flag = [manager1 fileExistsAtPath:@"/Users/chenliangjing/Desktop/test.plist" isDirectory:&amp;dir];NSLog(@"flag = %i, dir = %i", flag, dir); // flag = 1, dir = 0，文件存在，但不是一个文件夹 4. 获取文件或者文件夹的属性1234// 获取文件或者文件夹的属性NSFileManager *manager = [NSFileManager defaultManager];NSDictionary *info = [manager attributesOfItemAtPath:@"/Users/chenliangjing/Desktop/TempDir" error:nil];NSLog(@"info = %@", info); 5. 获取文件夹下所有的文件1234567891011121314151617181920// 创建文件管理对象NSFileManager *manager = [NSFileManager defaultManager]; // 1. 不包括子文件夹下面的文件// 注意：contentsOfDirectoryAtPath:方法只能获取当前文件下面的资源，而不能获取子文件夹下面的资源NSArray *contentArr = [manager contentsOfDirectoryAtPath:@"/Users/chenliangjing/Desktop/TempDir" error:nil];NSLog(@"contentArr = %@", contentArr); // 2. 包括子文件夹下面的所有文件// NSArray *contentAllArr = [manager1 subpathsAtPath: @"/Users/chenliangjing/Desktop/TempDir"];NSError *error = nil;NSArray *contentAllArr = [manager subpathsOfDirectoryAtPath: @"/Users/chenliangjing/Desktop/TempDir"error:&amp;error];if (error)&#123; NSLog(@"error = %@", error);&#125;else&#123; NSLog(@"contentAllArr = %@", contentAllArr);&#125; 6. 创建文件夹123456789// 创建文件夹NSFileManager *manager = [NSFileManager defaultManager]; // DirectoryAtPath: 文件夹创建的位置// withIntermediateDirectories: 如果指定的文件夹中有一些文件夹不存在，是否自动创建不存在的文件夹// attributes: 指定创建出来的文件夹的属性// error: 是否创建成功，如果失败会给传入的参数赋值// 注意：该方法只能创建文件夹，不能用来创建文件[manager createDirectoryAtPath:@"/Users/chenliangjing/Desktop/chenlj" withIntermediateDirectories:YES attributes:nil error:nil]; 7. 创建文件12345678910111213141516171819202122// 创建文件NSFileManager *manager = [NSFileManager defaultManager]; // 创建二进制数据NSString *contentStr = @"chenliangjing";NSData *data = [contentStr dataUsingEncoding:NSUTF8StringEncoding]; // createFileAtPath: 指定文件创建出来的位置// contents: 文件中的内容// attributes: 创建处理文件的属性// 该方法只能创建文件，不能用来创建文件夹BOOL flag = [manager createFileAtPath:@"/Users/chenliangjing/Desktop/TempDir/chenlj.txt" contents:data attributes:nil];if (flag)&#123; NSLog(@"创建成功"); NSString *content = [NSString stringWithContentsOfFile: @"/Users/chenliangjing/Desktop/TempDir/chenlj.txt" encoding:NSUTF8StringEncoding error:nil]; NSLog(@"content = %@", content); // content = chenliangjing&#125;else&#123; NSLog(@"创建失败");&#125; 常用结构体源代码地址 12345typedef CGPoint NSPoint;typedef CGSize NSSize;typedef CGRect NSRect; NSPoint 等于 CGPoint NSSize 等于 CGSize NSRect 等于 CGRect 123456789// 保存坐标CGPoint point = CGPointMake(10.0, 20.0); // 保存尺寸CGSize size = CGSizeMake(100.0, 100.0); // 保存坐标和尺寸CGRect rect = CGRectMake(point.x, point.y, size.width, size.height);NSLog(@"rect = %@", NSStringFromRect(rect)); // rect = &#123;&#123;10, 20&#125;, &#123;100, 100&#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Objective-C 2.0》读书笔记（第二章：对象、消息、运行时）]]></title>
    <url>%2F2017%2F04%2F20%2F%E3%80%8AEffective-Objective-C-2-0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E3%80%81%E6%B6%88%E6%81%AF%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言正在读《Effective Objective-C 2.0》这本书，这本书主要介绍了一些使用 Objective-C 语言编写代码方面的 52 个有效方法，并且介绍了相应的原理。准备按章节写下读书笔记，并贴出实际的验证代码。 《Effective Objective-C 2.0》读书笔记（第一章：熟悉 Objective-C） 《Effective Objective-C 2.0》读书笔记（第二章：对象、消息、运行时） 《Effective Objective-C 2.0》读书笔记（第三章：接口与 API 设计） 《Effective Objective-C 2.0》读书笔记（第四章：协议与分类） 《Effective Objective-C 2.0》读书笔记（第五章：内存管理） 《Effective Objective-C 2.0》读书笔记（第六章：block 与 GCD） 《Effective Objective-C 2.0》读书笔记（第七章：系统框架） 对象对象是使用 Objective-C 编程使用的基本构造单元，通过对象用来存储和传递数据。 消息在对象之间传递数据并执行任务的过程叫做消息传递（Messaging）。 运行时应用程序运行后，为应用程序提供相关支持的代码叫做 Objective-C runtime。运行时提供了一些让对象之间能够传递消息的重要函数，并且包含创建实例所用的全部逻辑。 理解”属性“概念属性用于封装对象中的数据。 在对象内部尽量直接访问实例变量理解对象“等同性”概念特定类所具有的等同性判定方法等同性判断的执行深度容器中可变类的等同性使用“类簇模式”隐藏实现细节创建类簇Cocoa 里面的类簇在既有类中使用关联对象存放自定义数据关联对象用法举例objc_msgSend 的作用消息转发机制动态方法解析备援接收者完整的消息转发动态方法解析举例使用 method swizzling 调试“黑盒方法”类对象的用意在类继承体系中查询类型信息]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链式编程实现一个简易计算器]]></title>
    <url>%2F2017%2F04%2F16%2F%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[链式编程优点 使用点语法调用，代码优雅，可读性强。 链式编程特点 模仿 getter 方法写法，使得支持点语法调用 让 block 当做 getter 方法返回值，其中 block 的返回值为对象本身，这样才能实现连续的点语法调用。 调用效果 一行代码实现整个计算过程。 实现过程 NSObject (CalculatorManager) 分类 1234567891011121314151617/** 链式调用 @param calculator void(^)(CalculatorManager *manager) 类型 block @return 返回计算的结果 */+ (double)makeCalculator:(void(^)(CalculatorManager *manager))calculator;&#123; // 1. 创建 CalculatorManager 对象实例 CalculatorManager *cal = [[CalculatorManager alloc] init]; // 2. 调用block calculator(cal); // 3. 返回计算结果 return cal.equal();&#125; CalculatorManager 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@implementation CalculatorManager&#123; double _result;&#125;/// 加法- (CalculatorManager *(^)(double value))add&#123; return ^CalculatorManager * (double value)&#123; _result += value; return self; &#125;;&#125;/// 减法- (CalculatorManager *(^)(double value))minus&#123; return ^CalculatorManager * (double value)&#123; _result -= value; return self; &#125;;&#125;/// 乘法- (CalculatorManager *(^)(double value))multiply&#123; return ^CalculatorManager * (double value)&#123; _result *= value; return self; &#125;;&#125;/// 除法- (CalculatorManager *(^)(double value))divide&#123; return ^CalculatorManager * (double value)&#123; _result /= value; return self; &#125;;&#125;/// 返回计算结果- (double (^)())equal&#123; return ^double&#123; return _result; &#125;;&#125;@end 源码地址]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-c</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-c</tag>
        <tag>链式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 语言基础（四、Category&Extension&Block&Protocol）]]></title>
    <url>%2F2017%2F04%2F10%2FObjective-C%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%E3%80%81Category%26Extension%26Block%26Protocol%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Category1. Category 基本概念 Category 是 Objectvie-C 特有的语法，其他语言没有 Category 作用 可以在不修改原来类的基础上，为这个类扩充一些方法 一个庞大的类可以分模块开发 一个庞大的类可以有多个人编写，更有利于团队合作 2. Category 格式 在 .h 文件中声明类别 新添加的方法必须写在 @interface 和 @end 之间 ClassNme（现有类的类名，要为那个类扩充方法） + CategoryName (待声明的类别名称) NewMethod：先添加的方法 12345// Category 的声明@interface ClassName (CategroyName)NewMethod; // 在类别中添加方法// 不允许在类别中添加成员变量@end 在 .m 文件中实现类别 1234567// Category 的实现@implementation ClassName (CategoryName)NewMethod&#123; // 扩充的方法的实现&#125;@end 3. Category 注意事项 分类是用来给原有类添加方法，它只能添加方法，不能添加属性（成员变量） 分类中的 @property，只会生成 setter/getter 的声明，不会生成 setter/getter 的实现以及成员变量 可以在分类中访问原有类中 .h 中属性 如果分类中有和原有类同名的方法，会调用分类中的方法，会忽略掉原有类的方法，开发中要谨慎这样写代码。 如果多个分类中都有和原有类中同名的方法，那么调用该方法的时候会执行谁由编译器决定，会执行最后一个参与编译的分类中的方法。 分类中方法的调用顺序：分类 -&gt; 本类 -&gt; 父类 Extension1.什么是类扩展？ 延展类别，又称为扩展（Extension），Extension 是 Category 的一个特例 可以为某一个类扩充一些私有的成员变量和方法 写在 .m 文件中 英文名是 Class Extension 2. 类扩展的书写格式123@interface ClassName ()// 扩充成员变量和方法@end 对比分类，只是少了一个分类名称，因此也被称作“匿名分类”。 Block1. 什么是 Block？ Block 是 iOS 中一种比较特使的数据类型 Block 是苹果官方特别推荐使用的数据类型，应用场景广泛 动画 多线程 集合遍历 网络请求回调 Block 的作用 用来保存一段代码，可以在适当的时候再取出来调用 功能类似于函数和方法 2. Block 的格式#Block 的定义格式123返回值类型 (^blcok 变量名)(形参列表) = ^(形参列表) &#123; &#125;; #Block 和指向函数的指针很像12int (* sumP)(int, int) = sum;printf("%d" ,sumP(10, 20)); // print 30 区别：函数指针保存的是函数的地址，而 block 保存的是一段代码块。 #Block 的最简单格式，无参数无返回值12345678// 无参数无返回值 Blockvoid (^block 变量名称) () = ^&#123; 代码块; &#125;// 举例void (^block) () = ^&#123; NSLog(@"我是 block");&#125;;block(); // 我是 block #带有参数 Block 的定义和使用123456789// 格式void (^block 变量名) (形参列表) = ^(形参列表) &#123; 代码块; &#125;;// 举例void (^myBlock) (NSString *name, int age) = ^(NSString *name, int age) &#123; NSLog(@"name = %@, age = %d", name, age);&#125;;myBlock(@"陈良静", 25); // name = 陈良静, age = 25 #带有参数和返回值的 Block 的定义和使用12345678910// 格式返回值类型 (^block 变量名称)(形参列表) = ^ (形参列表) &#123; 代码实现; &#125;;// 举例int (^sumBlock)(int a, int b) = ^(int a, int b) &#123; NSLog(@"%d", a + b); return a + b; &#125;;// 调用 blocksumBlock(10, 20); // 30 #调用 block 保存的代码1block变量名(实参); #Block 和 typedef 给 Block 数据类型取别名 123456789// 格式typedef 返回值类型 (^ Block类型别名) (形参列表);// 举例typedef int (^calculator) (int, int);// 使用calculator sumBlock = ^(int a, int b) &#123; return a + b &#125;;// 调用 blocksumBlock(10, 20); // 30 注意：利用 typedef 给 block 取别名，和指向函数的指针一样，block 变量名称就是别名。 3. Block 的应用场景 当发现代码的前面和后面都是一样的时候，这个时候就可以使用 block 举个栗子：每天上班前和上班后做的事情都一样，只有上班的时候做的事情才不一样，这个场景就可以使用 Block 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void goWorkPrefix()&#123; NSLog(@"起床"); NSLog(@"跑步去上班"); NSLog(@"打开电脑");&#125;void goWorkSufix()&#123; NSLog(@"关闭电脑"); NSLog(@"收拾东西"); NSLog(@"跑步回家");&#125;void goWork(void (^workBlock)())&#123; // 上班前做的事情 goWorkPrefix(); // 上班中 workBlock(); // 下班前做的事情 goWorkSufix();&#125;void goWorkInDay1()&#123; goWork(^&#123; NSLog(@"认识新同事"); &#125;);&#125;void goWorkInDay2()&#123; goWork(^&#123; NSLog(@"熟悉项目"); &#125;);&#125;void goWorkInDay3()&#123; goWork(^&#123; NSLog(@"开发新需求"); &#125;);&#125;void goWorkInDay4()&#123; goWork(^&#123; NSLog(@"项目发布"); &#125;);&#125;// 调用goWorkInDay1();goWorkInDay2();goWorkInDay3();goWorkInDay4(); 4. Block 的注意事项#block 中可以访问外面的变量123456// 1. block 中可以访问外面的变量int a = 10;void (^myBlock)() = ^&#123; NSLog(@"%i", a);&#125;;myBlock(); // 10 #block 中可以定义和外界同名的变量 如果在 block 中定义了和外界同名的变量，在 block 中访问的是 block 中的变量 1234567// 2. block 中可以定义和外界同名的变量int a = 10;void (^myBlock)() = ^&#123; int a = 20; NSLog(@"%i", a);&#125;;myBlock(); // 20 #默认情况下，不可以在 block 中修改外界变量的值 原因：因为 block 中的变量和外界的变量并不是同一个变量。当 block 中访问到了外界的变量时，block 会将外界的变量拷贝一份到堆内存中。 所以，如果在调用之前修改外界变量的值，不会影响到 block 中的 copy 值。 #在 block 中修改外界变量的值 如果想在 block 中修改外界变量的值，必须在外界变量前面加上 __block 如果在 block 中修改了外界变量的值，会影响到外界变量的值。 123456789// 4. 在 block 中修改外界变量的值__block int a = 10;void (^myBlock)() = ^&#123; a = 20; NSLog(@"a = %i", a);&#125;;myBlock(); // 20// 在 block 中修改了外界变量的值，会影响到外界变量的值NSLog(@"a = %i", a); // 20 为什么不加 __block 不能修改外界变量的值？ 因为此时外界变量的传递方式是值传递。 为什么加了 __block 就可以在 block 中修改外界变量的值？ 因为此时外界变量的传递方式是地址传递。 #block 存储在堆中还是栈中？ 默认情况下，block 存储在栈中，如果对 block 进行一个 copy 操作，block 会转移到堆`中。 如果 block 存储在栈中，block 中访问了外界的对象，那么不会对对象进行 retain 操作。 如果 block 存储在堆中，block 中访问了外界的对象，会对外界的对象进行一次 reatin操作。 如果在 block 中访问了外界的对象，一定要给对象加上 __block，只要加上了 __block，不管 block 是在栈中还是在堆中，都不会对对象进行一次reatin操作。 Protocol1. Protocol 基本概念 Protocol 翻译过来，叫做“协议” 很像 java 中的接口（interface）概念，java 中的接口是一堆方法的声明，没有实现，而 Objective-C 中的 interface 是类头文件的声明，并不是真正意义的接口的意思，在 Objective-C 中，接口是由一个叫协议的 Protocol 实现的。 Protocol 可以声明一些必须实现的方法和选择实现的方法，和 java 中的接口是完全不同的。 Protocol 的作用 用来声明一些方法 一个 Protocol 是由一系列的方法声明组成的。 2. Protocol 语法格式 Protocol 的定义 123@protocol ProtocolName// 方法声明列表@end 类遵守协议 一个类可以遵守 1 个或者多个协议 任何类只要遵守了 Protocol，就相当于拥有了 Protocol 中的所有方法声明 123@interface ClassName : SuperClassName &lt;Procotol1, Procotol2, ...&gt; // 遵守多个协议@end 举个栗子 1234567891011// 定义协议@protocol SprotsProtocol &lt;NSObject&gt;// 声明协议方法- (void)playFootball;- (void)playBasketball;@end#import "SprotsProtocol.h" // 导入协议@interface Student : NSObject&lt;SprotsProtocol&gt; // 遵守协议@end 3. Protocol 和继承的区别 继承之后默认就有实现，而 Protocol 只有声明没有实现 相同类型的类可以使用继承，但不同类型的类只能使用 Protocol Protocol 可以用于存储方法的声明，可以将多个类中共同的方法抽取出来，以后让这些类遵守协议即可 4. Protocol 注意事项#注意事项 Protocol 只能声明方法，不能声明属性 如果父类遵守了某个协议，那么子类也会自动遵守这个协议。 Objective-C 中类可以遵守一个或者多个协议，但是继承只能单继承。 Objective-C 中的协议可以遵守其他协议，只要一个协议遵守了其他协议，那么这个协议中就会自动包含其他协议的声明。 123#import "OtherProtocol.h" // 导入其他协议@protocol SomeProtocol &lt;OtherProtocol&gt; // 遵守其他协议@end #基协议 NSObject 是一个基类，最根本最基本的类，任何其他类都要继承他 NSObject 也是一个协议，是一个基协议，最根本最基本的协议，默认通过 Xcode 模板创建的协议都遵守 NSObject 协议 NSObject 协议中声明了很多最基本的方法 description retain release 建议每个新的协议都要遵守 NSObject 协议 #@required 和 @optional 关键字 协议中有两个关键字可以控制方法是否要实现（默认是 @required，在大多数情况下，用途在于程序员之间的交流） @required：这个方法必须实现（若不实现，编译器会发出警告，但是并不能严格的控制某一个最受该协议的类必须要实现该方法）。 @optional：这个方法不一定要实现，可选 5. Protocol 应用场景#类型限定 可以将协议写在数据类型的右边，明确地标注如果想要给变量赋值，那么该对象必须遵守某个协议。 假设一个学校要招收学生，要求学生要会学习和考试，只有遵守了这两个条件的学生才能成为学校的学生。那么代码实现如下： 123456789101112@class Student; // 向前声明，引用 Student 类@protocol StudentCondition &lt;NSObject&gt;// 声明协议方法- (void)study;- (void)exam;@end@interface School : NSObject/// 学生，限定 student 需要遵守 StudentCondition 协议@property(nonatomic, strong) Student&lt;StudentCondition&gt; *student; 这时如果学生没有实现 StudentCondition 协议的话，那么就将会报警告 特别注意：就算 student 遵守了 StudentCondition 协议，但他却不一定实现了协议里面的方法，如果在 School 调用 Student 对象的协议方法时，需要加一层验证，验证 student 是否实现了协议中的方法。不然 student 如果没有实现协议方法，调用的话程序会崩溃。 12345678- (void)studentStudy&#123; // 每次在调用对象的协议方法时应该进行一次验证 if ([self.student respondsToSelector:@selector(study)]) &#123; [self.student study]; &#125; &#125; #代理设计模式 什么是设计模式？ 设计模式（design pattern）是一套被反复使用，多数人知晓、代码设计经验的总结。使用设计模式是为了可重用性代码，让代码更容易被他人理解，保证代码可靠性。 什么是代理设计模式？ 就是委托方不方便自己做一些事情，于是定义一个协议，让代理方去实现这个协议，帮助委托方做事情。 代理设计模式的场合： 当对象 A 发生了一些行为，想告知对象 B（让对象 B 成为对象 A 的代理） 对象 B 想监听 对象 A 的一些行为（让对象 B 成为对象 A 的代理） 当对象 A 无法处理某些行为的时候，想让对象 B 帮忙处理（让对象 B 成为对象 A 的代理） 代理设计模式举例：人通过中介找房子 Person 类: @class Person; @protocol PersonProtocol &lt;NSObject&gt; - (void)personFindHourse:(Person *)person; @end @interface Person : NSObject /// 代理 @property(nonatomic, strong) id&lt;PersonProtocol&gt; delegate; - (void)findHourse; @end @implementation Person - (void)findHourse { if ([self.delegate respondsToSelector:@selector(personFindHourse:)]) { [self.delegate personFindHourse:self]; } } @end 中介类 1234567891011121314151617@protocol PersonProtocol; @interface LinkHome : NSObject&lt;PersonProtocol&gt; @end #import "Person.h" @implementation LinkHome - (void)personFindHourse:(Person *)person&#123; NSLog(@"我们是链家房屋中介"); NSLog(@"%s", __func__);&#125;@end 调用 协议的编写规范 一般情况下，当前协议属于谁，就将协议定义到谁的头文件中 协议的名称一般以它属于的那个类的类名开头，后面跟上 protocol 或者 delegate 协议中的方法名一般以协议的名称（protocol 之前）的作为开头 一般情况下，协议中的方法会将触发该协议的对象传递出去 一般情况下，一个类中的代理属性的名称叫做 delegate 当某一个类要成为另外一个类的代理的时候，一般情况下在 .h 用 @protocol 协议名称告诉当前类这是一个协议，在 .m 文件中才真正的导入一个协议的声明。 1234567891011121314151617181920@protocol StudentCondition; // 在 .h 用 @protocol 协议名称告诉当前类这是一个协议@interface Student : NSObject&lt;StudentCondition&gt; // 遵守协议@end#import "School.h" // 在 .m 文件中才真正的导入一个协议的声明@implementation Student// 实现协议方法- (void)study&#123; NSLog(@"study:%s", __func__);&#125;- (void)exam&#123; NSLog(@"exam:%s", __func__);&#125; 源码地址CategoryBlockProtocol]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>Category</tag>
        <tag>Extension</tag>
        <tag>Block</tag>
        <tag>Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 语言基础（三、内存管理）]]></title>
    <url>%2F2017%2F04%2F08%2FObjective-C%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[内存管理1. 内存管理的重要性 移动设备的内存极其有限，每个 app 所能占用的内存是有限制的 下列行为都会增加一个 app 的内存占用 创建一个 Objective-C 对象 定义一个变量 调用一个函数或者方法 当 app 所占用的内存较多时，系统会发出内存警告，这时得回收一些不需要再使用的内存空间，比如回收一些不需要使用的对象，变量等 如果 app 内存占用过大，系统可能会强制关闭 app，造成闪退现象，影响用户体验 2. 什么是内存管理 如何回收那些不需要再使用的对象 内存管理，就是对内存进行管理，涉及的操作有 分配内存：比如创建一个对象，会增加内存占用 清除内存：比如销毁一个对象，会减小内存占用 内存管理的管理范围 任何继承了 NSObject 的对象 对其他非对象类型无效（int、char、float、double、struct、enum等） 只有对 Objective-C 对象才需要进行内存管理的本质原因 Objective-C 对象存放于堆里面 非 Objective-C 对象一般放在栈里面（栈内存会被系统自动回收） 3. 堆和栈 栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈（先进后出）。 堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由系统回收，分配方式类似于链表。 举例 12345678910111213141516int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int a = 10; // 局部变量：栈 int b = 10; // 局部变量：栈 // p（局部变量） ：栈 // Person 对象（计数器 = 1）：堆 Person *p = [[Person alloc] init]; &#125; // 出了 &#125; 号，栈里面的变量 a/b/p 都会被回收 // 但是堆里面的 Person 对象还会留在内存中，因为他的计数器依然是 1 return 0;&#125; 3. 引用计数器#什么是引用计数 系统是如何判断什么时候需要回收一个对象所占的内存？ 通过对象的引用计数器 什么是引用计数器？ 每个 Objective-C 独享都有自己的引用计数器 引用计数器是一个整数 从字面上理解，表示“对象被引用的次数” 也可以理解为：表示有多少人正在使用这个对象 #引用计数器的作用 引用计数器表述有多少人正在使用这个对象 当没有任何人使用这个对象时，系统才会回收这个对象 即当对象的引用计数器为 0 时，对象占用的内存会被系统回收 如果对象的引用计数器不为 0，那么在整个程序运行过程中，它占用的内存就不可能被回收（除非整个程序已经退出） 任何一个对象，刚出生的时候，引用计数器都为 1 当使用 alloc/new/copy/mutableCopy 创建一个对象时，对象的引用计数器就是 1 #引用计数器的操作 管理对象所占用的内存，就是再操作对象的引用计数器 引用计数器常见操作 给对象发送一条 retain 消息，引用计数器 +1（retain 方法返回对象本身） 给对象发送一条 release 消息，引用计数器 -1 给对象发送一条 retainCount 消息，可以获得对象当前的引用计数器值 需要注意：release 并不代表销毁/回收对象，仅仅是将引用计数器 -1 4. dealloc 当一个对象的引用计数器为 0 时，这个对象即将被销毁，其占用的内存被系统回收 当对象即将被销毁时，系统会自动给对象发送一条 dealloc 消息（因此，从 delloc 方法有没有被调用，就可以判断出对象是否被销毁） dealloc 方法的重写 一般会重写 dealloc 方法，在这里释放相关的资源，dealloc 是对象的遗言 一旦重写了 dealloc 方法，就必须调用 [super dealloc] 方法，并且在最后面调用 5. 单个对象内存管理 一个 alloc 对应一个 release 一个 retain 对应一个 release ARC 不同与 Java 的垃圾回收机制（gc），ARC 是编译器做的事情， Java 的垃圾回收是系统做的事情。 6.野指针和空指针#野指针 只要一个对象被释放了，就称这个对象为“僵尸对象” 当一个指针指向一个僵尸对象，就称这个指针为“野指针” 只要给一个野指针发送消息就会报错 #Xcode 中监听僵尸对象Xcoder-&gt;Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Diagnostics-&gt;Zombie Objects #空指针 空指针：nil 0 为了避免给野指针发送消息会报错，一般情况下，当一个对象被释放后会将这个对象的指针设置为空指针，因为 Objective-C 中给空指针发送消息是不会报错的。 1p = nil; 7. 多对象内存管理 Objective-C 中不可避免的存在多个对象之间的内存管理，举个栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@interface Room : NSObject@property int roomNo;@end@implementation Room- (void)dealloc&#123; NSLog(@"%s", __func__); [super dealloc];&#125;@end@interface Person : NSObject&#123; Room *_room;&#125;- (void)setRoom:(Room *)room;- (Room *)room;@end@implementation Person- (void)setRoom:(Room *)room&#123; _room = room;&#125;- (Room *)room&#123; return _room;&#125;- (void)dealloc&#123; NSLog(@"%s", __func__); [super dealloc];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Room *r = [[Room alloc] init]; r.roomNo = 1111; Person *p = [[Person alloc] init]; p.room = r; [r release]; [p release]; &#125; return 0;&#125; 上面代码里面有两个类。 Person 类和 Room 类，Person 类拥有房间，做这个两个对象之间的内存管理要满足两个条件： 人需要使用房间，那么只要人在房间就一定要在 人不在了，房间也要不在； 要满足上述第一个个条件，就得在 Person 的 _room 的 setter 方法中对每一次传入的 room 引用计数器加 1 操作，要满足第二个条件，就得在 Person 的 dealloc 方法中，对 “_room” 做引用计数器减 1 操作： 123456789101112131415- (void)setRoom:(Room *)room&#123; // 对房间的引用计数器 +1 [room retain]; _room = room;&#125;- (void)dealloc&#123; NSLog(@"%s", __func__); // 人释放了，那么房间也需要释放 [_room release]; [super dealloc];&#125; 当 A 对象想使用 B 对象时，一定要对 B 对象进行一次 retain，这样才能保证 A 对象存在 B 对象就层，也就是说这样才能保证无论在什么时候在 A 对象中都可以使用 B 对象。 当 A 对象释放的时候，一定要对 B 对象进行一次 release，这样才能保证 A 对象释放了， B 对象对应也会随之是否，避免内存泄漏。 总之，对象引用计数器的加和减总是一一对应的，有加就有减。 8. set 方法内存管理上述对多对象的内存管理还不完善，如果人需要换房间，那么又会出现内存泄漏： 问题的原因是：换房的时候，Person 的成员变量 _room 由房间 1111 指向 8888，没有指向房间 1111 了，但是却没有对房间 1111 引用计数器减一操作，所以导致最终房间 1111 没有被释放，导致内存泄漏。 解决方法：每一次换房之前，都应该对以前的房间引用计数器减 1 123456789- (void)setRoom:(Room *)room&#123; // 将以前的房间释放掉 _room release]; // 对房间的引用计数器 +1 [room retain]; _room = room;&#125; 上述内存管理方案还不够完善，如果出现重复赋值时，即又给人一间 1111 的房间，应用程序将会崩溃，崩溃原因是野指针异常。具体原因是，由于人原本就拥有一间 1111 的房间，即对房间 1111 有一个引用，当再次给人赋值 1111 房间时，先会对 1111 房间 release 一次，release 完 1111 房间引用计数器变为 0，称为僵尸对象，然后又要对整个僵尸对象进行 retain 操作，给僵尸对象发送消息，程序崩溃。 解决方案：在每一个给 Person 的 _room 赋值之前，先判断新值是否和旧值一样，如果一样，什么都不做，如果不一样，才需要 release 旧值，retain 新值。 12345678910111213- (void)setRoom:(Room *)room&#123; // 判断旧值和新值是否一样 if (_room != room) &#123; // release 旧值 [_room release]; // retain 新值 // retain 方法即让对象的引用计数器加 1，同时会返回当前对象 _room = [room retain]; &#125;&#125; 9. property 修饰符1. 控制 set 方法的内存管理 retain：release 旧值，retain 新值（用于 Objective-C 对象），自动生成 getter/setter 方法内存管理代码 assign：直接赋值，不做任何内存管理（默认，用于非 Objective-C 对象），不会生成 set 方法内存管理代码，仅仅只会生成普通的 getter / setter copy：release 旧值，copy 新值（一般用于 NSString *） 2. 控制需不需要生成 set 方法 readwrite：同事生成 set 方法和 get 方法（默认） readonly：只会生成 get 方法 3. 多线程管理 atomic：线程安全，性能低（默认） nonatomic：非线程安全，性能高 4. 控制 set 方法和 get 方法的名称 setter：设置 set 方法名称，一定有一个冒号： getter：设置 get 方法名称 注意：不同类型的参数可以组合在一起使用。 10. @class 作用 可以简单的引用一个类 简单实用 @class Person; 仅仅是告诉编译器，Person 是一个类，并不会包含 Person 这个类的所有内容 具体使用 在 .h 文件中使用 @class 引用一个类 在 .m 文件中使用 #import 包含这个类的 .h 文件 其他应用场景 解决循环引用，比如 A 类引用 B 类，B 类同时引用 A 类 和 #import 的区别 import 是一个预编译指令，会将 &quot;&quot; 中的文件拷贝到 import 所在的位置，并且只要 &quot;&quot; 中的文件发生了变化，那么 import 就会重新拷贝一次（更新操作） @class 仅仅是告诉编译器，@class 后面的名称是一个类，不会做拷贝操作。所以编译器并不知道这个类中有哪些属性和方法，所以在 .m 文件中使用这个类的时候需要 import 这个类，才能使用。 @class 好处 编译效率更快 解决两个类相互拷贝形成的死循环 11. 循环 retain如果 A 对象要拥有 B 对象，而 B 对象有要拥有 A 对象，此时就会形成循环 retain 解决方案：不要让 A retain B，B 又 retain A，让其中一方不要做 retain 操作。 12. 集合中对象的内存管理 如果将一个对象添加到一个数组中，那么数组会对对象进行一次 retain 当数组对象释放后，会给数组中所有的对象发送一条 release 消息 当数组移除一个对象之后，会给对象发送一条 release 消息 autorelease1. autorelease 基本概念 autorelease 是一种致辞引用计数的内存管理方式，只要给对象发送一条 autorelease 消息，就会将对象放到一个自动释放池中，当自动释放池被销毁时，会对池子中的所有对象做一次 release 操作 注意：这里只是发送 release 消息，如果当时的引用计数依然不为 0，则该对象依然不会被释放。 autorelease 对象会返回对象本身 12Person *p = [[Person alloc] init];p = [p autorelease]; 调用完 autorelease 后，对象的引用计数器不变 123Person *p = [[Person alloc] init];p = [p autorelease];NSLog(@"%lu", [p retainCount]); // 1 autorelease 的好处 不用再关心对象的释放时间 不用再关心什么时候调用 release autorelease 的原理 autorelease 实际上只是把 release 的调用延迟了，对于每一个 autorelease，系统只是把该对象放入了当前的 autorelease pool 中，该 pool 中的所有对象都会被调用 release。 2. autorelease pool#autorelease pool 使用 iOS 5 以后 12345@autoreleasepool &#123; // 创建一个自动释放池 Person *p = [[[Person alloc] init] autorelease]; &#125; // 销毁自动释放池（会给池子中的所有对象发送一条 release 消息） iOS 5 以前 12345678// 创建自动释放池NSAutoreleasePool *autoPool = [[NSAutoreleasePool alloc] init]; Person *p = [[[Person alloc] init] autorelease]; // 销毁自动释放池[autoPool drain];// [autoPool release]; autorelease pool 的嵌套使用 自动释放池是以栈的形式存在 由于栈只有一个入口，所以调用 autorelease 永远会将对象放到栈顶的自动释放池 123456789@autoreleasepool &#123; // 栈底自动释放池 @autoreleasepool &#123; @autoreleasepool &#123; // 栈顶自动释放池 Person *p = [[[Person alloc] init] autorelease]; &#125; // 销毁自动释放池（会给池子中的所有对象发送一条 release 消息） Person *p = [[[Person alloc] init] autorelease]; &#125;&#125; #autorelease pool 注意事项 一定要在自动释放池中调用 autorelease，才会将对象放入自动释放池中 自动释放池中不适宜放占用内存较大的对象 尽量避免对大内存使用该方法，对于这种延迟释放机制，还是尽量少用 不要把大量循环操作放到同一个 @autorelease 之间，这样会造成内存峰值的上升 一个 alloc / new 对应一个 autorelease 或者 release，不要写多次 autorelease/release。 #autorelease pool 应用场景 类工厂方法 1NSArray *array = [NSArray array]; 内部实现是： 1NSArray *array = [[[NSArray alloc] init] autorelease]; 1234+ (instancetype)person&#123; return [[[self alloc] init] autorelease];&#125; ARC1.ARC 基本概念#什么是 ARC Automatic Reference Counting，自动引用计数，即 ARC。ARC 是 LLVM 3.0 编译器的一项特性，使用 ARC，基本一举解决了手动内存管理的麻烦问题。 在工程中使用 ARC 非常简单，只需要和往常一样编写代autorelease码，只不过不用写 retain，release 三个关键字，这是 ARC 的基本原则。 当开启 ARC 是，编译器将自动在代码合适的地方插入 retain，release，autorelease，而作为程序员，完全不用担心编译器会做错。 #ARC 的注意点和有点 ARC 注意点 ARC 是编译器特性，不是运行时特性 ARC 不是其他语言中的垃圾回收，有本质的区别 ARC 的有点 完全消除了手动管理内存的繁琐，让程序员更加专注于 app 的业务 基本避免了内存泄漏 有时还能更加快捷，因为编译器还可以执行某些优化 #ARC 的判断原则 ARC 的判断原则 只有要有一个强指针变量指向对象，对象就会保存在内存中 强指针 默认所有的指针都是强指针 被 __strong 修饰的指针 12Person *p1 = [[Person alloc] init]; __strong Person *p2 = [[Person alloc] init]; 弱指针 被 __weak 修饰的指针 1__weak Person *p3 = [[Person alloc] init]; 2. ARC 中对多个对象内存管理#MRC A 对象想要拥有 B 对象，就需要对 B 对象进行一次 retain A 对象不用 B 对象了，需要对 B 对象进行一次 release（property 的时候 retain，dealloc 时候 release） #ARC A 对象想拥有 B 对象，就需要用一个强指针指向 B 对象 A 对象不用 B 对象了，什么都不需要做，编译器会自动做这些事情 在 ARC 中保存一个对象用 strong，相当于 MRC 中的 retain #循环引用 对象之间的相互引用，如 A 对象引用 B 对象， B 对象 引用 A 对象，在 ARC 中也会发生循环引用 解决方案 一边用 strong，一边用 weak，相当于 MRC 中的 assign 3. ARC 和 MRC 混编#MRC 转 ARC 在 ARC 环境下： target －&gt; build phases －&gt; compile sources －&gt; 单击MRC的文件将 compiler flags设置为：－fno－objc－arc 通过 Xcode，Edit -&gt; Refactor -&gt; Convert to Objective-C ARC #ARC 转 MRC 在 MRC 环境下： target －&gt; build phases －&gt; compile sources －&gt; 单击ARC的文件将compiler flags设置为：－fobjc-arc Copy源码地址 1. Copy 基本使用（深浅拷贝）#Copy 的基本概念 什么是 Copy 字面意思是复制，拷贝，是产生一个副本的过程 常见的复制：文件复制 作用：利用一个源文件产生一个副本文件 修改副本文件的内容，不会影响到源文件 Objective-C 中的 Copy 作用：利用一个源对象产生一个副本对象 特点 修改源对象的属性和行为，不会影响到副本对象 修改副本对象的属性和行为，不会影响源对象 #Copy 的使用 如何使用 copy 功能 一个对象可以调用 copy 或 mutableCopy 方法来创建一个对象 copy：创建的对象是不可变副本（如：NSString、NSArray、NSDictionary） mutableCopy：创建的对象是可变副本（如：NSMutableString、NSMutableArray、NSMutableDictionary） 使用 copy 的前提 copy：需要遵守 NSCopying 协议，实现 copyWithZone 方法 123@protocol NSCoping- (id)copyWithZone:(NSZone *)zone;@end 使用 mutableCopy 的前提 mutableCopy：需要遵守 NSMutableCoping 协议，实现 mutableCopyWithZone 方法 123@protocol NSMutableCoping- (id) mutableCopyWithZone:(NSZone *)zone;@end 几种情况分析 可变对象调用 copy 结论： 可变对象调用 copy 方法，会生成新的对象，并且新对象是不可变的。 可变对象调用 mutableCopy 结论： 可变对象调用 mutableCopy，会生成新的对象，并且新对象是可变的。 不可变对象调用 mutableCopy 结论： 不可变对象调用 mutableCopy，会生成新的对象，并且新对象是可变的。 不可变对象调用 copy 结论： 不可变对象调用 copy，不会生成新的对象，并且新对象是不可变的。 原因：因为原来的对象时不可变的，拷贝出来的对象也是不能修改的，既然两个都不能修改，所以永远也不能影响到另外一个对象，那么已经符合要求，Objective-C 为了对内存进行优化，所以就不会生成一个新的对象。 #深浅拷贝正是因为调用 copy 方法有时候会生成一个新的对象，有时候不会生成一个新的对象，所以：如果没有生成新的对象，则称为浅拷贝，本质就是指针拷贝，如果生成了新的对象，则称为深拷贝，本质就是会创建一个新的对象 只有源对象和副本对象都不可变时，才是浅拷贝，其他都是深拷贝。 2. Copy 的内存管理 如果是浅拷贝（源对象和副本对象都不可变），由于不会生成新的对象，所以系统会对源对象进行一次 retain。所以对源对象一次 copy 操作，就要相应的做一次 release 操作。 如果是深拷贝。真是因为生成了新的对象，所以系统不会对源对象进行 retain，但是因为生成了新对象，所以需要对新对象进行一次 release。 3. Copy 和 Property#修饰字符串类型 Copy 是 Property 中内存管理的关键字。主要修饰 NSString 类型的属性。作用：为了防止修改了外界变量，影响到了对象中的属性。 1@property(nonatomic, copy) NSString *name; #修饰 block 如果 block 存储在栈中，block 中访问了外界的对象，不会对对象进行一次 retain 操作 如果 block 存储在堆中，block 中访问了外界的对象，会对对象进行一次 retain 操作 修饰 block。可以使用 copy 来保存 block，这样可以让 block 中使用到的外界对象进行一次 retain 操作，避免以后调用 block 的时候，外界的对象已经释放了。（如果外界对象在调用 block 之前被释放了，那么程序就会崩溃） 12// 注意：如果是 block 使用 copy 并不是拷贝，而是转移，将栈中的 block 转移到 堆中去@property(nonatomic, copy) void (^myBlock)(); #copy block之后引发的循环引用 如果对象中的 block 又用到了对象自己，那么此时会产生循环引用，发生内存泄漏，为避免这种情况，应该将对象修饰为 __block。 4. 自定义类实现 Copy源码地址 自定义类实现 copy 操作 让类遵守 NSCopying 协议 实现 copyWithZone:方法，在该方法中返回一个对象的副本即可 在 copyWithZone:方法中，创建一个新的对象，并设置该对象的数据与现有对象一致，并返回该对象 #无父类实现12345678910111213141516@interface Person : NSObject&lt;NSCopying&gt; // 遵守 NSCopying 协议@property(nonatomic, copy) NSString *name;@end @implementation Person// 实现 copyWithZone:方法- (id)copyWithZone:(NSZone *)zone &#123; // 1. 创建一个新的对象 Person *p = [[[self class] alloc] init]; // 2. 设置当前对象内容给新对象 p.name = _name; // 3. 返回新对象 return p;&#125;@end #有父类实现如果想让子类在 copy 的时候保留子类的属性，那么必须重写copyWithZone: 方法，在该方法中，先调用父类创建副本设置值，然后再设置子类特有值 123456789101112131415@interface Student : Person@property(nonatomic, assign) CGFloat height;@end @implementation Student- (id)copyWithZone:(NSZone *)zone&#123; // 1. 调用父类创建副本设置值 id obj = [super copyWithZone:zone]; // 2. 设置数据给副本 [obj setHeight:_height]; // 3. 返回新对象 return obj;&#125;@end MatableCopy 和 Copy 实现类似，只要遵守 NSMutableCoping 协议，然后实现 mutableCopyWithZone:方法。]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 语言基础（二、面向对象）]]></title>
    <url>%2F2017%2F04%2F06%2FObjective-C%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[封装面向对象三大特性 封装性 继承性 多态性 什么是封装？ 封装性就是隐藏实现细节，仅对外公开接口 为什么要进行封装？ 如果没有封装，如果要访问成员变量，需要把成员变量声明为 public 的，也就是公开的，但是这样我们不能控制外界如何赋值，外界有可能赋值一些脏数据。 123Student *stu = [Student new];// 学生年龄不能为负数stu-&gt;_age = -10; 可以利用封装来解决这一问题。通过封装来隐藏对象的属性和实现的细节，仅对外提供公共的访问方法。 123456789101112131415161718192021222324252627282930313233343536@interface Student : NSObject&#123; @public int _age;&#125;- (void)setAge:(int)age;@end@implementation Student- (void)setAge:(int)age&#123; if (age &lt; 0) &#123; NSLog(@"学生年龄不能是负数"); return; &#125; else &#123; _age = age; &#125;&#125;@endint main(int argc, const char * argv[]) &#123; Student *stu = [Student new]; // 通过封装的 set 方法给成员变量赋值 [stu setAge:10]; NSLog(@"%zd", stu-&gt;_age); // 10 return 0;&#125; 类是数据与功能的封装，数据就是成员变量，功能就是类方法或者对象方法。 对数据的封装，就是对成员变量的封装。 不封装的缺点：当一个类把自己的成员变量暴露给外界的时候，那么该类就失去了对该成员变量的管理权，别人就可以任意的修改你的成员变量。 封装就是将数据隐藏起来，只能用此类的方法才可以读取或者设置数据，不可被外部任意修改是面向对象设计的本质，降低了数据被误用的可能性，提高代码的灵活性。 封装的好处？ 好处 将变化隔离 提高安全性 原则 将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共的方法对其访问。 getter 和 setter由于经常需要定义一些方法来操作成员变量，而每个方法都必须有一个有意义的名称，而大量的起名字很麻烦，所以就有了 getter 和 setter 方法。 getter 和 setter 方法的格式和写法都是固定的，所以有了 getter 和 setter 方法，就不用去想起名字的问题。同时，getter 和 setter 方法还是程序员之间交流的一种规范，以后被人只要想到给属性赋值就立刻会想到 getter 和 setter 方法，降低了程序员之间的沟通成本。 setter 方法 作用：设置成员变量的值，可以监听属性变化。 写法： setter 方法一定是对象方法 setter 方法一定没有返回值 一定以 set 开头并且 set 后面跟上跟上需要设置的成员变量的名称去掉下划线，并且首字母大写。 一定有参数，参数类型一定和需要设置的成员变量的类型一致，并且参数的名称就是成员变量去掉下划线。 123456789// setter 方法- (void)setAge:(int)age;// 实现- (void)setAge:(int)age&#123; // 成员变量以下划线开头的好处，用以区分局部变量和成员变量 _age = age;&#125; getter 方法 作用：获取成员变量的值 写法： getter 方法一定是对象方法 getter 方法一定有返回值，返回值类型一定和成员变量类型一致 方法名称就是获取的成员变量名称去掉下划线。 一定没有参数。 12345678// getter 方法- (int)age;// 实现- (int)age&#123; return _age;&#125; 只读属性 如果某一个属性只提供了 getter 方法没有提供 setter 方法，称这个属性为只读属性 只写属性 如果某一个属性只提供了 setter 方法没有提供 getter 方法，称这个属性为只写属性 可读可写属性 如果某一个属性既提供了 getter 方法又提供 setter 方法，称这个属性为可读可写属性 私有属性 如果某一个属性既没有提供了 setter 方法也没有提供 getter 方法，称这个属性为私有属性 点语法 如果给属性提供了 getter 方法和 setter 方法，那么访问属性就多了一种方式，点语法。 点语法其实本质是调用了 setter 方法和 getter 方法。 点语法是一个编译器特性，会在程序翻译成二进制的时候，点语法自动转换为 setter 和 getter 方法。 如果点语法在 = 号的左边，那么编译器会自动转换为 setter 方法 123// 给 age 赋值 stu.age = 10; // [stu setAge:10]; 如果点语法在 = 号的右边，那么编译器会自动转换为 getter 方法 1234// 获取 age 的值 int age = stu.age; // int age = [stu age] NSLog(@"%zd", age); // 10 注意：点语法用于给成员变量赋值，如果不是给成员变量赋值一般情况下不建议使用，但是也可以使用。 self 关键字 self 不能离开类，离开类之后没有任何意义。 如果 self 在类方法中调用，那么 self 就代表调用当前类方法的那个类 如果 self 在对象方法中调用，那么 self 就代表调用当前对象方法的那个对象 类方法中可以直接调用类方法 类方法中不可以直接调用对象方法 类方法中不能访问成员变量 注意：self 会自动区分类方法和对象方法，如果在类方法中使用 self 调用对象方法，那么会直接报错。 不能在对象方法或者类方法中利用 self 调用当前 self 所在的方法，会死循环。 继承继承基本概念 可以利用继承来解决重复代码的问题 只要 B 类集成了 A 类，那么 B 类就拥有 A 类所有的属性和方法 如所有的类都继承自 NSObject，那么所有的类都拥有 NSObject 类的所有属性和方法，如： new 方法，isa 属性。 继承语法： 1@interface Student : NSObject 继承的其他特点 Objective-C 中的继承关系 继承了某个类的类称为子类 被继承的类称为父类/超类 如果子类中有和父类中同名的方法，那么称为方法重写 继承的缺点 提高代码的复用性 可以让类与类之间产生关系，正是因为继承让类与类之间产生了关系所以才有了多态。 继承的缺点 耦合性太强 注意：继承中方法调用的顺序，如果子类自己有就先调用自己的方法，如果自己没有就调用父类的方法，如果父类也没有，就找父类的父类，一直往上找，如果找得到就调用，如果直到找到根类 NSObject，也没有找到相应的方法，那么程序就会报错。 具体过程描述是：首先一个类实例化，那么这个这个实例对象和类对象以及这个类所有的父类的类对象都会在堆中分配存储空间，当指向这个实例对象的指针给该实例对象发送消息时，先在堆内存中找到这个实例对象，再通过实例对象的 isa 指针找到这个类的类对象，先从这个类的类对象中找有没有这个方法，如果有，则执行，如果没有，继续往上找这个类的父类类对象，找到就执行，找不到就一直往上，如果一直找到根类 NSObject 都没有找到这个方法，那么应用程序就会报错。 注意：在继承中，父类的方法（类方法和对象方法）在子类中可以重写，但是属性（成员变量）不能重写。 多态父类指针可以指向子类 私有变量和私有方法私有变量实例变量（成员变量）既可以在 @interface 中定义，也可以在 @implementation 中定义。 写在 @implementation 中的成员变量，默认就是私有的成员变量，并且和利用 @private 修饰的不太一样，在 @implementation 中定义的成员变量在其他类中无法查看，也无法访问，在 @implementation 中定义的私有变量只能在本类中访问。 私有方法如果只有方法的实现，没有方法的声明，那么该方法就是私有方法。 注意：在 Objective-C 中，没有真正的私有方法，因为 Objective-C 是消息机制。是在运行时才会去找接收消息的接受者发送消息。 property &amp;&amp; synthesize在 Xcode 4.4 以前：#property 基本使用 @property 是一个编译器指令，可以简化 getter/setter 的声明。编译器只要看到 @property，就知道要产生某一个属性的 getter/setter 声明。 好处是：免去手工书写 getter/setter 方法繁琐的代码。 12345@property int age;// 相当于- (void)setAge:(int)age;- (int)age; #synthesize 基本使用 @synthesize 是一个编译器指令，可以简化 getter/setter 的实现。编译器只要看到 @synthesize，就知道要产生某一个属性的 getter/setter 实现。 在 @synthesize 后面告诉编译器需要实现那个 @property 生成的声明 告诉 @synthesize，需要告诉将传入的值赋值给谁和返回谁的值给调用者。 如果在 @synthesize 后面没有告诉系统将传入的值赋值给谁，系统默认会赋值给和 @synthesize 后面写的名称相同的成员变量。 123456789101112@synthesize age = _age;// 相当于- (void)setAge:(int)age&#123; _age = age;&#125;- (int)age&#123; return _age;&#125; 在 Xcode 4.4 以后： 在 Xcode 4.4 以后，苹果对 @property 进行了一个增强，以后只要利用 @property 就可以同时生成 setter/getter 方法的声明和实现。 如果没有告诉 @property 要将传入的参数赋值给谁，默认 @property 会将传入的参数赋值给_开头的成员变量。 @property 的弊端：@property 只会生成最简单的 getter/setter 方法，并不会对传入的值进行过过滤。如果想对闯入的数据进行过滤，就必须重写 getter/setter 方法。 如果重写了 setter 方法，那么 @property 就只会生成 getter 方法，同样，如果如果重写了 getter 方法，那么 @property 就只会生成 setter 方法。 如果利用 @property 来生成 setter/getter 方法，那么可以不写成员变量，系统会自动给我们生成一个_开头的成员变量。 如果同时重写了 setter/getter 方法，那么系统就不会生成_开头的成员变量。 @property 自动帮我们生成的成员变量是一个私有的成员变量，也就是说是在 .m 文件中生成的，而不是在 .h 文件中生成的。 123456789101112131415@property int age;// 相当于- (void)setAge:(int)age;- (int)age;// 实现- (void)setAge:(int)age&#123; _age = age;&#125;- (int)age&#123; return _age;&#125; #属性修饰符 格式：@property (属性修饰符) 数据类型 变量名称; 属性修饰符 readwrite：代表既生成 setter 方法，又生成 getter 方法。默认情况下，@property 的属性修饰符就是 readwrite readonly：代表只生成 getter 方法，不生成 setter 方法 getter = getter 方法名：代表生成的 getter 方法名使用后面的名称。一般情况下，获取 BOOL 类型的属性值，都会将获取的方法名改为 isXXX setter = setter 方法名：代表生成的 setter 方法名使用后面的名称 12345// 是否通过@property (getter=isPassed) BOOL passed;Student *stu = [Student new];BOOL passed = stu.isPassed; 动态数据类型静态类型和动态类型#静态类型 将一个指针变量定义为特定类对象时，使用的是静态类型，在编译的时候就知道这个指针变量所属的类，这个变量总是存储特定类的对象。 默认情况下，所有的数据类型都是静态数据类型，静态数据类型特点： 在编译的时候就知道变量的类型 知道变量中有哪些属性和方法 在编译的时候就可以访问这些属性和方法 如果通过静态数据类型定义变量，如果访问了不是静态数据类型定义的属性和方法，那么编译器将会报错 1Person *p = [Person new]; #动态类型 程序直到执行才确定对象所属的类，在编译的时候编译器并不知道变量的真实类型，只有在运行的时候才知道他的真实类型 如果通过动态数据类型定义变量，如果访问了不属于动态数据类型的属性和方法，编译器不会报错 通过动态数据类型定义的变量，可以调用子类特有的方法，而静态类型不行 通过动态数据类型定义的变量，还可以调用私用方法 1234567id obj = [Person new];// 1. 调用子类特有方法[obj eat];// 2. 调用私有方法[obj privateMethod]; 动态类型弊端：由于动态数据类型可以调用任意方法，所以有可能调用到不属于自己的方法，而编译时又不会报错，所以可能导致运行时错误 应用场景：多态。可以减少代码量，避免调用子类特有的方法需要强制类型转换 为什么要有动态类型？ NSObject 是 Objective-C 中的基类，任何对象的 NSObject 类型的指针都可以指向任何对象，但是如果 NSObject 是静态类型，如果通过它直接调用 NSObject 上面不存在的方法，编译器会报错。 id 是一个数据类型，并且是一个动态数据类型 作用 定义变量 作为函数的参数 作为函数的返回值 id 是一种通用的对象类型，他可以指向属于任何类的对象，可以理解为是“万能指针”，相当于 C 语言中的 void * 因为 id 是动态数据类型，所以可以通过 id 类型直接调用指向对象中的方法，编译器不会报错 注意 在 id 的定义中，已经包含了 * 号，id 指针只能指向 Objective-C 中的对象 为了尽可能的减少编程中的错误，Xcode 做了一个检查，当使用 id 类型调用本项目中所有类上都没有的方法，编译器会报错。 id 类型不能使用点语法，因为点语法是编译时特性，而 id 是运行时特性。 id 数据类型与静态类型 不要滥用这种通用类型 如果没有使用到多态尽量使用静态类型 静态类型可以更早的法相错误（在编译时而不是运行时） 静态类型能够提高程序的可读性 使用动态类型前最好知道其真实类型 动态类型判断 (BOOL)isKindOfClass:(Class)aClass 判断实例对象是否是这个类或者这个类的子类的实例 为了避免动态数据类型引发的运行时错误，一般情况下如果使用动态数据类型变量，在调用这个变量的方法之前会做一次判断，判断当前变量是否能够调用这个方法 12345678910111213id obj = [Student new];// 1. 判断指定对象是否是当前指定类或者他的子类 if ([obj isKindOfClass:[Student class]]) &#123; [obj eat]; &#125; // 或者 // 2. 判断指定对象是否是当前指定类的实例 if ([obj isMemberOfClass:[Student class]]) &#123; [obj eat]; &#125; new 实现原理 new 做了三件事情 开辟存储空间，+ (instancetype)alloc 类方法 初始化所有属性（成员变量）- (instancetype)init 对象方法 返回对象的地址 123NSObject *obj = [Student new];// 等价于NSObject *obj = [[Student alloc] init]; alloc 类方法做了什么事情 开辟存储空间 将所有的属性设置为 0 返回当前实例对象的地址 init 对象方法做了什么事情 初始化成员变量，但是默认情况下 init 的实现是什么都没有做 返回初始化后的实例对象的地址 注意：alloc 返回的地址和 init 返回的地址是同一个地址 构造方法构造方法基本概念#1. 重写 init 方法 想在对象创建完毕后，成员变量马上就有一些默认的值就可以重写 init 方法 重写 init 方法格式 123456789- (instancetype)init&#123; self = [super init]; if (self) &#123; // 初始化操作 &#125; return self;&#125; [super init] 的作用，面向对象的体现，先利用父类的 init 方法为子类实例的父类不分数线初始化 self 为什么要赋值为 [super init]：简单来说是为了防止父类的初始化方法 release 掉了 self 指向的空间并重新 alloc 了一块空间，还有 [super init] 可能 alloc 失败，这时就不要再执行 if 中的语句。 #2. instancetype 和 id 的区别 相同点：instancetype 和 id 都是万能指针，都可以指向一个对象 不同点： id 在编译时不能判断对象的真实类型，instancetype 在编译时可以判断对象的真实类型 id 可以用来定义变量，可以作为返回值，可以当做形参，instancetype 只能当做返回值来使用 注意：以后凡是自定义构造方法，返回值尽量使用 instancetype，不要使用 id 自定义构造方法 其实就是自定义一个 init 方法 一定是一个对象方法 一定返回 id / instancetype 方法名称一定以 init 开头 12Student *stu = [[Student alloc] initWithAge:25];NSLog(@"%i", stu.age); // 25 一个类可以有 0 个或者多个自定义构造方法 一个自定义构造方法可以有 1 个或者多个参数 自定义构造方法在继承中的表现原则：子类只负责初始化自己的成员变量，父类的成员变量初始化工作交给父类去完成 123456789101112131415- (instancetype)initWithAge:(int)age name:(NSString *)name&#123; // 交给父类去初始化 self = [super initWithAge:age]; if (self) &#123; _name = name; &#125; return self;&#125;Student *stu = [[Student alloc] initWithAge:25 name:@"chenlj"];NSLog(@"age=%i,name=%@", stu.age,stu.name); // age=25,name=chenlj 自定义构造方法及成员变量名称注意点 自定义构造方法中的 init 后面的 With 首字母必须要大写。 属性名称或者方法名称不要 new 开头，有可能会引发一些未知错误。 类工厂方法类工厂方法基本概念 什么是类工厂方法？ 用于快速创建对象的类方法，称为类工厂方法 类工厂方法主要用于给对象分配存储空间以及初始化这块存储空间 规范 一定是类方法 方法名称以类的名称开头，首字母小写 一定有返回值，返回值是 id/instancetype 123456789101112131415// 声明+ (instancetype)personWithAge:(int)age;// 实现+ (instancetype)personWithAge:(int)age&#123; // 注意：在自定义类工程方法时，在类工厂方法中创建的对象一定不要使用类名来创建，一定要使用 self Person *p = [self alloc] init]; // Person *p = [Person alloc] init]; p.age = age; return p;&#125;// 调用Person *p = [Person personWithAge:25]; 自定义类工厂方法是苹果的一个非凡，一般情况下，会给一个类提供自定义构造方法和自定义类工厂方法用于创建对象。 类工厂方法在继承中的注意点 在自定义类工程方法时，在类工厂方法中创建的对象一定不要使用类名来创建，一定要使用 self self 在类方法中代表类对象，谁调用这个类方法，self 就代表谁 类的本质及存储细节类的本质 类的本质其实也是一个对象（类对象） 程序中第一次使用该类的时候被创建，在整个程序中只有一份 伺候每次使用都是这个类对象，他在程序运行时一直存在 类对象是一种数据结构，存储类的基本信息：类大小，类名称，类的版本，继承层次，以及消息与函数的映射表等 类对象代表类，Class 类型，对象方法属于类对象 如果消息的接受者是类名，则类名代表类对象 所有类的实例都是由类对象生成，类对象会把实例的 isa 指针的值修改成自己的地址，每个实例的 isa 指针都指向该实例的类对象 假设有一个 Person 类 12345678910111213141516171819202122232425262728293031323334353637383940@interface Person : NSObject@property int age;// 对象方法- (void)instanceMethod;// 类方法+ (void)classMethod;@end@implementation Person// 对象方法- (void)instanceMethod&#123; NSLog(@"instanceMethod");&#125;// 类方法+ (void)classMethod&#123; NSLog(@"classMethod");&#125;@endint main(int argc, const char * argv[]) &#123; Person *p = [[Person alloc] init]; // 调用对象方法 [p instanceMethod]; // 调用类方法 [Person classMethod]; return 0;&#125; Person 类在内存中的表现是： #说明 程序一启动，就会将 Person 类加载到代码区，会调用类的 load 方法，当程序第一次使用 Person 类时，会在堆中创建 Person 类对象。类对象在程序运行时一直存在，并且在整个程序中只有一份。 对象方法保存在类对象中 类方法保存在元类对象中 所有实例对象都是通过类对象生成，类对象会把实例的 isa 指针的值修改成自己的地址。并且把类中的所有属性（成员变量）拷贝一份到实例变量。 #对象方法调用顺序首先创建一个实例对象，会在堆中给实例对象分配存储空间，然后将实例对象中的所有属性初始化为 0，最后返回实例对象的地址给指针变量 p。当发生对象方法调用时，指针变量 p 会先到堆中找到相应的实例变量的存储空间，然后通过实例变量的 isa 指针找到对应的类对象，找到类对象中对象方法列表中的相应的对象方法，最后执行。 #类方法调用顺序当类方法调用发生时，首先会去堆中找到相应的类对象，然后通过类对象中 isa 指针找到指向的元类对象，最后找元类对象中类方法列表中的相应的类方法，如果找到，执行，如果没有找到，继续向上找根元类对象（NSObject 元类对象）。 #对象模型图 所有类的“类对象”的继承关系就是“元类对象”的继承关系。这样便于方法的查找。首先实例对象的 isa 指针指向类对象，类对象的 isa 指针指向元类对象，元类对象的 isa 指针指向根元类对象，根元类对象的 isa 指针指向自己。其次在类对象中存储着对象方法，元类对象中存储着类方法。当一个子类要执行一个对象方法时，先到自己类对象中找，如果找到就执行，找不到就要去类对象的父类对象中找。同理，如果一个子类要执行一个类方法时，先到自己的元类对象中找，如果找到就执行，找不到就要去元类对象的父类元类对象中找。 如何获取类对象 &amp; 类对象的应用场景 通过实例对象获取 1格式：[实例对象 class]； 通过类名获取（类名其实就是类对象） 1格式：[类对象 class]; 类对象的应用场景 用于创建对象实例 用于调用类方法 1234567891011121314// 获取类对象// 1. 通过实例获取Class c1 = [p class];// 2. 通过类对象获取Class c2 = [Person class];NSLog(@"c1 = %p, c2 = %p", c1, c2); // c1 = 0x100001260, c2 = 0x100001260 // 类对象应用场景// 1. 用于创建实例对象Person *p2 = [[c1 alloc] init];p2.age = 25;NSLog(@"%i", p2.age); // 25// 2. 用于调用类方法[c1 classMethod]; // classMethod 类的启动过程12345678910111213141516// 只要程序启动就会将类的代码加载到内存中，放到代码区// load 方法会在当前类被加载到内存的时候调用，有且仅会调用一次// 如果存在继承关系，会先调用父类的 load 方法，再调用子类的 load 方法+ (void)load&#123; &#125;// 当前类第一次被使用时调用（创建类对象的时候）// initialize 方法在整个程序运行过程中只会调用一次，无论使用多少次真个类都只会调用一次// initialize 用于对某一个类进行一次性的初始化// 如果存在继承关系，会先调用父类的 initialize 方法，再调用子类的 initialize 方法+ (void)initialize&#123; &#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 语言基础（一、基础知识）]]></title>
    <url>%2F2017%2F04%2F06%2FObjective-C%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Objective-C 简介 Objective-C 是一门面向对象的计算机语言 Objective-C 是在 C 语言的基础上增加了一层面向对象的语法 Objective-C 完全兼容 C 语言 可以在 Objective-C 中混入 C 语言代码 可以使用 Objective-C 开发 Mac OS 平台和 iOS 平台的应用程序 C 和 Objective-C 比较1. 源文件对比 C 语言中常见源文件 .h 开头、.c 文件 文件扩展名 源类型 .h 头文件，用于存放函数声明 .c C 语言源文件，用于实现头文件中声明的方法 Objective-C 语言中源文件 .h 头文件、.m 与 .mm 实现文件 文件扩展名 | 源类型————- | ————-.h | 头文件，头文件包含类、方法、属性的声明.m/.mm | 类的实现文件，参与编译的文件，用来实现类中声明的方法 2. 关键字对比 C 语言关键字度可以在 Objective-C 源程序中使用 Objective-C 新增的关键字在使用时，注意部分关键字以@开头 3. 数据类型#C 语言数据类型 基本数据类型 整型 短整型：short 整型：int 长整型：long 字符型：char 实型（浮点型） 单精度：float 双精度：double 构造类型 数组 结构体 枚举 共用体 指针类型 空类型（Void） #Objective-C 语言数据类型 基本数据类型 整型 短整型：short 整型：int 长整型：long 布尔类型：BOOL 字符型：char 实型（浮点型） 单精度：float 双精度：double Block 类型 构造类型 数组 结构体 枚举 共用体 指针类型 类：class id 类型 空类型：Void 特殊类型：SEL、nil 类型 描述 BOOL 只有两个取值，真和假 NSObject * Objective-C 中对象类型 id 动态对象类型，万能指针 SEL 选择器数据类型 block 代码块数据类型 4. 流程控制语句#C 语言中使用的流程控制语句都可以在 Objective-C 语言中应用if 语句 switch 语句 while 语句 do while 语句 for 语句 break 语句 continue 语句 #增强 for 循环，用于快速迭代数组或者集合 C 语言 for 循环 1234for (int i = 0; i &lt; 10; i++)&#123; printf("%d", i);&#125; Objective-C 语言增强 for 循环 1234for (NSString *string in NSArray)&#123; NSLog(@"%@", string);&#125; 5. 函数（方法）定义和声明对比 C 语言中函数的声明和实现 函数声明：int sum(int a, int b); 函数实现：int sum（int a, int b）{ return a + b; } Objective-C 中的方法 方法声明：- (int)sum:(int)a andB:(int)b; 方法实现：- (int)sum:(int)a andB:(int)b { return a + b } 注意：方法只能写在类里面，而函数可以写在任何地方 对象方法：使用对象调用的方法 类方法：使用类名调用的方法 1234// 对象方法- (id)initWithString:(NSString *)name;// 类方法+ (MyClass *)creatMyClassWithString:(NSString *)name; 6. 面向对象新增特性 封装性 继承性 多态性 7. 面向对象新增语法 属性生成器 @property @synthesize 12345// 声明属性@property (nonatomic, strong) NSString *name;// 合成属性@synthesize name = _name; 分类 分类与集成 使用分类扩展类，无需子类化 12345@interface NSString (MyNSString)- (NSString *)encrypWithMD5;@end 协议 使用协议声明方法 协议类似于 C#，Java 中的接口 12345@protocol MyProtocol- (void) MyProtocolMethod;@end Foundation 框架 创建和管理集合，如数组和字典 访问存储在应用中的图像和其他资源 创建和管理字符串 发布和观察通知 创建日期和时间对象 操控 URL 流 异步执行代码 8. 新增异常处理 用于处理错误信息 格式： @try ….. @catch ….. @finally 示例 12345678910// 创建对象per Person *per = [Person new]; @try &#123; // 调用一个没有实现的方法 [per test]; &#125; @catch (NSException *exception) &#123; NSLog(@"%@", exception.name); &#125; @finally &#123; NSLog(@"继续执行\n"); &#125; include 和 import import 和 include 功能一样，是将右边的文件拷贝到当前 import 的位置 import 是一个预处理指令，会自动防止重复拷贝 类和对象 Objective-C 是一种面向对象的语言，定义类是他的基本能力 类是用来描述对象的，是一系列方法和属性的集合 Objective-C 的类声明和实现包括两个部分：接口部分和实现部分 想要定义方法，就必须先有类的存在 如何设计一个类 生活中描述事物，一般有名称/属性，行为 如：人有身高，体重等属性，有说话，吃饭等行为 123事物名称（类名）：人（Person）属性：身高（height），年龄（age）行为（功能）：说话（say），吃饭（eat） Objective-C 中用类来描述事物也是如此 属性：对应类中的成员变量 行为：对应类中的成员方法 定义类其实是在定义类中的成员（成员变量和成员方法） 如何分析一个类 一般名词都是类（名词提炼法） 飞机发射两颗炮弹摧毁了 8 辆装甲车 123飞机炮弹装甲车 拥有相同（或者类似）属性（状态特征）和行为的对象都可以抽象成为一个类 定义行为（方法）时注意：谁最清楚这个行为，那么该行为就属于谁 对象的内存存储细节首先定义一个类，Person 类，拥有属性：age，height，weight，方法：eat，sleep，walk。 1234567891011121314151617181920212223242526272829@interface Person : NSObject&#123; int _age; double _height; double _weight;&#125;- (void)eat:(char *)food;- (void)sleep;- (void)walk;@end@implementation Person- (void)eat:(char *)food&#123; NSLog(@"eat");&#125;- (void)sleep&#123; NSLog(@"sleep");&#125;- (void)walk&#123; NSLog(@"walk");&#125; 通过类创建对象 开辟存储空间，通过 new 方法创建对象会在堆内存中开辟一块存储空间 初始化所有属性 返回指针地址 创建对象的时候返回的地址其实就是类的第 0 个属性的地址，因为类对象的本质就是一个结构体，结构体的地址就是结构体中第 0 个属性的地址。但是类的第 0 个属性并不是当前 Person 类的第 0 个属性 _age，而是一个叫做 isa 的属性，isa 是一个指针，占 8 个字节。 其实类也是一个对象，也就意味着 Person 也是一个对象，平常所说的创建对象就是通过一个类对象来创建一个新的实例对象。类对象是系统自动帮我们创建的，里面保存了当前对象的所有方法，而实例对象是程序员手动创建的，实例对象中有一个 isa 指针，指向了那个创建他的类对象。 1Person *p = [Person new]; 在内存中的存储情况： 过程描述：首先程序启动，Person 类代码被加载进代码区， 系统会自动根据 Person 类代码在堆中分配存储空间创建一个 Person 类对象，里面保存着 Person 类所有的方法。 接着调用 new 方法，从 Person 类对象里面查找 new 方法，也是在堆中分配存储空间创建一个 Person 实例对象，实例对象默认的第 0 个属性就是一个 isa 指针，这个指针就是指向 Person 类对象，接着初始化 Person 类中的所有属性，其中isa 指针会被初始化为指向创建他的对象地址，初始化完成后返回 Person 实例对象 的地址，保存在栈中的指针变量 p。 局部变量&amp;&amp;全局变量&amp;&amp;成员变量局部变量 写在函数或者代码块中的变量，称为局部变量 作用域：从定义的那一行开始，一直到文件的末尾 局部变量可以先定义再初始化，也可以定义的同时初始化 存储：栈 存储在栈中的数据系统会自动释放 全局变量 写在函数和大括号外部的变量，称为全局变量 作用域：从定义的那一行开始，一直到文件的末尾 全局变量可以先定义再初始化，也可以定义的同时初始化 存储：静态区 程序一启动就会分配存储空间，直到程序结束才会释放 成员变量 写在类声明的大括号中的变量，称为成员变量（属性、实例变量） 成员变量只能通过对象来访问 注意：成员变量不能离开类，离开类以后就不是成员变量，成员变量不能在定义的同时进行初始化 存储：堆区 存储在堆区的数据，不会被自动释放，需要程序员手动释放 方法和函数 函数属于整个文件，方法属于某一个类，方法离开类就不行 函数可以直接调用，方法必须用对象来调用。注意： 虽然函数属于整个文件，但是如果把函数写到类的声明中会不识别 不能把函数当方法来调用，也不能把方法当函数来调用 方法可以没有声明只有实现 方法如果只有声明没有实现，编译不会报错，但是运行会报错 常见错误 只有类的声明，没有类的实现 漏了@end @interface 和 @implemention 嵌套 成员变量没有写在大括号里面 方法声明写在大括号里面 成员变量不能在 {} 中进行初始化，不能被直接拿出去访问 方法不能当做函数一样调用 Objective-C 方法只能声明在 @interface 和 @end 之间，只能实现在 @implemention 和 @end 之间。Objective-C 方法不能独立于类存在。 C 函数不属于类，跟类没有关系，只归定义函数的文件所有 C 函数不能访问 Objective-C 对象的成员 成员变量和方法不能用 static 关键字修饰 类的实现可以写在 main 函数后面，在使用之前只要声明就可以 结构体作为对象属性1234567891011121314151617181920212223242526272829303132333435363738394041424344typedef struct &#123; int year; int month; int day;&#125;Date; @interface Person : NSObject&#123; @public Date _brithday;&#125; - (void)sayBrithday; @end @implementation Person- (void)sayBrithday&#123; NSLog(@"brithday.year = %i, brithday.mouth = %i, brithday.day = %i",_brithday.year, _brithday.month, _brithday.day);&#125; @end int main(int argc, const char * argv[]) &#123; // 通过类创建对象 /* 1. 开辟存储空间 2. 初始化所有属性 3. 返回指针地址 */ Person *p = [Person new]; p-&gt;_brithday = (Date)&#123;1991, 5, 23&#125;; // 等价于下面这种，本质是复制了一份一模一样副本 Date d1 = &#123;1991, 5, 23&#125;; Date d2; d2 = d1; [p sayBrithday]; return 0;&#125; 匿名对象没有名字的对象叫做匿名对象。但是无论有没有名字，只要调用 new 方法就都会返回对象的地址，每次 new 都会开辟一块新的存储空间 1234// 非匿名对象Person *p1 = [Person new];// 匿名对象[Person new]; 匿名对象的应用场景 当对象只需要使用一次的时候就可以使用匿名对象 匿名对象可以作为方法的实参 修改项目模板可以修改每次新增项目文件的默认内容，比如新文件的默认说明。地址：/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates 在里面进行相应的配置修改，有文件模板，还有工程模板。 阅读 Xcode 文档 文档关键字说明 Getting Started — 新手入门建议初学者看，里面有一些建立观念的东西。 Guides — 指南。指南是 Xcode 中最酷最好的东西，能够从一个问题，或者系统的一个方面出发，一步一步详 细介绍怎么使用 Cocoa 文档，能帮助整理好学校的脉络。 Reference — 参考资料。一个一个框架一个一个类组织起来的文档，包含了每个方法的使用方法。 Release Notes — 发布说明。一个 iOS 新版本带来了哪些新特性，熟悉新 iOS，比较不同 iOS 版本 API 不同，都需要参考这些信息。 Sample Code — 示例代码。苹果官方提供的一些示例代码，帮助学习某些技术某些 API，可以从示例代码中看出苹果官方的编码风格，以及帮助了解文档具体是怎么回事。 Technical Notes — 技术说明。一些技术文章。 Technical Q&amp;A — 常见技术问答。技术社区里面的一些常见问题及回答整理。 Viedo — 视频。主要是 WWDC 的视频，有空的话，建议都看，也可以练习英文。 一些有价值的文档 Start Developing iOS Apps Today 马上着手开发 iOS 应用程序，建立基本 iOS 开发概览 iOS Thechnology Overview iOS 技术概览，阅读这个文档的目的和检测标准是，遇到具体问题，知道应该去看哪方面的文档。 iOS Human Interface GuideLines iOS 人机交互指南，阅读这个文档的目的和检测标准是，看到任何一个 App，可以知道他的任何一个 UI 是系统控件，还是自定义的，他的层次关系是怎样的。 Programming with Objective-C 学习这个 Objective-C 基础语法，阅读这个文档的目的和检测标准是，看的懂基本的 Objective-C 代码，方便后面学习和阅读各种示例代码 App Programming Guide for iOS iOS 应用程序编程指南，介绍的及时开发一个 App 的完整流程，包括从 App 的生命周期，休眠，激活等等，阅读这个文档的目的和检测标准是，了解全部流程和很多细节问题。 View Programmming Guide for iOS View Controller Programmming Guide for iOS 阅读这两个文档的目的和检测标准是，深刻理解什么是 View，什么是 View Controller，理解生命情况下用 View，什么情况下用 View Controller。 Table View Programmming Guide for iOS 阅读这个文档的目的和检测标准是，深刻理解 UITableView/ UITableViewController 的理论和使用方法。]]></content>
      <categories>
        <category>Objective-C</category>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Objective-C 高级编程》读书笔记-内存管理]]></title>
    <url>%2F2017%2F03%2F30%2F%E3%80%8AObjective-C-%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是自动引用计数？自动引用计数（ARC，Automatic Reference Counting）。指内存管理中对引用采取自动计数的技术。只要在 LLVM 编译器中设置了 ARC 为有效状态，那么编译器将自动进行内存管理。 内存管理/引用计数举个栗子 以开关房间的灯为实例，假设房间的灯只有一盏，上班进入办公室需要开灯，下班离开办公室需要关灯。但是，办公室一般有多人一起上班，上下班时间上各自有前后顺序，只有来的最早的人才需要开灯，走的最晚的人才需要关灯，同时所有人都需要照明。分解需求如下： 最早进入办公室的人需要开灯； 之后进入办公室的人需要照明； 下班离开办公室的人不需要照明； 最后离开办公室的人需要关灯（此时无人需要照明）； 此时为了判断是否还有人在办公室，需要导入一个计数变量来记录需要照明的人数，看一下对应关系： 当第一个人进入办公室，需要照明的人数加 1。计数值从 0 变为 1，因此需要开灯； 之后每当有人进入办公室，需要照明的人数就加 1； 每当有人下班离开办公室，需要照明的人数就减 1； 最后一个人下班离开办公室，需要照明的人数减 1，这时计数值从 1 变为 0，因此需要关灯； 对应 Objective-C 中对象的内存管理如下表： 内存管理的思考方式 注意：以下代码在 MRC 环境下。 自己生成的对象，自己所持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时，释放对象 非自己持有的对象无法释放 对象操作与 Objective-C 中方法对应如下： 注意：Objective-C 中对象的内存管理方法都在所有类的基类 NSObject 中定义，包括 alloc 类方法，retain/release/dealloc 对象方法。 #自己生成的对象，自己持有使用以下名称开头的方法名生成的对象只有自己持有： alloc new copy mutableCopy 12345/// 自己生成并持有对象-allocNSObject *obj1 = [[NSObject alloc] init]; /// 自己生成并持有对象-newNSObject *obj2 = [NSObject new]; [[NSObject alloc] init] 和 [NSObject new] 两种方法的效果一致。 copy 方法利用基于 &lt;NSCopying&gt; 协议约定，由各类实现 copyWithZone：方法生成并持有对象的副本。同样，mutableCopy 方法利用基于 &lt;NSMutableCopying&gt; 协议，由各类实现 mutableCopyWithZone: 方法生成并持有对象的副本，两者的区别是：copy 方法生成不可变的对象，mutableCopy 方法生成可变的对象。其中 Foundation 类已经遵守了 &lt;NSCopying&gt; 和 &lt;NSMutableCopying&gt; 协议。 1234LJStudent *stu1 = [[LJStudent alloc] init];/// 自己生成并持有对象LJStudent *stu2 = [stu1 copy];NSLog(@"stu1:%p---stu2:%p",stu1, stu2); 打印结果： mutableCopy 方法类似。 除了这些方法，使用以下名称开头的方法名也意味着自己生成并持有对象： allocMyObject newThatObject copyThis mutableCopyYourObject #非自己生成的对象，自己也能持有12345/// 取得非自己生成但自己持有的对象id obj = [NSMutableArray array]; // 取得的对象存在，但变量 obj 并不持有NSLog(@"Reference Count=%lu",[obj retainCount]);[obj retain]; // obj 变量自己持有对象NSLog(@"Reference Count=%lu",[obj retainCount]); 打印结果： 为什么打印结果是 1 和 2，不是 0 和 1 ?不解？？？？？？？？？。做个标记~~~~ 答案：因为类似[NSMutableArray array]方法生成的对象，内部是使用了 autorelease 方法实现，将其注册到 artoreleasepool 中去了，所以第一次打印也是 1。如何证明，通过给对象发送 release 消息，应用程序将会崩溃。 这种能够取得对象但又不持有对象的方法内部实现是： 1234id obj = [[[self class] alloc] init]; // 生成对象并自己持有[obj autorelease]; // 对象存在但自己不持有对象 return obj; autorelease 能够使对象在超出指定生存范围时能够自动并正确的释放。（也是通过对对象调用 release 方法实现） #不再需要自己持有的对象时，释放对象自己持有的对象，一旦不再需要，持有者有义务释放该对象，使用 release 方法： 12345678/// 通过alloc/new/copy/mutableCopy 方法生成并持有的对象id obj1 = [[NSObject alloc] init]; // Reference Count 等于 1[obj1 release]; // Reference Count 等于 0 /// 通过 retain 持有的对象id obj2 = [NSMutableArray array]; // Reference Count 等于 2[obj2 retain]; // Reference Count 等于 2[obj2 release]; // Reference Count 等于 1，对象不可再调用 release 方法释放 #非自己持有的对象无法释放释放非自己持有的对象时应用程序会发生崩溃: 12345678/// 1. 释放完后不再需要的对象id obj1 = [[NSObject alloc] init];[obj1 release]; // 对象已释放[obj1 release]; // 再次释放，程序崩溃 /// 2. 取得的对象存在，但自己不持有id obj2 = [NSMutableArray array];[obj2 release]; // 程序崩溃 alloc/retain/release/dealloc 实现可以使用能够和 Cocoa 框架互换的 GNUstep 框架源码中 NSObject 类的 .m 文件进行分析，来分析 alloc/retain/release/dealloc 的实现。代码经过简化处理，只保留相关联的部分。 #alloc1234567891011121314151617181920212223242526272829303132333435363738394041/// alloc 生成对象+ (id)alloc&#123; return [self allocWithZone: NSDefaultMallocZone()];&#125;/// 给对象分配内存+ (id)allocWithZone: (NSZone*)z&#123; return NSAllocateObject (self, 0, z);&#125;/// 内联函数inline idNSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)&#123; id new; int size; // 计算所需要的内存空间 大小，包括对象大小、 obj_layout 的大小、额外的字节 size = class_getInstanceSize(aClass) + extraBytes + sizeof(struct obj_layout); // 分配存放对象所需的内存空间 new = NSZoneMalloc(zone, size); // 将该内存空间置 0 memset (new, 0, size); // 返回作为对象而使用的指针 new = (id)&amp;((struct obj_layout *)new)[1]; return new;&#125;// obj_layout 结构体struct obj_layout &#123; // 不懂这个东东是干什么的 char padding[__BIGGEST_ALIGNMENT__ - ((UNP % __BIGGEST_ALIGNMENT__) ? (UNP % __BIGGEST_ALIGNMENT__) : __BIGGEST_ALIGNMENT__)]; // 这个东东是一个 long 类型 gsrefcount_t retained;&#125;; NSDefaultMallocZone、NSZoneMalloc 中包含的 NSZone 是为了防止内存碎片化而引入的结构，通过对内存分配的区域本身进行多重化管理，根据使用对象的目的、对象的大小分配内存，从而提高了内存管理的效率。 去掉 NSZone 之后的简化代码： 1234567891011121314151617+ (id)alloc&#123; // 计算所需要的内存空间 大小，包括 obj_layout 的大小 int size = sizeof(struct obj_layout) + 对象大小; // obj_layout 结构体的指针，calloc() 函数用来动态的分配内存空间，并将每一个字节都初始化为 0，空间大小等于 1 * size，分配成功返回指向该内存的地址 struct obj_layout *p = (struct obj_layout *)calloc(1, size); // 返回作为对象而使用的指针 return (id)(p + 1);&#125;// obj_layout 结构体struct obj_layout &#123; // 这个东东是一个 long 类型 gsrefcount_t retained;&#125;; alloc 类方法用 struct obj_layout 中 long 类型整数 retained 来保存引用计数，并将其写入对象内存头部，该对象内存块全部置 0 后返回。 alloc 返回对象内存图 对象的引用计数可以通过 retainCount 实例方法得到，来看对象 alloc 后 retainCount 实例方法做了什么： 1234567891011121314- (NSUInteger)retainCount&#123; // 让 struct obj_layout 中保存的 retained 变量加 1 后返回，最开始 retained 的值为 0 return NSExtraRefCount(self) + 1;&#125;/// 内联函数 inline NSUIntegerNSExtraRefCount(id anObject)&#123; // 返回 struct obj_layout 中的 retained 变量 return ((struct obj_layout *)anObject)[-1].retained;&#125; 由对象寻址找到对象内存头部，从而访问其中的 retained 变量。由于分配时全部置为 0，所以 retained 的值为 0。 #retain再看 retain 是怎么实现的： 123456789101112- (id)retain&#123; NSIncrementExtraRefCount(self); return self;&#125;/// 内联函数，去除了一些异常判断和线程安全的代码inline voidNSIncrementExtraRefCount(id anObject)&#123; ((struct obj_layout)anObject)[-1].retained++;&#125; 可以发现：对对象 retain 操作就是对 struct obj_layout 中的 retained 变量进行 ++ 操作。 #release看对对象 release 操作发生了什么： 123456789101112131415161718192021222324252627- (oneway void)release&#123; // 判断当前 retained 变量的值是否为 0，如果为 0，直接调用 dealloc 方法销毁对象 if (NSDecrementExtraRefCountWasZero(self)) &#123; # ifdef OBJC_CAP_ARC objc_delete_weak_refs(self); # endif [self dealloc]; &#125;&#125;/// 内联函数inline BOOLNSDecrementExtraRefCountWasZero(id anObject)&#123;if (((struct obj_layout)anObject)[-1].retained == 0) &#123; return YES; &#125; else &#123; ((struct obj_layout)anObject)[-1].retained--; return NO; &#125;&#125; 对对象 release 操作的内部实现是：判断当前 retained 变量的值，如果大于 0 就减 1，等于 0，等于 0 就调用 dealloc 方法销毁对象。 #dealloc最后，看一下对对象执行 dealloc 操作背后的实现： 12345678910111213- (void)dealloc&#123; NSDeallocateObject (self);&#125;// inline 标识内联函数，用于经常会使用到的函数，可以提高性能inline voidNSDeallocateObject(id anObject)&#123; struct obj_layout *o = &amp;((struct obj_layout)anObject)[-1]; free(o);&#125; 对对象执行 dealloc 操作，相当于会释放掉由 alloc 方法申请分配的内存。 以上就是 alloc/retain/release/dealloc 方法在 GNUstep 框架中的实现，具体总结如下： 在 Objective-C 的对象中存在引用计数这一整数值； 调用 alloc 或是 retain 方法后，引用计数加 1； 调用 release 方法后，引用计数减 1； 当引用计数为 0 时，调用 dealloc 方法销毁对象； apple 的实现源码地址，先来看 alloc 类方法实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950+ (id)alloc &#123; return _objc_rootAlloc(self);&#125;id_objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false, true);&#125;static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123; id obj = class_createInstance(cls, 0); return obj;&#125;id class_createInstance(Class cls, size_t extraBytes)&#123; return (*_alloc)(cls, extraBytes);&#125;id (*_alloc)(Class, size_t) = _class_createInstance;static id _class_createInstance(Class cls, size_t extraBytes)&#123; return _class_createInstanceFromZone (cls, extraBytes, nil);&#125;id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone)&#123; void *bytes; size_t size; // Allocate and initialize size = cls-&gt;alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size &lt; 16) size = 16; if (zone) &#123; bytes = malloc_zone_calloc((malloc_zone_t *)zone, 1, size); &#125; else &#123; bytes = calloc(1, size); &#125; return objc_constructInstance(cls, bytes);&#125; retainCount 123456789101112131415161718192021222324252627- (NSUInteger)retainCount &#123; return ((id)self)-&gt;rootRetainCount();&#125;inline uintptr_t objc_object::rootRetainCount()&#123; if (isTaggedPointer()) return (uintptr_t)this; return sidetable_retainCount();&#125;uintptr_tobjc_object::sidetable_retainCount()&#123; SideTable&amp; table = SideTables()[this]; size_t refcnt_result = 1; table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123; // this is valid for SIDE_TABLE_RC_PINNED too refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; &#125; table.unlock(); return refcnt_result;&#125; autoreleaseautorelease 实现apple 实现ARC 规则概要内存管理的思考方式所有权修饰符规则属性数组ARC实现__strong 修饰符__weak 修饰符__autoreleasing 修饰符引用计数]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Objective-C 2.0》读书笔记（第一章：熟悉 Objective-C）]]></title>
    <url>%2F2017%2F03%2F27%2F%E3%80%8AEffective-Objective-C-2-0%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89-%E7%86%9F%E6%82%89-Objective-C%2F</url>
    <content type="text"><![CDATA[前言正在读《Effective Objective-C 2.0》这本书，这本书主要介绍了一些使用 Objective-C 语言编写代码方面的 52 个有效方法，并且介绍了相应的原理。准备按章节写下读书笔记，并贴出实际的验证代码。 《Effective Objective-C 2.0》读书笔记（第一章：熟悉 Objective-C） 《Effective Objective-C 2.0》读书笔记（第二章：对象、消息、运行时） 《Effective Objective-C 2.0》读书笔记（第三章：接口与 API 设计） 《Effective Objective-C 2.0》读书笔记（第四章：协议与分类） 《Effective Objective-C 2.0》读书笔记（第五章：内存管理） 《Effective Objective-C 2.0》读书笔记（第六章：block 与 GCD） 《Effective Objective-C 2.0》读书笔记（第七章：系统框架） Objective-C 语言的起源Objective-C 语言是在 C 语言的基础上添加了一层面向对象，是 C 语言的超集。由 Smalltalk 演化而来，使用动态绑定的消息结构（messaging structrue）而不是函数调用（function calling）。在运行时才会检查对象类型，接收一条消息后，究竟该执行何种代码，由运行时环境而不是编译器来决定。 #区别 函数调用（function calling）：运行时所应执行的代码由编译器决定。如果调用的函数是多态的，运行时按照虚方法表（virtual table）来查出到底执行那个函数实现。 消息结构（messaging structrue）：运行时所应执行的代码由运行环境决定。不论是否多态，总是在运行时才去查看所要执行的的方法。 #内存模型 Objective-C 对象所占内存分配在堆空间（heap space） 1NSString stackString; 直接这样定义，会报如下错误： 原因：Objective-C 对象所占的内存总是分配在堆（heap）空间上，而不是在栈空间（stack space），不能在栈中分配 OC 对象。 Objective-C 对象的内存布局 123// 定义两个指针变量 oneString 和 twoString，指向同一个 NSString 类型的对象实例NSString *oneString = @"I am String"; NSString *twoString = oneString; 此时的内存布局： 此时图中演示了一个分配在堆中的 NSString 实例，还有两个分配在栈上的指针指向该实例。其中，分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧（stack frame）弹出时自动清理。 在类头文件中尽量少引用其他头文件在 .h 声明文件中，如果不是必须要引用到其他的类，只是使用到其他类的类名，可以使用向前声明（forward declaring）。 举个栗子：有一个 LJPerson 类，需要提及 LJStudent 类，并不需要知道 LJStudent 类里面的细节，可以使用向前声明。 12345678910111213#import &lt;Foundation/Foundation.h&gt;@class LJStudent; // 向前声明@interface LJPerson : NSObject/// 姓名@property(nonatomic, copy) NSString *name;/// 年龄@property(nonatomic, assign) NSUInteger age;/// 学生@property(nonatomic, strong) LJStudent *stu;@end 这样做的好处： 解决两个类互相引用的问题； 减少类的使用者所需引入头文件的数量，这样也就减少了编译时间； 必须引入的情况： 如果这个类继承自其他类，假设 LJTeacher 类继承自 LJPerson 类，那么在 LJTeacher 的头文件中必须引入 LJPerson 类； 12345#import "LJPerson.h"@interface LJTeacher : LJPerson@end 2. 如果要声明类遵从某个协议，该协议必须要有完整的定义，不能使用向前声明，也必须在头文件中引入包含该协议的类； 原则： 除非有必要，否则不要引入头文件。一般做法：在头文件中使用向前声明来提及其他类，然后在实现文件中再引入这个类的头文件。这样做可以尽量降低类之间的耦合（couping）。 有时无法使用向前声明，比如声明某个类遵循某一协议。这种情况，尽量把该类遵循某项协议的这条声明移到分类中去。比如 UITableViewDataSource 这种委托协议，这种协议只有与接收委托的类放在一起才有意义，可以在 .m 文件中引入协议的头文件，声明和实现协议。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。 多用字面量语法，少用与之等价的方法 使用字面量语法（literal syntax）的好处： 缩短源代码长度； 可读性更强； 在初始化数组和字典时更为安全，如果数组或者字典中的元素有 nil 值时，会及时抛出异常； #字面量数值可以使用 NSNumber 类将整数、浮点数、布尔值转化成 Objective-C 对象。 不用字面量方式： 1234567891011// 整数NSNumber *someInt = [NSNumber numberWithInt:29]; // 浮点数NSNumber *someFloat = [NSNumber numberWithFloat:2.9]; // 布尔值NSNumber *someBool = [NSNumber numberWithBool:YES]; // charNSNumber *someChar = [NSNumber numberWithChar:'a']; 使用字面量方式： 12345678910111213141516// 整数 NSNumber *someInt = @29; // 浮点数 NSNumber *someFloat = @2.9f; // 布尔值 NSNumber *someBool = @YES; // char NSNumber *someChar = @'a'; // 表达式 int x = 3; float y = 5.8f; NSNumber *expressionNumber = @(x * y); #字面量数组使用字面量创建数更简洁和会更安全。 不用字面量方式： 12345678NSArray *sports = [NSArray arrayWithObjects:@"basketball", @"football", @"swimming", @"running", nil]; // 操作数组 NSString *running = [sports objectAtIndex:3]; 使用字面量方式： 1234NSArray *sports = @[@"basketball", @"football", @"swimming", @"running"];// 操作数组 NSString *running = sports[3]; 更安全？ 假设有三个对象实例obj1、obj2、obj3，其中 obj2 为 nil，分别使用两种方式创建数组 arrayA、arrayB，看下会发生什么情况： 123456789id obj1 = @"obj1";id obj2 = nil;id obj3 = @2; NSArray *arrayA = [NSArray arrayWithObjects:obj1, obj2, obj3, nil];NSLog(@"arrayA=%@",arrayA);NSArray *arrayB = @[obj1, obj2, obj3];NSLog(@"arrayB=%@",arrayB); 看下打印： 结果：没有使用字面量方式创建的数组 arrayA 只有 obj1 一个元素加进去了，而使用字面量创建的数组 arrayB 崩溃了。 原因：arrayWithObjects 方法会依次处理各个参数，直到发现 nil 为止，由于 obj2 是 nil，所以该方法会提前结束；而使用字面量创建的数组的效果时先创建了一个数组，然后把 [] 内所有的对象都加入到这个数组，当发现了 为 nil 的对象加进数组时会抛出异常，可以很快的发现编程中的错误，所以更安全。 #字面量数组和字面量数组类似 不使用字面量 1234567891011121314// 字典NSDictionary *notLiteralDic = [NSDictionary dictionaryWithObjectsAndKeys: @"chenlj",@"name", @25, @"age", @"iOS", @"job", nil]; // 读取NSString *job = [notLiteralDic valueForKey:@"job"];NSLog(@"job=%@", job); // 可变NSMutableDictionary *notLiteralMdic = [notLiteralDic mutableCopy];// 写入[notLiteralMdic setObject:@"Andriod" forKey:@"job"];NSLog(@"notLiteralMdic=%@", notLiteralMdic); 使用字面量 12345678910111213// 字典NSDictionary *literalDic = @&#123;@"name" : @"chenlj", @"age" : @25, @"job" : @"iOS"&#125;; // 读取NSString *job = literalDic[@"job"];NSLog(@"job=%@", job); // 可变NSMutableDictionary *literalMdic = [literalDic mutableCopy]; // 写入literalMdic[@"job"] = @"Andriod";NSLog(@"literalMdic=%@", literalMdic); 打印： 要点 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，更加简明扼要。 应该通过取下标操作来访问数组小标或字典的键所对应的元素； 用字面量语法创建数组或字典时，若值中有 nil，则会抛出异常。因此，需要务必确保值里不含 nil。 多用类型常量，少用 #define 宏定义用枚举表示状态、选项、状态码]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 设计模式-单例模式]]></title>
    <url>%2F2017%2F03%2F17%2FiOS-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例简介 作用 保证类在程序运行过程中只有一个实例，而且该实例易于外界访问。 方便地控制了实例的个数，节约系统资源。 使用场景 在整个应用程序中，共享一份资源（这份资源只需要创建初始化 1 次） 源代码地址 怎么实现？ 保证外界每次调用 alloc 方法时要只非配一次内存。 保证外界调用 copy 方法时不会创建新的对象实例。 提供给外界一个快速方便获取单例的类方法，同时要保证返回同一个对象实例。 宏定义定义一个单例，方便整个应用中类的单例实现。 具体实现- GCD 在 .m 文件中保留一个全局的 static 实例。static 关键字保证变量只能在本文件中访问。 1static id _instance; 保证外界每次调用 alloc 方法时要只非配一次内存。 12345678910// alloc 内部是调用 allocWithZone: 方法，所以应该重写 allocWithZone: 方法，保证每次分配内存空间时只会分配一次+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _person = [super allocWithZone:zone]; &#125;); return _person;&#125; 保证外界调用 copy 方法时不会创建新的对象实例。 12345// 保证外界调用 copy 方法也不会创建新的对象实例- (id)copyWithZone:(NSZone *)zone&#123; return _person;&#125; 提供给外界一个快速方便获取单例的类方法，同时要保证返回同一个对象实例。 1234567891011// 快速方便获取单例，保证返回同一个对象+ (instancetype)sharedPerson&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _person = [[self alloc] init]; &#125;); return _person;&#125; 宏定义定义一个单例，方便整个应用中类的单例实现。 12345678910111213141516171819202122232425262728293031// .h 文件#define SingletonH + (instancetype)sharedInstance;// .m 文件#define SingletonM \static id _instance;\\+ (instancetype)allocWithZone:(struct _NSZone *)zone\&#123;\ static dispatch_once_t onceToken;\ dispatch_once(&amp;onceToken, ^&#123;\ _instance = [super allocWithZone:zone];\ &#125;);\ \ return _instance;\&#125;\\+ (instancetype)sharedInstance\&#123;\ static dispatch_once_t onceToken;\ dispatch_once(&amp;onceToken, ^&#123;\ _instance = [[self alloc] init];\ &#125;);\ \ return _instance;\&#125; \\- (id)copyWithZone:(NSZone *)zone\&#123;\ return _instance;\&#125; 那个类需要实现单例，是需要在 .h 文件中写入 SingletonH，在 .m 文件中写入 SingletonM 就可以了 12345678910111213141516// .h 文件@interface Person : NSObject///@property(nonatomic, copy) NSString *name;SingletonH;@end// .m 文件@implementation PersonSingletonM;@end 优化。实现单例类方法名替换，根据具体类在宏定义中替换。 12345678910111213141516171819202122232425262728293031// .h 文件#define SingletonH(name) + (instancetype)shared##name;// .m 文件#define SingletonM(name) \static id _instance;\\+ (instancetype)allocWithZone:(struct _NSZone *)zone\&#123;\ static dispatch_once_t onceToken;\ dispatch_once(&amp;onceToken, ^&#123;\ _instance = [super allocWithZone:zone];\ &#125;);\ \ return _instance;\&#125;\\+ (instancetype)shared##name\&#123;\ static dispatch_once_t onceToken;\ dispatch_once(&amp;onceToken, ^&#123;\ _instance = [[self alloc] init];\ &#125;);\ \ return _instance;\&#125; \\- (id)copyWithZone:(NSZone *)zone\&#123;\ return _instance;\&#125; 外界调用 非 GCD 实现12345678910111213141516171819202122232425262728293031323334static id _instance;+(instancetype)allocWithZone:(struct _NSZone *)zone&#123; // 加锁，保证线程安全 @synchronized (self) &#123; if (_instance == nil) &#123; _instance = [super allocWithZone:zone]; &#125; &#125; return _instance;&#125;+ (instancetype)sharedInstance&#123; // 加锁，保证线程安全 @synchronized (self) &#123; if (_instance == nil) &#123; _instance = [[self alloc] init]; &#125; &#125; return _instance;&#125;- (id)copyWithZone:(NSZone *)zone&#123; return _instance;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 多线程-NSOperation]]></title>
    <url>%2F2017%2F03%2F17%2FiOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B-NSOperation%2F</url>
    <content type="text"><![CDATA[简介NSOperation 的作用 配合 NSOperation 和 NSOperationQueue 也能实现多线程编程。 NSOperation 和 NSOperationQueue 实现多线程的步骤 先将需要执行的操作封装到一个 NSOperation 对象中 然后将 NSOperation 对象添加到 NSOperationQueue 中 系统会自动将 NSOperationQueue 中的 NSOperation 取出来 将取出的 NSOperation 封装的操作放到一条线程中执行 NSOperation 的子类 NSOperation 是个抽象类，并不具备封装操作的能力，必须使用他的子类 使用 NSOperation 子类方式有 3 中 NSInvocationOperation NSBlockOperation 自定义类集成 NSOperation，实现内部相应的方法 NSInvocationOperation 123456789101112131415// NSInvocationOperation 对象不会开启线程- (void)invocationOperation&#123; NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test:) object:@"chenlianging"]; NSLog(@"Current Thread = %@", [NSThread currentThread]); // Current Thread = &lt;NSThread: 0x60800006d1c0&gt;&#123;number = 1, name = main&#125; // 开启 [op start];&#125;- (void)test:(NSString *)prames&#123; NSLog(@"params = %@", prames); // params = chenlianging NSLog(@"Current Thread = %@", [NSThread currentThread]); // Current Thread = &lt;NSThread: 0x60800006d1c0&gt;&#123;number = 1, name = main&#125;&#125; 结论：NSInvocationOperation 对象不会开启线程，任务在主线程执行。 NSBlockOperation 123456789101112131415161718192021222324252627282930// NSBlockOperation 单独使用不会开启线程，但是添加额外的任务情况下会开启新线程- (void)blockOperation&#123; NSLog(@"Current Thread = %@", [NSThread currentThread]); // Current Thread = &lt;NSThread: 0x60800007e5c0&gt;&#123;number = 1, name = main&#125; // 在主线程执行 NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"下载一"); NSLog(@"Current Thread = %@", [NSThread currentThread]); // Current Thread = &lt;NSThread: 0x60800007e5c0&gt;&#123;number = 1, name = main&#125; &#125;]; // 在子线程执行 [op addExecutionBlock:^&#123; NSLog(@"下载二——————Current Thread = %@", [NSThread currentThread]); // 下载二——————Current Thread = &lt;NSThread: 0x610000264e80&gt;&#123;number = 3, name = (null)&#125; &#125;]; // 在子线程执行 [op addExecutionBlock:^&#123; NSLog(@"下载三——————Current Thread = %@", [NSThread currentThread]); // 下载三——————Current Thread = &lt;NSThread: 0x618000262dc0&gt;&#123;number = 4, name = (null)&#125; &#125;]; // 在子线程执行 [op addExecutionBlock:^&#123; NSLog(@"下载四——————Current Thread = %@", [NSThread currentThread]); // 下载四——————Current Thread = &lt;NSThread: 0x60000007e240&gt;&#123;number = 5, name = (null)&#125; &#125;]; // 开启 [op start];&#125; 结论：NSBlockOperation 单独使用不会开启线程，但是添加额外的任务情况下会开启新线程，在子线程中执行。 NSOperationQueue NSOpreation 可以调用 start 方法来执行任务，但默认是同步执行的。 如果将 NSOpreation 添加到 NSOperationQueue （操作队列）中，系统会自动异步执行 NSOpreation 中的操作。 主队列：[NSOperationQueue mainQueue]。凡是添加到主队列中的任务，都会放到主线程中执行 其他队列：(串行、并发) [[NSOperationQueue alloc] init]。添加到这种队列中的任务，会自动在子线程中执行。 最大并发数 maxConcurrentOperationCount 设置为 0：任务不会执行 设置为 1：表示创建的是串行队列 设置大于 1：表示创建的是并发队列 挂起和取消 suspended：挂起 YES：挂起任务，暂停执行 NO：恢复暂停 特点：挂起后还可以恢复。 cancelAllOperations 特点：取消后不能恢复。 12345// 取消所有操作[self.queue cancelAllOperations];// 取消某一个操作[self.op cancel]; 注意一：如果当前某一个任务正在执行，不管使用挂起还是取消操作，都不能让那个正在执行的任务暂停或者取消执行，只会暂停或者取消接下来还没开始执行的任务。 注意二：在自定义任务中，可以在 main 方法中，对每一段耗时操作进行一次判断，判断当前任务是否取消，配合 cancelAllOperations 操作，可以实现控制某一个正在执行的任务的取消操作。 1234567891011121314151617181920212223242526&gt; // 自定义 Opreation 需要重写 main 方法，将需要执行的任务封装到 main 方法中&gt; - (void)main&gt; &#123;&gt; for (int i = 0; i &lt; 1000; i ++)&gt; &#123;&gt; NSLog(@"CustomOpreation1------%zd---%@", i, [NSThread currentThread]); &#125; &gt; if (self.isCancelled) return; &gt; for (int i = 0; i &lt; 1000; i ++) &#123;&gt; NSLog(@"CustomOpreation2------%zd---%@", i, [NSThread currentThread]); &#125; &gt; if (self.isCancelled) return; &gt; for (int i = 0; i &lt; 1000; i ++) &#123;&gt; NSLog(@"CustomOpreation3------%zd---%@", i, [NSThread currentThread]); &#125; &gt; if (self.isCancelled) return; &#125;&gt; 自定义 NSOperation 自定义 Opreation 需要重写 main 方法，将需要执行的任务封装到 main 方法中。 使用场景：将经常需要执行的任务封装起来，以后不管哪里要用到同一个操作任务都能方便使用。 1234567891011#import "CustomOpreation.h"@implementation CustomOpreation// 自定义 Opreation 需要重写 main 方法，将需要执行的任务封装到 main 方法中- (void)main&#123; NSLog(@"CustomOpreation-----%@", [NSThread currentThread]);&#125;@end NSOperation 的依赖和监听 NSOperation 之间可以通过设置依赖来保证执行顺序 可以在不同 queue 的 NSOperation 对象之间设置依赖关系 123456789101112131415161718192021222324252627282930313233343536373839// 1. 创建队列NSOperationQueue *q1 = [[NSOperationQueue alloc] init];NSOperationQueue *q2 = [[NSOperationQueue alloc] init]; // 2. 创建操作NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"download1------%@", [NSThread currentThread]);&#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"download2------%@", [NSThread currentThread]);&#125;];NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"download3------%@", [NSThread currentThread]);&#125;]; NSBlockOperation *op4 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 10; i ++) &#123; NSLog(@"download4------%@", [NSThread currentThread]); &#125;&#125;]; NSBlockOperation *op5 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"download5------%@", [NSThread currentThread]);&#125;]; // 3. 设置依赖[op3 addDependency:op1]; // op1 执行完了才能执行 op3[op3 addDependency:op2]; // op2 执行完了才能执行 op3[op3 addDependency:op4]; // op4 执行完了才能执行 op3 // 4. 将操作加入到队列中[q1 addOperation:op1];[q1 addOperation:op2];[q1 addOperation:op3];[q2 addOperation:op4];[q2 addOperation:op5]; 打印结果： 注意：不能相互设置依赖。造成结果，两个操作都不会执行。 监听 NSOpration 执行完毕 1234// 监听操作的执行完毕op5.completionBlock = ^&#123; NSLog(@"op5 执行完毕%@", [NSThread currentThread]); // 在子线程中执行，但不一定是和操作在同一一个子线程&#125;; NSOperationQuene 线程间通信1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 创建队列NSOperationQueue *q = [[NSOperationQueue alloc] init]; __block UIImage *image1 = nil;__block UIImage *image2 = nil; // 1. 下载图片1NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSURL *url = [NSURL URLWithString:@"http://b.hiphotos.baidu.com/baike/w%3D268%3Bg%3D0/sign=92e00c9b8f5494ee8722081f15ce87c3/29381f30e924b899c83ff41c6d061d950a7bf697.jpg"]; NSData *data = [NSData dataWithContentsOfURL:url]; image1 = [UIImage imageWithData:data]; NSLog(@"op1 ---- current thread = %@", [NSThread currentThread]); // op1 ---- current thread = &lt;NSThread: 0x61000007bb00&gt;&#123;number = 4, name = (null)&#125;&#125;]; // 2. 下载图片2NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSURL *url = [NSURL URLWithString:@"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=596812886,3493058479&amp;fm=58"]; NSData *data = [NSData dataWithContentsOfURL:url]; image2 = [UIImage imageWithData:data]; NSLog(@"op2 ---- current thread = %@", [NSThread currentThread]); // op2 ---- current thread = &lt;NSThread: 0x6000000783c0&gt;&#123;number = 5, name = (null)&#125;&#125;]; // 3. 合成图片NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; // 开启图形上下文 UIGraphicsBeginImageContext(CGSizeMake(300, 300)); // 绘制图片 [image1 drawInRect:CGRectMake(0, 0, 150, 300)]; image1 = nil; [image2 drawInRect:CGRectMake(150, 0, 150, 300)]; image2 = nil; // 获取图片 UIImage *combineImage = UIGraphicsGetImageFromCurrentImageContext(); // 关闭图形上下文 UIGraphicsEndImageContext(); NSLog(@"op3 ---- current thread = %@", [NSThread currentThread]); // op3 ---- current thread = &lt;NSThread: 0x608000073d80&gt;&#123;number = 6, name = (null)&#125; // 回到主线程，渲染 UI [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.imageView.image = combineImage; NSLog(@"mainQueue ---- current thread = %@", [NSThread currentThread]); // mainQueue ---- current thread = &lt;NSThread: 0x61000006ffc0&gt;&#123;number = 1, name = main&#125; &#125;];&#125;]; // 4. 设置依赖[op3 addDependency:op1];[op3 addDependency:op2]; // 5. 将操作加入到队列[q addOperation:op1];[q addOperation:op2];[q addOperation:op3]; 显示效果： NSOperation 实现多图下载 需要解决的问题 在内存中缓存图片 在沙盒中缓存图片数据 缓存下载图片操作 下载过程中显示占位图片 滑动 tableView 导致的 cell 显示图片错乱问题 重复下载问题 下载失败异常处理 注意事项： 将下载图片的操作缓存到字典中，避免重复多次下载操作 下载未完成之前，显示占位图片 直接给 cell 设置图片在滑动 tableView 的时候会出现错误，因为如果图片还没有下载完成，就已经滑动了，当图片下载完成时要显示的 cell 已经不是当时的 cell 了，下载完成时，应当刷新表格视图当前行，这样才能意义对应的找到需要设置图片的 cell 当下载失败时，需要移除下载操作，并且直接返回，不然会导致设置图片内存缓存由于图片为 nil 而出现崩溃，同时避免下载失败后不再重新下载了 下载完成后，移除下载操作 将下载图片操作添加到队列中，下载完成无须将操作从队列中移除，队列会自动移除下载完成的操作 图片下载完成后，需要将图片数据缓存到内存以及沙盒中 从沙盒中加载图片数据后，需要将图片缓存到内存字典中 沙盒目录 Documents：在 itnues 连接时会备份到苹果服务器 Library Caches： Preference：偏好设置 tmp：临时文件，随时会被清理 出现内存警告时，需要清空内存缓存以及取消正在下载的操作 12345678- (void)didReceiveMemoryWarning&#123; // 清除所有内存缓存 [self.imageCache removeAllObjects]; // 取消所有正在进行的操作 [self.queue cancelAllOperations];&#125; 实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"CellId"];if (cell == nil)&#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@"CellId"];&#125; App *a = self.apps[indexPath.row];cell.textLabel.text = a.name;cell.detailTextLabel.text = a.download; // 从内存中取出图片UIImage *image = self.imageCache[a.icon];if (image)&#123; // 内存中有图片 cell.imageView.image = image;&#125;else&#123; // 从沙盒中获取图片数据 // 获取 Caches 的目录 NSString *cachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]; // 获取文件名 NSString *fileName = [a.icon lastPathComponent]; // 计算文件的全路径 NSString *file = [cachesPath stringByAppendingPathComponent:fileName]; // 加载沙盒中文件数据 NSData *data = [NSData dataWithContentsOfFile:file]; if (data) &#123; // 沙盒中有图片 UIImage *imageCache = [UIImage imageWithData:data]; cell.imageView.image = imageCache; // 注意8：从沙盒中加载图片数据后，需要将图片缓存到内存字典中 self.imageCache[a.icon] = cell.imageView.image; &#125; else &#123; NSOperation *op = self.operationCache[a.icon]; // 注意2：下载未完成之前，显示占位图片 cell.imageView.image = [UIImage imageNamed:@"placeHolder"]; if (op == nil) &#123; op = [NSBlockOperation blockOperationWithBlock:^&#123; // 下载图片 NSLog(@"下载图片"); NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:a.icon]]; // 注意4：当下载失败时，需要移除下载操作，并且直接返回 if (data == nil) &#123; [self.operationCache removeObjectForKey:a.icon]; return; &#125; UIImage *downLoadImage = [UIImage imageWithData:data]; // 注意7：图片下载完成后，需要将图片数据缓存到内存以及沙盒中 // 保存到内存字典中 self.imageCache[a.icon] = downLoadImage; // 将图片文件数据写入沙盒中 [data writeToFile:file atomically:YES]; // 回到主线程刷新 UI [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; // 注意3：直接给 cell 设置图片在滑动 tableView 的时候会出现错误，因为如果图片还没有下载完成，就已经滑动了，当图片下载完成时要显示的 cell 已经不是当时的 cell 了// cell.imageView.image = image; [tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationNone]; &#125;]; // 注意5：下载完成后，移除下载操作 [self.operationCache removeObjectForKey:a.icon]; &#125;]; // 注意6：将下载图片操作添加到队列中，下载完成无须将操作从队列中移除，队列会自动移除下载完成的操作 [self.queue addOperation:op]; // 注意1：将下载图片的操作缓存到字典中，避免重复多次下载操作 self.operationCache[a.icon] = op; &#125; &#125;&#125; return cell; 流程图 扩展 设置缓存过期，缓存多久，一周，一月还是一天？ 设置缓存大小，大于多少需要清除？按照什么顺序清除？ 使用 SDWebImage 一行代码实现图片缓存和异步下载，具体是怎么实现的？ 源代码地址]]></content>
      <categories>
        <category>iOS</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 多线程-GCD]]></title>
    <url>%2F2017%2F03%2F17%2FiOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD%2F</url>
    <content type="text"><![CDATA[GCD 基本介绍什么是 GCD？ 全称是 Grand Gentral Dispatch，可翻译为“牛逼的中枢调度器” 纯 C 语言，提供了非常强大的函数 GCD 的优势？ GCD 是苹果公司为多核的并行运算提出的解决方案 GCD 会自动利用更多的 CPU 内核（比如双核，四核） GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程） 程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码 任务和队列 任务：执行什么操作 队列：用来存放任务 GCD 的使用 定制任务 确定想做的事情 将任务添加到队列中 GCD 会自动将队列中的任务取出，放到对应的线程中去执行 任务的取出遵循队列的 FIFO(先进先出，后进后出) 执行任务123456789// 用`同步`的方式执行任务// queue：队列// block：任务dispatch_sync(dispatch_queue_t _Nonnull queue, ^(void)block)// 用`异步`的方式执行任务// queue：队列// block：任务dispatch_async(dispatch_queue_t _Nonnull queue, ^(void)block) 同步和异步 同步：只能在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新的线程中执行任务，具备开启线程的能力 队列的类型并发队列(Concurrent Dispatch Queue) 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue） 让任务一个接着一个得执行（一个任务执行完毕后，再执行下一个任务） GCD 基本使用并发队列 方法一：GCD 默认已经提供了全局的并发队列，共整个应用使用，可以无需手动创建 1234567891011/** 获的系统全局并发队列 @param identifier：队列的优先级：DISPATCH_QUEUE_PRIORITY_HIGH 2， DISPATCH_QUEUE_PRIORITY_DEFAULT 0， DISPATCH_QUEUE_PRIORITY_LOW （-2）， DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN @param flags：默认传 0，无用的参数 @return 返回一个全局并发队列 */ dispatch_queue_t queue = dispatch_get_global_queue(long identifier, unsigned long flags) 方法二：创建并发队列 1234567 // 1.创建一个并发队列/** @param label: 相当于队列的名字 @param attr: 串行队列：DISPATCH_QUEUE_SERIAL；并发队列：DISPATCH_QUEUE_CONCURRENT； @return 返回一个队列 */// dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_CONCURRENT); 串行队列 方法一：创建串行队列 1234 // 1.创建串行队列// 队列类型传 DISPATCH_QUEUE_SERIAL 或者 NULLdispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL);// dispatch_queue_t queue = dispatch_queue_create("myQueue", NULL); 方法二：系统主队列(跟主线程相关的队列)。主队列是 GCD 自带的一中特殊的串行队列，放到主队列中的任务，都会放到主线程中执行 12// 获取主队列dispatch_queue_t queue = dispatch_get_main_queue(); 组合形式1. 异步函数 + 并发队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546/// 异步函数 + 并发队列：可以同时开启多条线程- (void)asyncConurrent&#123; // 1.创建一个并发队列 /** @param label: 相当于队列的名字 @param attr: 串行队列：DISPATCH_QUEUE_SERIAL；并发队列：DISPATCH_QUEUE_CONCURRENT； @return 返回一个队列 */ // dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_CONCURRENT); /** 获的系统全局并发队列 @param identifier：队列的优先级：DISPATCH_QUEUE_PRIORITY_HIGH 2， DISPATCH_QUEUE_PRIORITY_DEFAULT 0， DISPATCH_QUEUE_PRIORITY_LOW （-2）， DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN @param flags：默认传 0，无用的参数 @return 返回一个全局并发队列 */ dispatch_queue_t queue = dispatch_get_global_queue(0, 0); // 2. 将任务加入到队列 dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务01----%@", [NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务02----%@", [NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务03----%@", [NSThread currentThread]); &#125; &#125;);&#125; 打印结果： 结论：异步函数 + 并发队列，可以同时开启多个线程，多个任务能并发执行 2. 同步函数 + 并发队列12345678910111213141516171819202122232425262728/// 同步函数 + 并发队列：不能开启多条线程- (void)syncConurrent&#123; // 1. 获得全局并发队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); // 2. 将任务加入到队列 dispatch_sync(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务01----%@", [NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务02----%@", [NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务03----%@", [NSThread currentThread]); &#125; &#125;);&#125; 打印结果： 结论：同步函数 + 并发队列：不能开启新的线程 3. 同步函数 + 手动创建串行队列12345678910111213141516171819202122232425262728293031/// 同步函数 + 串行队列：：不会开启新的线程，任务一个接一个地执行- (void)syncSerial&#123; // 1.创建串行队列 // 队列类型传 DISPATCH_QUEUE_SERIAL 或者 NULL dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL);// dispatch_queue_t queue = dispatch_queue_create("myQueue", NULL); // 2. 将任务加入到队列 dispatch_sync(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务01----%@", [NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务02----%@", [NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务03----%@", [NSThread currentThread]); &#125; &#125;);&#125; 打印结果： 结论：同步函数 + 串行队列：不会开启新的线程，任务一个接一个地执行 4. 异步函数 + 手动创建串行队列123456789101112131415161718192021222324252627282930/// 异步函数 + 串行队列- (void)asyncSerial&#123; // 1.创建串行队列 // 获取主队列// dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL); // 2. 将任务加入到队列 dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务01----%@", [NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务02----%@", [NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务03----%@", [NSThread currentThread]); &#125; &#125;);&#125; 打印结果： 结论：异步函数 + 手动创建串行队列：会开启新的线程，另外任务是串行执行的。 5. 异步函数 + 主队列12345678910111213141516171819202122232425262728/// 异步函数 + 主队列- (void)asyncMain&#123; // 1.获取主队列 dispatch_queue_t queue = dispatch_get_main_queue(); // 2. 将任务加入到队列 dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务01----%@", [NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务02----%@", [NSThread currentThread]); &#125; &#125;); dispatch_async(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务03----%@", [NSThread currentThread]); &#125; &#125;);&#125; 打印输出： 结论：异步函数 + 主队列：主队列优先级更高，不会开启新的线程，会在主线程中执行，任务也是一个接一个执行。 6. 同步函数 + 主队列12345678910111213141516171819202122232425262728/// 同步函数 + 主队列- (void)syncMain&#123; // 1.获取主队列 dispatch_queue_t queue = dispatch_get_main_queue(); // 2. 将任务加入到队列 dispatch_sync(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务01----%@", [NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务02----%@", [NSThread currentThread]); &#125; &#125;); dispatch_sync(queue, ^&#123; for (NSInteger i = 0; i &lt; 10; i++) &#123; NSLog(@"任务03----%@", [NSThread currentThread]); &#125; &#125;);&#125; 情况一：如果同步函数在主线程被调用，那么会崩溃： 情况二：如果同步函数在子线程被调用，会怎么样呢？ 1[self performSelectorInBackground:@selector(syncMain) withObject:nil]; 看打印输出： 结果不会崩溃，任务会在主线程中被执行，而且是串行执行 结论：同步函数 + 主队列：同步函数如果在主线程被调用，会崩溃。如果在子线程中被调用，任务会在主线程中被执行，而且是串行执行。 总结所以，总结一下，各种队列的执行效果： 注意 如果往当前串行队列中添加任务，会阻塞住当前的串行队列，应用也会崩溃。如这样： 如果把队列改成串行队列改成并发队列，再看一下结果： 如果还是串行队列，就把同步函数改成异步函数，再来看下结果打印： 同步函数和异步函数的执行：异步函数中的任务执行会等一会儿执行，如果是同步函数，那么同步函数中的任务会立即执行。 GCD 线程间通信从子线程回到主线程12345678dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 执行耗时的异步操作... dispatch_async(dispatch_get_main_queue(), ^&#123; // 回到主线程，执行刷新UI操作 &#125;);&#125;); GCD 中的其他函数barrier 函数12// 作用：在他前面的任务结束后他才执行，而且他后面的任务等他执行完成后才会执行dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); 注意： barrier 函数里面的队列 queue 不能是全局并发队列 12345678910111213141516171819202122232425for (NSInteger i = 0; i &lt; 3; i ++)&#123; // dispatch_barrier_async 的队列不能是是全局并发队列 dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSLog(@"-----01----%@", [NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@"-----02-----%@", [NSThread currentThread]); &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@"-----barrier-----%@", [NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@"-----03----%@", [NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@"-----04----%@", [NSThread currentThread]); &#125;);&#125; 控制台输出： 延时执行函数iOS 常见的延时执行方法: 调用 NSObject 的方法 12// 几秒后执行 aSelector 方法- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay; 使用 GCD 函数 1dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block); 使用 NSTimer 方法 1+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo; 效果都一样： 1234567891011121314151617181920- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@"touchBegin"); // 方法一，调用 NSObject 方法// [self performSelector:@selector(run) withObject:nil afterDelay:2.0]; // 方法二，使用 GCD 函数// dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;// NSLog(@"---run");// &#125;); // 方法三，NSTimer 定时器 [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:NO];&#125;- (void)run&#123; NSLog(@"---run");&#125; 打印结果： 一次性代码函数 使用 dispatch_once 函数能保证某段代码在程序运行过程中只被执行一次 1234static dispatch_once_t onceTaken;dispatch_once(&amp;onceTaken, ^&#123; // 只执行一次的代码（这里默认是线程安全的）&#125;); 快速迭代函数 使用 dispatch_apply 函数能进行快速迭代遍历 1dispatch_apply(size_t iterations, dispatch_queue_t queue, DISPATCH_NOESCAPE void (^block)(size_t)); 应用场景-将一个文件夹中的所有文件拷贝到另一个文件夹里面去 123456789101112131415161718192021// 设置起始文件夹路径和目标文件夹路径NSString *fromPath = @"/Users/chenliangjing/Desktop/from";NSString *toPath = @"/Users/chenliangjing/Desktop/to"; // 遍历出起始文件夹下的所有子路径NSFileManager *fm = [NSFileManager defaultManager];NSArray *fromSubpath = [fm subpathsOfDirectoryAtPath:fromPath error:nil];NSArray *toBeginSubpath = [fm subpathsOfDirectoryAtPath:toPath error:nil];NSLog(@"beginSubpath:%@",toBeginSubpath); // 使用 dispatch_apply 函数快速遍历dispatch_apply(fromSubpath.count, dispatch_get_global_queue(0, 0), ^(size_t index) &#123; // 获得起始文件夹下文件的全路径，以及目标文件夹下的全路径 NSString *fromFullPath = [fromPath stringByAppendingPathComponent:fromSubpath[index]]; NSString *toFullPath = [toPath stringByAppendingPathComponent:fromSubpath[index]]; // 剪切 [fm moveItemAtPath:fromFullPath toPath:toFullPath error:nil]; NSLog(@"---%@----%@",toFullPath, [NSThread currentThread]);&#125;); 控制台输出： 队列组函数 开发有时会有这样一个需求：首先分别异步执行多个耗时操作，然后需要等这多个耗时操作都执行完毕再回到主线程执行其他操作。这个时候可以用 GCD 的队列组实现，步骤如下： 12345678910111213141516// 创建队列和队列组dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; // 执行一个耗时操作&#125;); dispatch_group_async(group, queue, ^&#123; // 执行一个耗时操作&#125;); // 回到主线程，执行其他操作dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的任务都执行完毕后，回到主线程&#125;); 应用场景-去网络上下载两张图片，等两张图片都下载完成后拼接成一张显示到 imageView 上，可以这样做： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 创建队列和队列组dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; // 1.下载第一张图片 // 获取图片地址url NSURL *url1 = [NSURL URLWithString:@"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=596812886,3493058479&amp;fm=58"]; // 下载图片,耗时操作 NSData *data1 = [NSData dataWithContentsOfURL:url1]; self.image1 = [UIImage imageWithData:data1];&#125;); // 2.下载第一张图片dispatch_group_async(group, queue, ^&#123; // 获取图片地址url NSURL *url2 = [NSURL URLWithString:@"http://b.hiphotos.baidu.com/baike/w%3D268%3Bg%3D0/sign=92e00c9b8f5494ee8722081f15ce87c3/29381f30e924b899c83ff41c6d061d950a7bf697.jpg"]; // 下载图片,耗时操作 NSData *data2 = [NSData dataWithContentsOfURL:url2]; self.image2 = [UIImage imageWithData:data2];&#125;); // 3. 将下载的两张图片合成一张dispatch_group_notify(group, queue, ^&#123; // 开启图形上下文 UIGraphicsBeginImageContext(CGSizeMake(300, 300)); // 绘制图片 [self.image1 drawInRect:CGRectMake(0, 0, 150, 300)]; [self.image2 drawInRect:CGRectMake(150, 0, 150, 300)]; // 从图形上下文中获取图片 UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); // 关闭图形上下文 UIGraphicsEndImageContext(); // 回到主线程 dispatch_async(dispatch_get_main_queue(), ^&#123; // 4. 将图片显示到 imageView 上去 self.imageView.image = image; &#125;);&#125;); 看下效果：]]></content>
      <categories>
        <category>iOS</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 多线程-NSThread]]></title>
    <url>%2F2017%2F03%2F17%2FiOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B-NSThread%2F</url>
    <content type="text"><![CDATA[前言NSThread 是实现 iOS 多线程技术的一种方案。是用 OC 语言编写的，由程序员管理线程生命周期，简单易用，可直接操作，使用更加地面向对象。 创建线程123456789101112131415- (IBAction)buttonClick:(id)sender&#123; // 1.创建线程对象 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@"testParm"]; // 2. 启动线程 [thread start];&#125;- (void)run:(NSString *)parm&#123; // 获取当前线程对象 NSThread *currentThread = [NSThread currentThread]; NSLog(@"----run----%@---%@", parm, currentThread);&#125; 控制台打印，可以看到： 确实创建了一个新的线程； 参数也已经成功传递过去了； 注意：NSThread 创建的线程对象，系统会保证他的生命周期直到线程要执行的任务完成。 可以测试一下，新建一个类 TestThread，继承自 NSThread，重写他的 dealloc 方法： 123456789101112131415161718- (IBAction)buttonClick:(id)sender&#123; // 1.创建线程对象 TestThread *thread = [[TestThread alloc] initWithTarget:self selector:@selector(run:) object:@"testParm"]; // 2. 启动线程 [thread start];&#125;- (void)run:(NSString *)parm&#123; for (int i = 0; i &lt; 50; i++) &#123; // 获取当前线程对象 NSThread *currentThread = [NSThread currentThread]; NSLog(@"run-%zd---%@---%@", i, parm, currentThread); &#125;&#125; 查看控制台输出： 方法二创建线程后自动启动线程： 1[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@"testParm"]; 方法三创建一个后台线程后自动启动线程： 1[self performSelectorInBackground:@selector(run:) withObject:@"testParm"]; 总结 方法二和方法三比方法一更能简单快捷的创建线程，但是无法对线程进行更详细的设置 主线程相关方法123[NSThread mainThread];// 获得主线程（类方法）[thread isMainThread]; // 是否为主线程（对象方法）[NSThread isMainThread];// 是否为主线程（类方法） 线程其他方法12345// 获取当前线程对象NSThread *currentThread = [NSThread currentThread];// 设置线程名字- （void）setName:(NSString:)name; 线程的状态线程总共有五种状态 新建（New）：当线程刚新建时的状态，还没有调用 start 方法 就绪（Runnable）： 新建状态的线程调用了开启线程的 start 方法会进入就绪状态； 处于阻塞状态下的线程由于 sleep 到时或者得到同步锁，也会进入就绪状态； 处于运行状态下的线程，当 CPU 去转换调度其他线程时，当前线程就会进入到就绪状态； 运行（Running）：CPU 调度就绪状态的当前线程，当前线程就进入运行状态 阻塞（Blocked）：处于运行状态的线程调用了 sleep 方法或者在等待同步锁时会进入到阻塞状态 死亡（Dead）：线程任务执行完毕、或异常退出、强制退出时线程会进入到死亡状态 控制线程状态#启动线程12// 进入就绪状态 -&gt; 运行状态，当任务执行完毕，自动进入死亡状态- (void)start; #阻塞（暂停）线程12345// 进入阻塞状态// 让线程睡到 date 日期+ (void)sleepUntilDate:(date *)date;// 线程睡 timeInterval 时间+ (void)sleepForTimeInterval:(NSTimeInterval)timeInterval; #强制停止线程12// 线程进入死亡状态+ (void)exit; 注意：线程一旦停止（死亡）了，就不能再次开启任务 线程安全资源共享 同块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源 比如多个线程访问同一个对象、同一个变量、同一个文件 当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题 解决方案 - 互斥锁 #互斥锁使用格式1234@synchronized(所对象)&#123; // 需要锁定的代码&#125; #互斥锁优缺点 优点：能有效防止因多线程抢夺资源造成的数据安全问题 缺点：需要消耗大量 CPU 资源 #互斥锁使用前提 多条线程抢夺同一块资源 #线程同步 线程同步：多条线程在同一条线上执行（按顺序地执行任务） 互斥锁：就是使用了线程同步技术 #原子和非原子属性 atomic：原子熟悉，会为 setter 方法加锁（默认就是 atomic）。线程安全，需要消耗大量的资源 nonatomic：非原子属性，不会为 setter 方法加锁（默认就是 atomic）。非线程安全，适合内存小的移动设备 建议： 所有属性都声明为 nonatomic 尽量避免多线程抢夺同一块资源 尽量将加锁、资源抢夺的业务逻辑交给服务器处理，减小移动设备客户端的压力 以售票场景为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)viewDidLoad &#123; [super viewDidLoad]; // 创建线程 self.thread01 = [[NSThread alloc] initWithTarget:self selector:@selector(saleTicket) object:nil]; self.thread01.name = @"售票员01"; self.thread02 = [[NSThread alloc] initWithTarget:self selector:@selector(saleTicket) object:nil]; self.thread02.name = @"售票员02"; self.thread03 = [[NSThread alloc] initWithTarget:self selector:@selector(saleTicket) object:nil]; self.thread03.name = @"售票员03"; self.ticketCount = 100;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 开启线程 [self.thread01 start]; [self.thread02 start]; [self.thread03 start];&#125;- (void)saleTicket&#123; while (1) &#123; // 先取出总数 NSInteger count = self.ticketCount; if (count &gt; 0) &#123; // 让线程睡 0.1 秒，进入阻塞状态 [NSThread sleepForTimeInterval:0.1]; self.ticketCount = count - 1; NSLog(@"%@卖了一张票，还剩下%ld张", [NSThread currentThread].name, self.ticketCount); &#125; else &#123; NSLog(@"票已经买完了"); break; &#125; &#125;&#125; 看控制台打印： 很明显出现了数据错乱和数据安全问题 在读写数据的地方加把互斥锁： 12345678910111213141516171819202122232425- (void)saleTicket&#123; while (1) &#123; // self 用做锁对象，可保持所对象不发生变化 @synchronized (self) &#123; // 先取出总数 NSInteger count = self.ticketCount; if (count &gt; 0) &#123; // 让线程睡 0.1 秒，进入阻塞状态 [NSThread sleepForTimeInterval:0.1]; self.ticketCount = count - 1; NSLog(@"%@卖了一张票，还剩下%ld张", [NSThread currentThread].name, self.ticketCount); &#125; else &#123; NSLog(@"票已经买完了"); break; &#125; &#125; &#125;&#125; 再看控制台打印： 线程间通信什么叫做线程间通信？ 在一个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信 一个线程传递数据给另一个线程 在一个线程执行完特定任务后，在转到另一个线程继续执行任务 系统方法12performSelectorOnMainThread:@selector withObject: waitUntilDone:performSelector:@selector(setImage:) onThread: withObject:image waitUntilDone: Port 端口 NSPort NSMessagePort NSMachPort 线程间通信示例 - 图片下载 123456789101112131415// 1. 获取图片地址urlNSURL *url = [NSURL URLWithString:@"https://imgsa.baidu.com/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60/sign=ca5abb5b7bf0f736ccf344536b3cd87c/29381f30e924b899c83ff41c6d061d950a7bf697.jpg"]; // 测试代码执行时间// NSDate *begin = [NSDate date];CFTimeInterval begin = CFAbsoluteTimeGetCurrent();// 2. 下载图片,耗时操作NSData *data = [NSData dataWithContentsOfURL:url];// NSDate *end = [NSDate date];CFTimeInterval end = CFAbsoluteTimeGetCurrent();// NSLog(@"%f",[end timeIntervalSinceDate:begin]);NSLog(@"%f",end - begin); // 3. 将图片显示到 imageView 上self.imageView.image = [UIImage imageWithData:data]; 可以发现下载图片这段耗时操作耗时： 而这种耗时操作不应该放在主线程中进行 12345678910111213141516171819202122232425- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 开一个子线程去下载图片 [self performSelectorInBackground:@selector(downImage) withObject:nil];&#125;- (void)downImage&#123; // 1. 获取图片地址url NSURL *url = [NSURL URLWithString:@"https://imgsa.baidu.com/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60/sign=ca5abb5b7bf0f736ccf344536b3cd87c/29381f30e924b899c83ff41c6d061d950a7bf697.jpg"]; // 2. 下载图片,耗时操作 NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; // 3. 图片下载完成，回到主线程刷新 UI，并传递 image 参数回去 // waitUntilDone 参数：指是否等主线程 showImage: 方法执行完成，如果 YES，则会等 showImage: 方法执行完毕才会继续 执行下面的代码 [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; &#125;- (void)showImage:(UIImage *)image&#123; // 将图片显示到 imageView 上 self.imageView.image = image;&#125; 回到主线程还有方法二: 1[self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; 方法三: 1[self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:NO]; 这样就实现了线程间的通信，现在主线程开一条子线程去执行下载图片的耗时操作，等到图片下载完成在从子线程回到主线程，并把图片传递到主线程，刷新 UI。]]></content>
      <categories>
        <category>iOS</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 多线程-基本概念]]></title>
    <url>%2F2017%2F03%2F10%2FiOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[进程与线程进程Q：什么是进程？A：进程是指在系统中正在运行的一个应用程序。eg：比如同时打开微信、QQ，系统就会分别启动两个进程。 注意：每个进程之间是独立的且均运行在其专用并受保护的内存空间内。 线程Q：什么是线程？A：线程是进程的基本执行单元，一个进程想要执行任务，必须得有线程（每个进程至少要有一个线程）。eg：比如使用 QQ 进行文字聊天，使用微信进行视频聊天，都需要在各自的线程中执行。 线程的串行Q：什么是线程的串行？A：如果要在一个线程中执行多个任务，那么只能一个一个的按照顺利执行这些任务，也就是说：在同一时间内，一个线程中只能执行一个任务。eg：比如在一个线程中有 3 个下载任务（任务 A，任务 B，任务 C） 多线程Q：什么是多线程？A：一个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。eg：可以将进程比作工厂车间，线程比作车间工人，由不任务的车间工人在车间运作，最后生产出产品。因此，可以说多线程技术可以提高程序的执行效率。 比如：同时开启 3 条线程分别来执行 3 个下载任务（任务 A，任务 B，任务 C） 多线程的原理 同一时间，CPU 只能处理一条线程，只有一条线程在工作 多线程并发执行时，其实是 CPU 快速的在线程之间调度切换 如果 CPU 调度线程的时间足够快，就造成了多条线程并发执行的假象 考虑情况：如果线程非常非常多，会发生什么情况？ A：CPU 会在多个线程之间调度，最终会导致 CPU 累死，消耗大量的 CPU 资源，并且每条线程被执行的频率降低，导致线程的执行效率降低 多线程的优缺点#多线程的优点 能够适当的提高程序的执行效率； 能够适当提高资源的利用率（CPU、内存的利用率） #多线程的缺点 创建线程是有开销的，iOS 主要的成本包括：内核数据结构（大于 1 KB）、栈空间（子线程 512 KB、主线程 1 M，也可以使用 setStackSize: 设置，但必须是 4 K 的倍数，而且最小是 16 K），创建线程约需要 90 毫秒的创建时间 如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU 在调度线程上的开销就越大 程序设计会更加复杂：比如线程之间的通信，多线程的数据共享等 iOS 中的多线程什么是主线程？ 一个 iOS 程序运行后，默认会开启 1 条线程，该线程称为“主线程”或“UI 线程”。 主线程的主要作用？ 显示/刷新 UI 界面 处理 UI 事件（比如点击事件、滚动事件、拖拽事件等） 主线程的使用注意？ 不要将比较耗时的操作放置在主线程中，因为耗时操作会卡住主线程严重影响界面流畅度，会给用户一种“卡”的感觉，体验效果不好。 多线程的实现方案 备注：pthread: iOS 10 已经找不到了这个方法]]></content>
      <categories>
        <category>iOS</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿悦动圈运动APP（第一天）]]></title>
    <url>%2F2017%2F03%2F07%2F%E4%BB%BF%E6%82%A6%E5%8A%A8%E5%9C%88%E8%BF%90%E5%8A%A8APP%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[仿悦动圈运动APP 项目地址 第一天获取图片资源 用PP助手下载悦动圈官方 App 的 ipa 包，使用归档工具解压 ipa 包，找到 Payload 文件夹，看到 SprotBar 显示包内容，里面就有整个 App 的资源文件，能在里面找到 AppIcon，Lanch 启动图，引导图等。 但是还有很多图片是找不到的，因为在一个 Assets.car 的文件里面，需要用到一个工具把里面的图片资源导出来，这个工具叫cartool，可以用 XCode 打开，在 main.m 文件里删除 idiomSuffixForCoreThemeIdiom 方法，新建一个文件夹用来接收导出来的图片，如下配置： 再运行一下工程，图片资源就导出到添加的文件夹里面了。 新建工程，基础配置新建一个工程项目，配置应用名称、BundleId、部署版本、横竖屏等这些信息，再将图片资源导入，配置下 AppIcon，启动图 接口API获取使用 Charles 工具，配置一下，https 请求需要在手机端安装 SSL 证书，获取到每个页面的 API，做好对应的整理，主要有请求方式，请求参数，请求地址的获取。 关于 Charles 如何使用的相关介绍可以参照唐老师写的这篇博客 搭建框架 底部是一个 UITabBarController 主控制器，有 SportsViewController、ChallengeViewController、ProfileViewController 5个子控制器，采用 storyboard 的方式搭建，并按照 MVVM 的架构模式新建好文件夹目录： 修改 TabBar 的全局颜色： 1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 修改TabBar的全局颜色 [UITabBar appearance].tintColor = CLJTabBarTintColor; return YES;&#125; 将各个子控制器添加到 TabBarController 上去： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; [self creatViewControllerWithStoryboard:@&quot;Sports&quot;]; [self creatViewControllerWithStoryboard:@&quot;Challenge&quot;]; [self creatViewControllerWithStoryboard:@&quot;Explore&quot;]; [self creatViewControllerWithStoryboard:@&quot;Social&quot;]; [self creatViewControllerWithStoryboard:@&quot;Profile&quot;];&#125;// 通过Storyboard添加子控制器- (void)creatViewControllerWithStoryboard:(NSString *)storyboard&#123; UIStoryboard *sb = [UIStoryboard storyboardWithName:storyboard bundle:nil]; UIViewController *vc = [sb instantiateInitialViewController]; [self addChildViewController:vc];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序初体验]]></title>
    <url>%2F2016%2F11%2F09%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[微信小程序概述什么是微信小程序微信小程序是公众号的一种，叫做应用号，2016年9月12日，定名为小程序。小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。也就是说，这是一种新的公众号的形态，这种形态下面用户关注了一个公众号，就像安装了一个 APP 一样，这样的话我们可以尝试做到让更多的 APP 有一种更轻量的形态，但是又更好使用的一种形态来存在。 公测 公测参与者：企业、政府、媒体、其他组织 公测内容： 开发支持：提供一系列工具帮助开发者快速接入并完成小程序开发； 开发文档：介绍小程序的开发框架、基础组件、API 及相关开发问题； 开发者工具：集成开发调试、代码编辑、小程序预览及发布等功能； 设计指南：提出设计原则及规范，帮助建立友好、高效、一致的用户体验； 运营规范：介绍微信公众平台小程序的审核标准及运营规则； 小程序体验 demo：可体验小程序组件及 API 功能，并提供调试功能供开发者使用； 注意事项：现阶段每个机构帐号只允许注册最多 50 个小程序，每个小程序一年需要缴纳 300 块钱，所有小程序帐号都需要绑定一个电子邮箱，一个手机号码只能绑定 5 个小程序。 微信小程序与 APP 微信小程序是微信公众号中的应用号，是一种集成在智能手机第三方应用程序中的轻应用，而不是单独的一款应用程序。其本质还是HTML5+CSS+JAVASCRIPT，只是微信小程序提高了自身对于 HTML5 的特性支持能力，开放了更多的系统调用。将有更好的用户体验、更快的加载速度、更多的功能。 APP（应用程序；外语全称：Application）指的是智能手机的第三方应用程序，即一个单独的应用程序。比较著名的应用商店有苹果的 App Store，谷歌的 Google Play Store，诺基亚的 Ovi store，还有黑莓用户的 BlackBerry App World，微软的 Marketplace 等。 应用分类：游戏、教育、电商、办公、旅游、生活、社交、工具、视频、音频、新闻、财经、图形； 功能特性：相机（拍照、摄像、二维码）、地图（定位、导航）、推送（通知、消息）、闪光灯（电筒）、蓝牙（硬件通讯、智能家居）、陀螺仪（摇一摇、水平仪）、重力感应、罗盘、网络； 微信小程序取代 APP 用户使用流程：搜索-下载-安装-注册-使用-卸载 搜索：微信小程序只需要在微信发现模块；而 APP 需要在不同的应用市场搜索（iOS：APPStore；android：GoodPlayStore/小米应用商店/应用宝/91助手）； 下载：微信小程序只需要关注而不需要下载安装就可以使用；而APP不管功能单一还是复杂都需要下载安装后才能使用； 安装：微信小程序不需要安装，则不需要占用存储空间；而APP需要下载后进行安装，占用存储空间，造成存储空间会不断减少； 使用：微信小程序因为是集成在微信应用程序中的应用号，所以不需要进行注册后才能使用；而 APP 在使用过程中则有些功能是需要用户进行注册后才能进行使用，这就造成即使使用频率低的 APP 也需要进行注册，且过多的注册不同的 APP 也会造成用户对注册信息的遗忘； 卸载：微信小程序不再使用后不需要进行卸载操作；而 APP 在用户不再使用的情况下需要用户进行卸载操作； 开发者开发流程：需求-设计-开发-发布 开发语言：微信小程序开发人员需要了解掌握weiLang：视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架、页面管理框架、基础组件、丰富的API（视图、内容、按钮、导航、多媒体、网络能力、罗盘、重力感应、画板等） 开发环境：微信小程序：windows/Mac/Linux+微信 web 开发者工具； 发布市场：微信小程序开发完成后，直接通过开发帐号进行提交，然后经过审核再分发，保证质量； 注意事项：微信小程序开发及发布权限（见开头注意事项）；iOSAPP 开发发布权限（个人开发者帐号 99 美元/年-必须发布到 APPStore 市场但无数量限制、企业开发者帐号 299 美元/年-可以不发布到 APPStore 市场且无数量限制）；android 开发发布权限（）。 开发使用体验 应用页面层级：微信小程序一个应用同时只能打开 5 个页面 应用包大小：微信小程序为了提升体验流畅度，编译后的代码包大小需小于 1MB ，大于 1MB 的代码包将上传失败 启动与运行：微信小程序启动、运行速度好过纯网页的 H5（有强大的框架和丰富的组件） 功能特点：微信小程序的功能比 H5 的功能强大（有强大的框架和丰富的组件） 流畅性：微信小程序具有一定的缓存能力，避免同一个页面多次进行网络请求刷新 开发调试：微信小程序使用微信 web 开发工具集成的调试工具 Wxml、Console、Sources、Network、Appdata、Storage。 Wxml panel 在模拟器中实时看到修改的情况，且可以快速找到页面中组件对应的 wxml 代码。 Sources panel 用于显示当前项目的脚本文件 Network panel 用于观察和显示 request 和 socket 的请求情况 Appdata panel 用于显示当前项目当前时刻 appdata 具体数据，实时地反馈项目数据情况 Storage panel 用于显示当前项目的使用 wx.setStorage 或者 wx.setStorageSync 后的数据存储情况 Console panel 有两大功能：开发者可以在此输入和调试代码，及错误输出 开发初体验开发前准备注册想要发布微信小程序，一定要先注册，注册流程参照官网微信小程序接入指南 绑定开发者登录微信登录微信公众平台小程序，进入用户身份- 开发者，新增绑定开发者。 已认证的小程序可绑定：&lt;= 20人 未认证的小程序可绑定：&lt;= 10人 获取AppID进入“设置-开发设置”，获取AppID信息 开发工具官方官方 IDE（最新版本 0.10.102800） 小程序快速生成平台]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 基本操作]]></title>
    <url>%2F2016%2F11%2F09%2FGit-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[#GitHub 上传代码安装 git如果没有安装 git，得先安装 git，mac 系统自带 git，不用安装，可以在命令行里查看下 git 的版本： 1git version git 配置安装完 git，首要任务是配置我们的信息，最重要的是用户名及邮箱，在终端中以下命令：12git config --global user.name "用户名" git config --global user.email "用户邮箱" 新建一个代码仓库登录到个人 GitHub 主页，点击头像左边附近 + 号按钮，选择 New repository 新建代码仓库： 给仓库取个名字，可以添加描述，也可以不添加，点击下面创建按钮，一个个人仓库就创建好了 克隆仓库到本地复制刚刚创建好的仓库的地址，在终端中克隆下来： 1git clone https://github.com/github用户名/“仓库名”.git 添加内容到暂存区克隆仓库到本地后，本地就会出现一个被版本管理的和代码仓库同名的目录文件夹，将写好的代码工程文件拖入到这个目录文件夹，终端 cd 到这个被版本控制的文件夹，然后提交添加到暂存区： 添加单个文件： 1git add "文件名.后缀名" 添加目录下所有的文件： 1git add -A 提交到暂存区将添加的文件进行提交，填写这次提交的描述，通过下面的命令： 1git commit -m "这次提交的描述" 提交到远程仓库之前的操作都是在本地进行的，要想把暂存区的提交同步到 github 上的远程仓库，还需要执行下面的命令： 1git push origin master 执行成功完这个命令，就可以去 github 上查看这个仓库就已经多了刚刚提交的文件。 查看仓库当前状态可以查看当前仓库的状态：是否为最新代码，有什么更新等等，执行 git status 命令： 1git status 其他命令git show 查看某一次提交更新了什么：1git show 版本回退没有将错误的版本提交到远程仓库#情况一本地工作区修改后还没有被放到暂存区： 1git checkout -- file # `file` 指那个需要回退的文件 #情况二本地工作区修改后还添加到了暂存区： 1git reset HEAD file # `file` 指那个需要回退的文件 再回到情况一，执行，此操作相当于让之前的 git add 失效： 1git checkout -- file # `file` 指那个需要回退的文件 #情况三已提交了不合适的修改到版本库，但还没有推送到远程库: 1git reset --hard HEAD^ 此操作相当于让之前的 git commit -m &quot;修改说明&quot; 失效。 已经将错误的版本提交到远程仓库如果已经将错误的版本提交到远程仓库，想要回退到之前的版本的话，可以有一下几种方式： #方法一(不推荐)本地仓库： 先回退到某一个版本，比如上一个版本 1git reset --hard HEAD^ HEAD^表示上一个版本，HEAD^^则表示上上个版本，再往上 100 个版本可以写成HEAD~100 然后删除远程的 master 分支： 1git push origin:master 最后重新创建远程 master 分支，并将本地仓库中的最新修改提交到远程 master 仓库： 1git push origin master #方法二（慎用）同样先在本地仓库回退到你想回退的版本，然后强制 push 到远程仓库： 1git push --force 注意：这个暴力强制的方式，如果在团队开发的时候，容易造成覆盖掉其他同事的提交的代码的风险，慎用！ #方法三（推荐）采取 revert 的方法，相当于重新生成一个提交，来撤销前一次错误的commit: 1git revert HEAD 然后再把从工作区提交到暂存区，最后推送到远程分支： 123git add .git commit -m "撤销上次提交的修改"git push origin master #分支查看分支使用 git branch 命令列举出工程下面所有的分支列表，用*号标记的分支为当前所在的分支，master 叫做主干分支，是每个在 git 管理下的工程都默认有的。 1git branch 新建分支使用 git branch [branch-name] 命令新建一个分支，如用如下命令新建一个 develop 分支： 1git branch develop 使用 git branch 命令查看一下，现在就建好了 develop 分支： 切换分支使用 git checkout [branch-name] 切换到指定的分支，如使用如下命令切换到 develop 分支： 1git checkout develop 查看一下，当前所在分支已经切换到了 develop 分支： 另外如果使用 git checkout -b [branch-name] 带 -b 标识新建分支，则表示新建一个分支并同时切换到这个新建的分支下面，如再新建一个 develop2 分支并同时切换到这个分支下就可以用如下一行命令搞定： 1git checkout -b develop2 删除分支如果要删除一个分支，使用 git branch -d [branch-name] 命令，如把 develop2 分支删除，就可以使用如下命令： 1git branch -d develop2 注意：如果要删除的分支正是当前所在的分支，则会报错，需要切换到另一个分支，再可以执行删除命令。强制删除分支：git branch -D [branch-name] 命令。 合并分支Fast forward 模式（删除分支后，会丢掉分支信息） 如果在 develop 分支里做了修改，想要把修改合并到 master 分支里面，就要用到合并分支命令 git merge [branch]，如在 develop 添加一个 test.txt 文件，然后合并到 master 分支里去： 123touch test.txt // 添加一个 test.txt 文件 git checkout master // 切换到 master 分支git merge develop // 把 develop 分支中的修改合并到 master 分支 注意：如果在 develop 分支和 master 对同一个文件做了不同的修改的话，则合并的时候会产生冲突，这个时候，需要打开那个冲突的文件，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 到 ======= 线包裹的内容是来自 master 分支，======= 到 &gt;&gt;&gt;&gt;&gt;&gt;&gt; develop 线包裹的内容是 develop 分支中的，需要删除其中一个分支中冲突的内容的包括所有包裹内容的线，然后再进行合并。 禁用Fast forward 模式（Git就会在merge时生成一个新的commit， 从分支历史上就可以看出分支信息。） 1git merge --no-ff -m "合并说明" branch-name 在本地创建和远程分支对应的分支1git checkout -b branch-name origin/branch-name 建立本地分支和远程分支的关联1git branch --set-upstream branch-name origin/branch-name 合并远程不是对应分支的代码有时候如果远程有一条分支更新了一些代码，如newFetrue，fixBug，需要合并到本地，由于和本地不是对应关系，不能直接 pull 拉取合并，可以先在本地新建一个和远程对应的临时分支，然后再去合并这条临时分支上的代码 12345678# develop:远程分支，temp 本地临时分支git fetch origin develop:temp# 合并 temp 分支git merge temp# 合并指定 commitId 的代码git cherry-pick commitId #标签在开发过程中，当发布了一个稳定的版本后，都会给代码带一个标签。主要的 git 命令如下： 新建标签1234567891011# 1. 当前 HEAD 打标签git tag &lt;name&gt;# 2. 给某个 commit 打标签git tag &lt;name&gt; &lt;commit id&gt;# 3. 创建带有说明的标签， 用 `-a` 指定标签名，`-m` 指定说明文字：git tag -a &lt;name&gt; -m &lt;说明&gt; &lt;commit id&gt;# 4. 当前 HEAD 打标签git tag -a &lt;name&gt; -m &lt;说明&gt; 查看标签12345# 1. 查看某一个标签的详情git show &lt;tagname&gt;# 2. 查看所有标签git tag 推送标签到远程12345# 1. 推送标签到远程git push origin &lt;tagname&gt;# 2. 一次性推送所有本地未推送到远程的标签到远程git push origin --tags 删除标签12345# 1. 删除本地标签git tag -d &lt;tagname&gt;# 2. 删除远程标签git push origin :refs/tags/&lt;tagname&gt; #查看历史记录采坑记录1. 仓库太大，clone 太慢碰到一个仓库，仓库代码 500 多兆，通过 http 的方式 git clone 出现报错，报错信息是： error: RPC failed; curl 18 transfer closed with outstanding read data remaining fatal: The remote end hung up unexpectedly 找了找网上的解决方案，主要有两个： 增大 http postBuffer 的空间大小 12345# 全局设置 http postBuffer 的空间大小git config --global http.postBuffer 524288000 // 大概 500 M，不够再自己加# 查看是否设置成功git config -l 但这个方法对我无效。 只 clone 最近的一次提交 123456# clone 最近的一次提交git clone --depth=1 &lt;仓库地址&gt;# 下载该分支下的所有提交记录信息git fetch --unshallow 这样可以很快很轻量的把代码 clone 下来，但这中方式同样会有一个问题，就是只会默认 clone 默认分支下的代码，通常是 master 分支下的代码。接下来就需要用到下面的命令，比如下载日常开发分支 develop 下的代码： 123456# 设置和远程 develop 分支的连接git remote set-branches origin 'develop'# 下载远程 develop 分支下最近的一次提交 git fetch --depth 1 origin develop# 从远处 develop 分支新建一个 develop 的本地分支git checkout -b develop origin/develop]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斯坦福 iOS 开发课程学习笔记（计算器 demo）]]></title>
    <url>%2F2016%2F10%2F27%2F%20%E6%96%AF%E5%9D%A6%E7%A6%8F%20iOS%20%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%AE%A1%E7%AE%97%E5%99%A8%20demo%EF%BC%89%2F</url>
    <content type="text"><![CDATA[参考资料 Developing iOS 9 Apps with Swiftby Stanford 源代码 开发环境 系统：macOS Sierra 10.12 x-code：Version 8.1 (8B62) Swift 3.0 实现？分析需求UI 布局需求 界面 UI 需要做成这样： 还需要适配横屏： 界面元素： 标签（UILable）：显示输入的操作数和计算结果； 按钮（UIButton）：输入操作数和运算符。按钮分类： 数值型按钮： 0，1，2，3，4，5，6，7，8，9 常量型按钮： π，e 一元操作符按钮： √，cos 二元操作符按钮： +，—，×，÷ 计算结果按钮： = 功能需求 输入显示： 当没有在输入状态时，要将点击的按钮代表的操作数显示为标签的文本，如果是数值型按钮，直接显示按钮标题，如果是常量型按钮，显示常量代表的数值，其他类型的按钮按下后不要显示； 当有在输入状态时，要将按下的按钮的标题拼接到标签文本上去，如输入先输入 1，再输入 2， 然后输入 3，则标签依次显示 1， 12， 123，如此类推； 当按下常量型按钮时，要将常量型按钮的数值显示到标签文本上去，如按下 π，标签文本需显示 3.14159265358…； 当按下一元操作符时，需要将一元操作后的计算结果显示到标签文本上去，如先按下 4，然后按下开方 √ 按钮，则应该把 4 开方后的计算结果 2 显示到标签文本上去； 当按下二元操作符或 = 号时，要将当前的计算结果显示到标签文本上去； 计算结果：需要保证计算结果的正确。 写代码第一步实现点击数值型按钮，能够正确显示到标签文本中去： 新建一个 Single View Application: 填写一下工程选项配置： 选择 Main.storyboard, 从 x-code 右下角的控件列表中拖拽一个 UIButton 进来，按住 Ctal 键，将按钮连线到 ViewController 控制器中来，选择 Connect 连接： 选中按钮，按住 option 键，拖动鼠标，另外复制 8 个相同的按钮出来，效果如下： 检查一下按钮的点击响应事件是否有效，在响应事件方法里打印一下按钮的标题，测试一下是否准确打印： 1234@IBAction func touchDigit(_ sender: UIButton) &#123; let digit = sender.currentTitle! print("touch \(digit) digit") &#125; 再从控件列表里面拖拽一个 UILabel 标签控件进来，像按钮一个连线，如下图所示： x-code 自动生成一个隐式解析可选类型(implicitly unwrapped optionals)的 UIlabel 类型的属性： 接下来声明一个标识当前是否正在输入状态的变量 userIsInTheMiddleOfTyping 并初始化： 1var userIsInTheMiddleOfTyping = false // 标识当前是否正在输入状态 实现点击按钮，能够正确显示到标签文本中去，没在输入状态时直接显示按钮标题，连续输入时，需要将按钮的标题拼接到标签文本上去： 1234567891011@IBAction func touchDigit(_ sender: UIButton) &#123; let digit = sender.currentTitle! if userIsInTheMiddleOfTyping &#123; let textCurrentlyInDispaly = display.text! display.text = textCurrentlyInDispaly + digit &#125; else &#123; display.text = digit &#125; userIsInTheMiddleOfTyping = true&#125; 第二步填加常量型按钮，实现点击常量型按钮，标签文本显示正确常量值： 在 Main.storyboard 里复制两个按钮，修改按钮标题为 π 和 e，注意删掉存在的在 ViewController 中 touchDigit: 事件方法连线，重新拉拽到 ViewController 里去，选择 Action，命名为 performOpreation： 在 performOpreation：方法里写代码，实现功能： 1234567891011@IBAction func performOpreation(_ sender: UIButton) &#123; let methemtiaclSymbol = sender.currentTitle! if methemtiaclSymbol == "π" &#123; display.text = String(M_PI) &#125; else if methemtiaclSymbol == "e" &#123; display.text = String(M_E) &#125; userIsInTheMiddleOfTyping = false&#125; 第三步增加一元操作符，点击一元操作符按钮，能将一元操作后的计算结果显示到标签文本上去： 在 Main.storyboard 增加一元运算 √ 和 cos，调取 Emoji &amp; Symbols 输入，快捷键：Ctrl + Commond + Shift，也可以像下图一样调取： 在 performOpreation：方法里增加如下代码： 1234567891011121314151617@IBAction func performOpreation(_ sender: UIButton) &#123; let methemtiaclSymbol = sender.currentTitle! if methemtiaclSymbol == "π" &#123; display.text = String(M_PI) &#125; else if methemtiaclSymbol == "e" &#123; display.text = String(M_E) &#125; else if methemtiaclSymbol == "√" &#123; display.text = String(sqrt(Double(display.text!)!)) &#125; else if methemtiaclSymbol == "cos" &#123; display.text = String(cos(Double(display.text!)!)) &#125; userIsInTheMiddleOfTyping = false&#125; 也可以用 Switch 实现： 123456789101112@IBAction func performOpreation(_ sender: UIButton) &#123; let methemtiaclSymbol = sender.currentTitle! switch methemtiaclSymbol &#123; case "π": display.text = String(M_PI) case "e": display.text = String(M_E) case "√": display.text = String(sqrt(Double(display.text!)!)) case "cos": display.text = String(cos(Double(display.text!)!)) default: break &#125; userIsInTheMiddleOfTyping = false&#125; 可以使用 Ctrl + I 快捷键，快速让选中区域的代码按照苹果官方的代码风格对齐缩进。 第四步增加一个计算型属性，简化代码： 以上功能虽然实现了，但是发现计算每次都要将 String 类型的文本转换成 Double 类型的操作数，计算完成的 Double 类型的结果又要重新转换成 String 类型的文本，很麻烦，而且会造成代码冗余，可以定义一个计算性属性 displayValue，专门用来作计算结果和显示文本的数据类型之间的转换： 12345678var displayValue: Double &#123; get &#123; return Double(display.text!)! &#125; set &#123; display.text = String(newValue) &#125;&#125; 接下来修改 performOpreation：方法里面的代码： 123456789101112@IBAction func performOpreation(_ sender: UIButton) &#123; let methemtiaclSymbol = sender.currentTitle! switch methemtiaclSymbol &#123; case "π": displayValue = M_PI case "e": displayValue = M_E case "√": displayValue = sqrt(displayValue) case "cos": displayValue = cos(displayValue) default: break &#125; userIsInTheMiddleOfTyping = false&#125; 第五步新建一个类，专门负责计算： 以上虽然实现功能，但是不应该把计算相关的代码写到控制器里去，如果计算一复杂，控制器会多很多代码，可读性和逻辑容易混乱，控制器只应该负责把计算结果显示到相关的视图上去就行，其他的事情应该交给专门的类去实现： 选择 Swift File 文件，点 Next 下一步： 新建一个类，命名为 CalculatorBrain，这个类专门负责接收操作数，执行运算，返回结果： 123class CalculatorBrain &#123; &#125; 定义属性和方法，accumulator 属性用来存储操作数以及计算结果，setOperand：方法用来接收操作数，performOperation：方法执行运算过程，result 只读属性返回计算结果： 123456789101112131415class CalculatorBrain &#123; var accumulator = 0.0 func setOperand(operand: Double) &#123; &#125; func performOperation(symbol: String) &#123; &#125; var result: Double &#123; get &#123; return accumulator &#125; &#125; &#125; 然后在 ViewController 里面实例化 CalculatorBrain 类，再到 performOpreation：方法里修改代码为： 1234567891011121314var brain = CalculatorBrain() @IBAction func performOpreation(_ sender: UIButton) &#123; if userIsInTheMiddleOfTyping &#123; brain.setOperand(operand: displayValue) userIsInTheMiddleOfTyping = false &#125; if let methemtiaclSymbol = sender.currentTitle &#123; brain.performOperation(symbol: methemtiaclSymbol) &#125; displayValue = brain.result&#125; 相应地，实现 CalculatorBrain 中的方法： 12345678910111213141516171819202122232425class CalculatorBrain &#123; var accumulator = 0.0 func setOperand(operand: Double) &#123; accumulator = operand &#125; func performOperation(symbol: String) &#123; switch symbol &#123; case "π": accumulator = M_PI case "e": accumulator = M_E case "√": accumulator = sqrt(accumulator) case "cos": accumulator = cos(accumulator) default: break &#125; &#125; var result: Double &#123; get &#123; return accumulator &#125; &#125; &#125; 测试下功能，看效果是不是一样。 第六步优化一下代码： 以上步骤虽然将计算相关的逻辑转移到 CalculatorBrain 类中去了，但是每次都要使用根据不同的运算符，然后在 Switch 中去执行不同的运算，能不能将运算类型进行抽象，使用枚举 Enum 来表示，不同的运算类型对应的运算再用一种数据结构 Dictionary 来表示和存储，这样代码可读性和可扩展性就能提高不少。 首先，定义一个关联值枚举，来存储抽象出的所有的运算类型： 123456 enum Operation &#123; case Constrant(Double) case UnaryOperation((Double) -&gt; Double) case BinaryOperation((Double, Double) -&gt; Double) case Equals&#125; 该枚举将每一种运算类型对应到每一个枚举成员，并给枚举成员设置关联值类型，常量运算关联了一个 Double 类型，一元运算关联了一个 （Double）-&gt; Double 类型的闭包，二元操作运算关联了一个 （Double, Double） -&gt; Double 类型的闭包，Equals 运算没有设置关联值类型。 再定义一个字典，来存储不同的运算符以及对应的运算操作： 123456 var operations: Dictionary&lt;String, Operation&gt; = ["π": .Constrant(M_PI),"e": .Constrant(M_E),"√": Operation.UnaryOperation(sqrt),"cos": Operation.UnaryOperation(cos) ] 通过字典不同的 key, 来给枚举成员设置不同的关联值，并存储在字典里面。 最后修改 performOperation：方法中的代码： 123456789func performOperation(symbol: String) &#123; if let operation = operations[symbol] &#123; switch operation &#123; case .Constrant(let value): accumulator = value case .UnaryOperation(let function): accumulator = function(accumulator) default: break &#125; &#125;&#125; 在 Switch 语句中，关联值可以被提取出来作为 switch 语句的一部分，第一个 case, 关联值是一个 Double 类型的常量，那么提取出来的关联值就是这个常量的值， 第二个 case, 关联值是一个 （Double） -&gt; Double 类型的闭包，那么提取出来的关联值就是这个闭包。 最后，测试一下，看功能是否正常。 第七步实现二元运算： 二元运算不同常量和一元运算，二元运算不是一点击运算符就能知道结果，他是一个表达式，需要两个操作数和操作符都输入了才能计算他的值，所以这里需要定一个一种数据结构来保存二元操作的中间状态，既保存第一个操作数以及运算类型，所以可以定义一个结构体： 1234struct pendingBinaryOperationInfo &#123; var firstOperand: Double var binaryOperation: (Double, Double) -&gt; Double&#125; 定义一个这个结构体类型的属性，并让这个属性是可选类型，因为这个属性有时候需要为 nil,如每一次按 = 按钮计算结束后，这个属性就应该为 nil： 1var pending: pendingBinaryOperationInfo? 在 Main.storyboard 里添加二元操作加，减，乘，除，调整下布局： 相应地，在 operations 字典里添加二元操作的代码，先实现加法： 12345678var operations: Dictionary&lt;String, Operation&gt; = [ "π": .Constrant(M_PI), "e": .Constrant(M_E), "√": Operation.UnaryOperation(sqrt), "cos": Operation.UnaryOperation(cos), "+": Operation.BinaryOperation(add), "=": Operation.Equals] 加法方法： 123func add(op1: Double, op2: Double) -&gt; Double &#123; return op1 + op2&#125; 接下来，在 performOperation：里添加代码： 1234567891011121314func performOperation(symbol: String) &#123; if let operation = operations[symbol] &#123; switch operation &#123; case .Constrant(let value): accumulator = value case .UnaryOperation(let function): accumulator = function(accumulator) case.BinaryOperation(let function): pending = pendingBinaryOperationInfo(firstOperand: accumulator, binaryOperation: function) case.Equals: if pending != nil &#123; accumulator = pending!.binaryOperation(pending!.firstOperand, accumulator) pending = nil &#125; &#125; &#125;&#125; 优化一下，将执行二元运算的操作抽出一个方法来，并且实现只要按一下二元操作符就计算出计算出结果，而不用每次都要按等号： 123456func executePendingBinaryOperation() &#123; if pending != nil &#123; accumulator = pending!.binaryOperation(pending!.firstOperand, accumulator) pending = nil &#125;&#125; performOperation：方法里面代码变成这样： 123456789101112131415func performOperation(symbol: String) &#123; if let operation = operations[symbol] &#123; switch operation &#123; case .Constrant(let value): accumulator = value case .UnaryOperation(let function): accumulator = function(accumulator) case.BinaryOperation(let function): executePendingBinaryOperation() pending = pendingBinaryOperationInfo(firstOperand: accumulator, binaryOperation: function) case.Equals: executePendingBinaryOperation() &#125; &#125;&#125; 第八步利用闭包特性，简化代码： 可以将二元操作的实现用闭包来简化，如加法运算： 12"+": Operation.BinaryOperation(&#123;(op1: Double, op2: Double) -&gt; Double in return op1 + op2 &#125;) 由于使用的枚举成员关联了类型，所以编译器能够根据上下文推断出闭包的参数和返回值类型，于是可以省略掉参数和返回值类型以及箭头和参数周围的括号，简化为： 1"+": Operation.BinaryOperation(&#123;op1, op2 in return op1 + op2 &#125;) 由于闭包函数体只包含了一个单一表达式 (op1 + op2)，按照闭包语法，单表达式闭包可以隐式返回，还可以省略掉 return 关键字： 1"+": Operation.BinaryOperation(&#123;op1, op2 in op1 + op2 &#125;) 还可以简化，闭包自动为内联闭包提供了参数名称缩写功能,可以直接通过 $0, $1, $2 来顺序调用闭包的参数，又由于使用了参数名称缩写，又可以省略参数列表，in 关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成: 1"+": Operation.BinaryOperation(&#123;$0 + $1&#125;) 同理，实现其他的减，乘，除二元运算： 123"−": Operation.BinaryOperation(&#123;$0 - $1&#125;),"×": Operation.BinaryOperation(&#123;$0 * $1&#125;),"÷": Operation.BinaryOperation(&#123;$0 / $1&#125;), 测试一下，看功能是否能实现？ 第九步给各个方法属性添加访问权限： 其实这一步在每定义一个方法和属性的时候就应该做，最好刚开始都先添加 Privite 权限，这样后面如果调用需要再一个个修改成其他权限，这样影响比较小，也更安全，如果反过来，则会让很多已经调用该方法或者引用了该属性的其他对象瞬间报错。 可以通过如下的操作查看类的公共接口： 默认是 internal 权限，表示对外是可访问的 而这里有些属性和方法是不应该暴露给外界的，所以应该设置为 private 访问权限，不让其他类访问。 对于 CalculatorBrain 类，只需要给外界暴露 setOperand：和 performOperation：方法还有 result 计算属性就可以了。 第十步布局 UI，适配横竖屏 现在功能做完了，最后一步，需要把 UI 布局好，需要不管哪种屏幕，不管横竖屏，都要适配好。这里需要用到 iOS 推出的一个新的概念 UIStackView： 首先选中最下面一排四个按钮，如下图操作，插入一个 StackView： 接下来到右边的属性观察器里设置一些属性，Distribution 选择 Fill Equally，Spaceing 选择 10， 同理，重复这样的操作选择后面四排按钮，同样的操作分别设置好 StackView： 接下来选择这五个设置好了的 StackView, 在给这五个 StackView 设置一个 StackView： 然后，同时选中最上面的标签以及最大的那个 StackView，再给他们设置一个 StackView 进来： 最后设置约束，首先选中最后设置的那个最大的那个 StackView，按住 Ctrl 键，向上拖线，放手，在弹出的选择视图里面选择对顶部的垂直距离固定，然后选中弹出的那个线，到右边属性观察器里面修改约束值为 0： 依次同样的操作设置好左，右，底部的约束，然后就会变成这样，这样整个 UI 不管在横竖屏或者各种尺寸的设备都保持对上下左右的距离都固定。 好了，看下运行效果： 好，做完了…… 设计 / 思路分析需要建哪些类？类的职能？ 视图控制器 ViewController， 类职能：控制视图的生命周期，管理视图，响应视图上的各种点击、触摸等事件； CalculatorBrain，类职能：接收操作数和运算符，计算出结果，并返回出去； 类?类里面需要定义哪些属性，方法, 数据结构，类型、职能是什么？哪些是私有的，哪些是公有的？ ViewController 属性： 属性 类型 职能 访问权限 display UILable! 显示文本 private userIsInTheMiddleOfTyping Bool 标识是否正在输入 private displayValue Double 计算型属性，将 display 显示的 String 类型文本返回为 Double，将输入的 Double 类型的操作数装换为 String 类型显示到 display 的文本 private brain CalculatorBrain 类 类实例，专门用来接收操作数和运算符，计算出结果，并返回出去 private 方法 方法 类型 职能 访问权限 touchDigit Method 事件方法 监听按钮的点击事件，用来输入操作数 private performOperation Method 事件方法 监听按钮的点击事件，用来执行计算过程 private CalculatorBrain 属性： 属性 类型 职能 访问权限 accumulator Double 存储操作数 private operations Dictionary&lt;String, Operation&gt; 存储运算符以及运算符对应的实际运算操作 private pending PendingBinaryOperationInfo Struct 结构体 存储二元操作的第一个操作数以及二元操作类型 private result Double 只读属性，返回计算结果 public 方法 方法 类型 职能 访问权限 setOperand 实例方法 接收操作数 public performOperation 实例方法 执行运算操作 public executePendingBinaryOperation 实例方法 执行二元运算操作，并将运算结果赋值给 accumulator private 结构体 结构体 类型 职能 访问权限 PendingBinaryOperationInfo Strcut 保存二元操作的相关信息，包括是什么二元操作，和第一个操作数 private 枚举 枚举 类型 职能 访问权限 Operation Enum 带关联值的枚举，存储运算的操作类型 private 调用关系 测试 是否适配好了横竖屏？ 所有的功能需求是否都已实现？ 边际值和异常情况是否考虑完全？ 是否编写单元函数测试？ 优化？现在的代码有什么 bug ?是否存在代码冗余？是否能重构？总结？语法知识点隐式解析可选类型(implicitly unwrapped optionals)概念如果一个可选类型第一次被赋值之后,可以确定以后总会有值。就可以使用隐式解析可选类型。 一个隐式解析可选类型其实就是一个普通的可选类型,但是可以被当做非可选类型来使用,并不需要每次都使用 ! 解析来获取可选值。 可以把隐式解析可选类型当做一个可以自动解析的可选类型。 注意：同样，在隐式解析可选类型没有值的时候尝试取值,会触发运行时错误。所以，如果一个变量之后可能变成 nil 的话请不要使用隐式解析可选类型。如果需要在变量的生命周期中判断是否是 nil 的话，请使用普通可选类型。 扩展 可选是一种枚举： 1234enumOptional&lt;T&gt;&#123; case None case Some(T) &#125; 可选可以成链式（chained）： 12345678var display: UILabel? // 假设 display 没有被定义成隐式解析可选的 UILabel 类型 if let label = display &#123; if let text = label.text &#123; let x = text.hashValue ... &#125;&#125; 可以简化为： 1if let x = display?.text?.hashValue &#123; ... &#125; 可选的默认运算符 “??”(空合运算符) 假设需求：给一个 UIlable 赋值一个 String 类型的文本，如果这个 String 为 nil, 则赋值为“ ”空格。一般需要这样做： 123456let s: String? = ... // might be nilif s != nil &#123; display.text = s&#125; else &#123; display.text = “ “&#125; 但是有更简单的方式实现： 1display.text = s ?? " " 使用空合运算符 ?? 需要满足两个条件： s 是可选类型； 默认值的数据类型需要和可选类型的数据类型一致； 关联值枚举关联值枚举 Switch 值绑定Switch 值绑定 闭包简写闭包简写 访问控制 属性，类，函数等能够进行版本控制的统称为实体。 open：open 是 Swift 3 新增的访问控制符，相较于 public 更加开放。open 和 public 都是可以跨 Module 访问的，但在跨 Module 访问时， open 修饰的类可以继承，修饰的方法可以重写（此时，open 需同时修饰该方法以及所在类），而 public 不可以。至于 public final 与 public，前者在任何地方均不可重写，而后者可在本 Module 内重写。 public：可以访问自己模块或应用中源文件的任何实体，别人也可以访问引入该模块中源文件里的所有实体。通常情况下，某个接口或 Framework 是可以被任何人使用时，可以设置为 public 级别； internal：可以访问自己模块或应用中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体，通常情况下，某个接口或 Framework 作为内部结构使用时，可以将其设为 internal 级别； fileprivate：可在当前源文件内访问所有类的实体； private：只能在当前类中访问使用的实体，称为私有实体。使用 private 级别，可以用作隐藏某些功能的实现细节； 访问优先级：open &gt; public &gt; internal(默认) &gt; fileprivate &gt; private UIStackViewStack View 会自动为每个 subview 创建和添加 Auto Layout constraints。所以可以控制 subview 的大小和位置。可以通过选项配置 subview 的大小、排布以及彼此间的间距。 tips 使用 x-code 代码格式缩进对齐功能，选中一段代码，ctrl + I 组合键； 使用 x-code 输入表情和特殊字符 Emoji &amp; Symbols，Ctrl + Commond + Shift 组合键； 查看源文件的开放接口，如下操作：]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发小 tips 收集]]></title>
    <url>%2F2016%2F10%2F21%2FiOS%E5%BC%80%E5%8F%91%E5%B0%8F-tips-%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[前言先开个坑，记录整理下 iOS 开发中的小 tips… 工具效率1. 查看工程代码行数 cd 到工程文件夹，如果要避免统计到第三方库的代码，应该再 cd 到存放我们自己写的项目文件夹： 打开终端，输入如下命令： 1find . -name "*.m" -or -name "*.h" -or -name "*.xib" -or -name "*.c" |xargs grep -v "^$"|wc -l 注意：这个统计会去掉空行，但是包括注释。 如果需要列出每个文件的行数，则输入这句命令： 1find . -name "*.m" -or -name "*.h" -or -name "*.xib" -or -name "*.c" |xargs wc -l 但是发现一个问题：如果用这句命令，总行数和上一句命令的总行数对不上，可能是没有忽略掉空行吧，不知道那个命令才是表示去掉空行的，困惑？ 2. pod install/update 更新慢 原因：执行以上两个命令的时候会升级 CocoaPods 的 spec 仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： 1234# 安装pod install --verbose --no-repo-update# 更新pod update --verbose --no-repo-update 语言语法踩过的坑1. 特定页面导航栏的隐藏开发者经常碰见这样的需求，总有某些页面需要隐藏导航栏，但是又不能影响到整体项目，如个人中心页面，一般最容易想到的做法是在 viewWillAppear 设置 navigationBar 隐藏，然后在 viewWillDisappear 方法里设置 navigationBar 不隐藏，像这样： 12345678910111213- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES];&#125;- (void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO];&#125; 这样似乎可以解决问题，但是如果这个时候要使用模态视图，prestent 出一个视图，比如常见的弹出登录界面，这个时候就会出现如下的一个不好看的闪动的动画效果，而这并不是我们想要的： #解决方案导航控制器有一个代理方法，可以设置导航控制器的代理为当前控制器，然后在 willShowViewController 代理方法里面隐藏导航栏就可以解决问题了： 1234- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated&#123; [self.navigationController setNavigationBarHidden:YES animated:NO];&#125; 2. 设置 tableViewCell 分割线占满整个 cell 的宽度 先在 cell 的实例化方法中添加如下方法 12345678if ([cell respondsToSelector:@selector(setPreservesSuperviewLayoutMargins:)])&#123; cell.preservesSuperviewLayoutMargins = NO;&#125;if ([cell respondsToSelector:@selector(setLayoutMargins:)])&#123; [cell setLayoutMargins:UIEdgeInsetsZero];&#125; tableView 的 SeparatorStyle 为 UITableViewCellSeparatorStyleSingleLine，separatorInset 为 UIEdgeInsetsZero： 123tableView.separatorStyle = UITableViewCellSeparatorStyleSingleLine;tableView.separatorInset = UIEdgeInsetsZero;tableView.tableFooterView = [[UIView alloc] initWithFrame:CGRectZero]; // 隐藏模拟器上多余的cell分割线 Assertion failure in -[UICollectionViewData validateLayoutInRect:], /SourceCache/UIKit/UIKit-3347.44/UICollectionViewData.m:426iOS 8 系统下 UICollectionView 自定义布局后，刷新 reloadData 方法，当前一个布局还没有结束的时候，就有开始刷新布局，会崩溃，搞了好久，解决方案如下： 重写布局类 UICollectionViewLayout 的 prepareLayout 布局方法，在每一次开始布局前，是原有的布局失效 12345- (void)prepareLayout&#123; [super prepareLayout]; [self invalidateLayout];&#125; 其他]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一点感受]]></title>
    <url>%2F2016%2F09%2F23%2F%E4%B8%80%E7%82%B9%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[碎碎念现在是2016年9月23号下午三点半，距离六点下班还有一点时间，希望能完成这篇文章。写写最近的感受，反正基本没有人能看到，哈哈，写写，希望能释怀一下！ 前几天中午和一个安卓的同事一起出去吃午饭，路上聊天，说道现在已近九月份了，马上国庆七天假，国庆回来2016年还能有两三个月的工作时间了，一年就过去了，时间过得可真快啊。可是呢，好像生活和工作都过得没有激情，理想和现实之间的差距让人特别无奈、沮丧。方向感缺失，要学的东西太多，又沉不下心来，不知从何入手，能联系的朋友越来越少，越来越觉得孤独，可又不想花时间去结交新朋友，出去吃喝玩乐，闲着没事的时候就开始回忆之前上学的时光，上学的时候渴望快点毕业，快点出去工作赚钱，现在想来读书的时光才是最好的时光，虽然也有考试课业的压力，但也青春过，玩过，遇到的人也真诚，也有一些好朋友在旁边，有激情有小伙伴一起去做一些喜欢的事情。。。 关于工作写点对工作的感受吧，毕竟对很多人而言，工作上班占据了生活的大部分时间。 2015年6月走出校门，来到深圳——一座改革开放30年来发展最腾飞的城市。起初，和几个不认识的朋友一起合租在一个八人间，400/月的房租，八月份找到了工作，搬了，也是现在的住处，一个人住，开始有点不习惯，每次下班回来都空落落的，和以前热闹的大学宿舍氛围不同，时间好像过得很慢。特别是周末，一觉睡起来阳光照到脸上的时候，心里是落寞的，好在刚进公司的时候，很多都不懂，也经常加班，周末也会去公司加班，工作成为我生活的所有节奏，慢慢地感觉好好了，新公司也认识了几个和我一起的同龄人，也能聊聊天，但工作后发现同事之间的关系总是很难走的很近，很难交心，这或许就是职场的生存法则吧，因为说不定明天坐你身旁的同事就离职了，我想正是这种不确定性让进入职场的人们更愿意选择君子之交淡如水吧，看惯了聚散离别，或许就成熟了，也麻木了吧! 转折发生在2016年春节后上班，年后来上班，公司内部人心慌慌，P2P创业公司，资金链断裂，工资发不出来，投资人的钱打了水漂，网上一大堆公司的负面新闻，大家都没心情工作了，最终，公司还是倒闭了，一家创办了快三年的创业公司经过两年多腾飞式的扩张发展，被政府整顿关停，老板也被关进拘留所了，上千号人瞬间都失业了，到现在我也还有一个月多的工资没有领到，估计是再也领不到了。于是，大家都开始重新找工作，投简历，各自踏上各自新的征程了。一座城市虽然小，可是散了就真的再也见不到了，那么近却又那么远。 二月底，忙完劳动局讨薪的事情就开始重新找工作了，还算幸运，碰到了现在的这家公司（也就是现在的领导）的CTO开始组建技术团队，一些之前项目组和旧公司的同事又成为了同事，团队差不多一个月左右就建起来了，领导对我们也很好，可是公司对于做什么方向的产品还没有一个很明确的方向，各部门之间的协同交流效率也不是很高，一直到现在都还没一个能有一个拿得出手的产品出来，心里多少有愧，领导交办给我的申请苹果企业账号的事情也没办好，感觉好沮丧，很有挫败感。希望团队能早点找到一个明确的方向，大家齐心做一款产品出来，这是我希望的。 关于职业今年，有几个做开发的同学转行了，去做别的了。有时候会在想，自己喜不喜欢程序员这份工作呢，我说不上非常喜欢，好像我也没有非常喜欢某样东西，我觉得我不是特别讨厌，或者只是因为不喜欢A或C，只能选择B吧。都说这是一个最好的时代，创业的黄金时代，程序员的黄金时代，也是少数靠自己实力而不用靠别人脸色就能生存的行业，我很喜欢后面那句话。 人一切痛苦的本质，是对自己无能的愤怒！想要快乐，就努力让自己变得更强吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于推送的实时聊天功能实现]]></title>
    <url>%2F2016%2F09%2F16%2F%E5%9F%BA%E4%BA%8E%E6%8E%A8%E9%80%81%E7%9A%84%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言最近做项目，遇到要做一个实时推送的聊天功能的需求，开发完成，把实现的细节和步骤以及遇到的问题记录一下。 效果不废话，先看效果： 原理 利用极光实时推送，客户端端发消息发送给服务端，服务端再把消息发送给极光服务器，极光服务器把接收到的消息发送给苹果服务器，苹果服务器最后把消息推送到另外一个客户端手中。由于iOS和andriod双平台，所以需要和服务端定义好协议以及设置好标签（tags），别名（alias）。这样才能实现张三发送给李四的消息，只有李四能收到，李四回给张三的消息也只有上三能收到。就是一个客户端发送指定的内容到指定的客户端（可能是一个，也可能是一多个），这些指定的客户端能收到指定的内容。 步骤界面搭建一个基本的聊天界面。包括输入框，消息的展示，消息时间的处理，键盘的弹出隐藏，输入框高度的动态增长等这些基本的功能点： 监听键盘弹出和隐藏在控制器viewDidLoad视图加载完毕的方法中接收键盘弹起和隐藏的通知：UIKeyboardWillChangeFrameNotification，键盘frame改变的这个通知，已经包含了键盘的弹出和隐藏，避免了写两个通知方法，通知响应事件，只需要到键盘frame变化以及动画时间，就可以通过该变输入框的约束从而达到输入框随着键盘的弹出而弹出，隐藏和降落，动画时间也是一样 123456789101112131415161718- (void)keyboardWillChangeFrame:(NSNotification *)note&#123; CGRect beginFrame = [[note.userInfo objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue]; CGRect endFrame = [[note.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue]; CGFloat duration = [note.userInfo[UIKeyboardAnimationDurationUserInfoKey] doubleValue]; CGFloat delta = (endFrame.origin.y - beginFrame.origin.y); // 动画 [UIView animateWithDuration:duration animations:^&#123; [self.chatInputToolBarView mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.bottom.mas_equalTo(-(kAllHeight - endFrame.origin.y)); &#125;]; CGFloat contentOffsetY = self.mainTableView.contentOffset.y - delta; self.mainTableView.contentOffset = CGPointMake(0, contentOffsetY); [self.view layoutIfNeeded]; &#125;];&#125; 消息的展示每次接受到新消息或者发送一条消息，都需要把最新的消息顶到表格的最底部，先更新数据源，再更新表格视图： 123456[self.mainTableView beginUpdates];[self.messageDataArray addObject:message];[self.mainTableView insertRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:self.messageDataArray.count inSection:0]] withRowAnimation:UITableViewRowAnimationBottom];[self.mainTableView endUpdates];[self scrollToBottom]; 将消息滚动到最底部： 1234567891011- (void)scrollToBottom&#123; //1.获取最后一行 if (self.messageDataArray.count == 0) &#123; return; &#125; NSIndexPath *lastIndex = [NSIndexPath indexPathForRow:self.messageDataArray.count inSection:0]; [self.mainTableView scrollToRowAtIndexPath:lastIndex atScrollPosition:UITableViewScrollPositionBottom animated:NO];&#125; 消息时间的处理规则：今天的消息只显示小时和分钟，昨天的消息显示昨天：时：分，昨天以前的消息显示具体的年月时时分，同一个小时发送的消息时间只显示一次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273+ (NSString *)getVSTChatFormatTime:(long long)time&#123; //1.获取当前的时间 NSDate *currentDate = [SYTimeManager getCurrentDate]; // 1.1获取年，月，日 NSInteger currentYear = [SYTimeManager getYearWithDate:currentDate]; NSInteger currentMonth = [SYTimeManager getMonthWithDate:currentDate]; NSInteger currentDay = [SYTimeManager getDayWithDate:currentDate]; //2.获取消息发送时间 NSDate *msgDate = [NSDate dateWithTimeIntervalSince1970:time]; // 2.1获取年，月，日 NSInteger msgYear = [SYTimeManager getYearWithDate:msgDate]; NSInteger msgMonth = [SYTimeManager getMonthWithDate:msgDate]; NSInteger msgDay = [SYTimeManager getDayWithDate:msgDate]; //3.判断: /* 今天：(HH:mm) 昨天: (昨天 HH:mm) 昨天以前:（2016-07-27 16:07） */ NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; if (currentYear == msgYear &amp;&amp; currentMonth == msgMonth &amp;&amp; currentDay == msgDay) &#123; // 今天 dateFormat.dateFormat= DateFormat_Hm; &#125; else if(currentYear == msgYear &amp;&amp; currentMonth == msgMonth &amp;&amp; currentDay - 1 == msgDay) &#123; // 昨天 dateFormat.dateFormat= [NSString stringWithFormat:@"昨天 %@",DateFormat_Hm]; &#125; else &#123; // 昨天以前 dateFormat.dateFormat= DateFormat_yyyyMdHm; &#125; return [dateFormat stringFromDate:msgDate];&#125;// 比较两个时间是否在同一个小时内,若是，返回YES,否返回NO+ (BOOL)isSameHourTime:(long long)timeA time:(long long)timeB;&#123; NSDate *dateA = [NSDate dateWithTimeIntervalSince1970:timeA]; NSDate *dateB = [NSDate dateWithTimeIntervalSince1970:timeB]; // 获取年月日 NSString *tempStringA = [SYTimeManager getTimeWithDate:dateA format:DateFormat_yMd]; NSString *tempStringB = [SYTimeManager getTimeWithDate:dateB format:DateFormat_yMd]; // 获取小时 NSInteger hourA = [SYTimeManager getHourWithDate:dateA]; NSInteger hourB = [SYTimeManager getHourWithDate:dateB]; if (hourA == hourB) &#123; // 日期也需要一样 if ([tempStringA isEqualToString:tempStringB]) &#123; return YES; &#125; return NO; &#125; else &#123; return NO; &#125;&#125; 消息背景图片的拉伸一般UI设计师会切一张有四个角的小图片，我们应该根据消息文本的长度和高度进行拉伸，但是要保留四个角，只拉伸证件部分，有两种做法，一种是用代码实现，另一种是通过Assets.xcasses的Show Slicing实现，推荐使用第二种，直观和方便： 中间四条线框住的区域才是可以被拉伸的，其他四个角都是不会被拉伸，另外还可以在左边的属性栏中设置left,right,top,bottom四个方向上的值。拉伸的模式有平铺和拉伸两种。 动态增长输入框高度当输入多行文本的时候，输入框的高度要随着输入文字的换行而自动增长，首先需要监听textView的- (void)textViewDidChange:(UITextView *)textView代理方法，当输入的文本换行时，动态增加输入框的高度： 123456789101112131415161718192021222324252627282930313233343536 // 1.计算TextView的高度， CGFloat textViewH = 0; CGFloat minHeight = textViewDefaultHeight; //textView最小的高度 CGFloat maxHeight = textViewMaxHeight; //textView最大的高度 // 2。获取contentSize的高度 CGFloat contentHeight = textView.contentSize.height; if (contentHeight &lt; minHeight) &#123; textViewH = minHeight; &#125; else if (contentHeight &gt; maxHeight) &#123; textViewH = maxHeight; &#125; else &#123; textViewH = contentHeight; &#125; // 3.加个动画[UIView animateWithDuration:0.25 animations:^&#123; CGRect textViewF = textView.frame; textViewF.size.height = textViewH; textView.frame = textViewF; [self.chatInputToolBarView mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.height.mas_equalTo(textViewH + 2 * margins_V); &#125;]; [self.view layoutIfNeeded];&#125;];// 4.光标回到原位[textView setContentOffset:CGPointZero animated:YES];[textView scrollRangeToVisible:textView.selectedRange]; 推送极光推送下载好极光最新的SDK，在极光官网创建应用，创建开发、生产环境的服务端证书，APP描述文件，配置好AppKey，JPushChannel，在应用程序didFinishLaunchingWithOptions启动极光推送，分8.0系统前后两种不同的方法，通知形式有Badge角标，Sound声音，Alert横幅： 12345678910111213141516171819202122232425262728293031323334if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 8.0) &#123; // categories [JPUSHService registerForRemoteNotificationTypes:(UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert) categories:nil]; &#125; else &#123; // categories nil [JPUSHService registerForRemoteNotificationTypes:(UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound | UIRemoteNotificationTypeAlert) categories:nil]; &#125; // Required // [JPUSHService setupWithOption:launchOptions] // pushConfig.plist appKey // 有广告符标识IDFA（尽量不用，避免上架审核被拒）// NSString *JPushAdvertisingId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];// [JPUSHService setupWithOption:JPushOptions// appKey:JPushAppKey// channel:JPushChannel// apsForProduction:JPushIsProduction// advertisingIdentifier:JPushAdvertisingId];// 或无广告符标识IDFA（尽量不用，避免上架审核被拒）[JPUSHService setupWithOption:options appKey:JPushAppKey channel:JPushChannel apsForProduction:JPushIsProduction];注册极光推送，传deviceToken过去：- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; [JPushManager JPushRegister:deviceToken];&#125; 前台配置要想推送给指定的客户端，就需要绑定别名： 123456789101112/// 绑定别名（注意：1 登录成功或者自动登录后；2 去除绑定-退出登录后）+ (void)JPushTagsAndAliasInbackgroundTags:(NSSet *)set alias:(NSString *)name&#123; // 标签分组（表示没有值） NSSet *tags = set; // 用户别名（自定义值，nil是表示没有值） NSString *alias = name; NSLog(@"tags = %@, alias = %@(registrationID = %@)", tags, alias, [self registrationID]); // tags、alias均无值时表示去除绑定 [JPUSHService setTags:tags aliasInbackground:alias];&#125; 后台配置需要和客户端这边协商，联调，设置同样的标签和别名，以JSON字符串的形式将消息内容推送过来 接收推送消息有新消息过来，需要去接收，然后显示在表格的最底部： 123456789- (void)receiveJPushMessage:(NSNotification *)notification&#123; NSDictionary *dict = notification.object; NSString *dictString = dict[@"objectId"]; NSDictionary *resultDict = [NSString jsonDictWithString:dictString]; ECSJPushContentModel *contentModel = [ECSJPushContentModel yy_modelWithJSON:resultDict]; VSTChatMessageModel *message = getChatMessageModel(contentModel.content, contentModel.sourceAccount, contentModel.account, contentModel.sendTime); &#125; 跳转到指定页面当有消息进来，如果应用在后台或者被杀死，则需要点击推送消息横幅跳转到指定页面，总共有应用在前台，后台，应用被杀死三种情况需要考虑： 应用在前台，应用在后台12345678910111213141516171819202122232425262728- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler&#123; DLog(@"2-1 didReceiveRemoteNotification remoteNotification = %@", userInfo); // apn 内容获取： [JPushManager JPushHandleRemote:userInfo fetchCompletionHandler:completionHandler]; DLog(@"2-2 didReceiveRemoteNotification remoteNotification = %@", userInfo); if ([userInfo isKindOfClass:[NSDictionary class]]) &#123; NSDictionary *dict = userInfo[@"aps"]; NSString *content = dict[@"alert"]; DLog(@"content = %@", content); // [SYNotificationManager postNotificationJPush:dict]; [SYNotificationManager postNotificationJPush:userInfo]; &#125; if (application.applicationState == UIApplicationStateActive) &#123; // 程序当前正处于前台 &#125; else if (application.applicationState == UIApplicationStateInactive) &#123; // 程序处于后台 // do something &#125;&#125; 应用被杀死123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. // 保存推送信息启动APP NSDictionary *notification = [launchOptions objectForKey: UIApplicationLaunchOptionsRemoteNotificationKey]; if ([NSDictionary isValidNSDictionary:notification]) &#123; [SYUserDefaultManager SaveRemoteNotification:notification]; &#125; return YES;&#125; 然后再视加载完毕后进行跳转 遇到的问题注意1：标签和别名的组成规则，之前用用户名设置，但是用户名出现了.这个非法字符，导致设置标签和别名失败，从而导致张三发给李四的消息，李四却收不到的问题。 12345678910错误码定义Code 描述 详细解释6001 无效的设置，tag/alias 不应参数都为 null 6002 设置超时 建议重试6003 alias 字符串不合法 有效的别名、标签组成：字母（区分大小写）、数字、下划线、汉字。6004 alias超长。最多 40个字节 中文 UTF-8 是 3 个字节6005 某一个 tag 字符串不合法 有效的别名、标签组成：字母（区分大小写）、数字、下划线、汉字。6006 某一个 tag 超长。一个 tag 最多 40个字符 中文 UTF-8 是 3 个字节6007 tags 数量超出限制。最多 100个 这是一台设备的限制。一个应用全局的标签数量无限制。6008 tag/alias 超出总长度限制。总长度最多 1K 字节 注意2：跳转要等视图控制器加载完了才能去做跳转，特别是应用被杀死后收到推送消息进行跳转，在APP完毕的方法里面可以先把推送消息保存起来，等到视图控制器加载完毕后，再执行跳转操作。 注意3：算消息cell高度时,如果是用自动布局算的: 123// 使用自动布局后,直接让系统自动算出cell高度self.mainTableView.estimatedRowHeight = 120.0;self.mainTableView.rowHeight = UITableViewAutomaticDimension; 则将表格拉倒最底部或者最顶部的方法就会失效，所以，这个使用自动布局算cell高度只适用于cell只是静态展示，没有动态编辑的情况，如果cell需要动态的编辑，比如增删cell,cell上的控件有交互效果，就不能用系统自动去算高度了。 参考链接总结]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>聊天</tag>
        <tag>推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 苹果企业开发者账号申请实践]]></title>
    <url>%2F2016%2F06%2F21%2F2016%E8%8B%B9%E6%9E%9C%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[苹果开发者账号分类 个人。99美元，可以上传到APP Store,限制最大开发设备安装数100台，不能多人协作开发，可以申请升级为公司账号。 公司。99美元，可以上传到APP Store,限制最大开发设备安装数100台，能多人协作开发,申请需填写邓白氏编码。 企业。299美元，不可以上传到APP Store, 不限制最大开发设备安装数，能多人协作开发,申请需填写邓白氏编码 申请目的 给企业用户进行内部测试，使用企业账号生成的证书打包的APP没有安装设备数量的限制，但不能上传到AppStore,可以放于企业官网或者第三方分发渠道供用户下载安装。 准备工作 VISA或者万事达信用卡 公司邮箱 公司网站（需和邮箱后缀一致） Apple ID 公司英文名称 公司总部座机号 公司邓白氏编码 公司英文地址 邮政编码 申请步骤申请Apple ID 登录苹果开发者主页,拉到最下面。选择Developer Program 同样拉到页面最下面，选择Enterprise Program 来到页面中间，选择Get started with enrollment，开始： 接下来这个页面，苹果将会告诉我们申请企业开发者账号需要哪些材料，依旧拉到下面，点击Start Your Enrollment按钮 这时如果没有登录Apple ID的话会自动弹出Apple ID的登录界面,如果有的话就直接登录，没有的话就需要创建一个新的Apple ID，点击 资料填完后，直接点击Continue按钮 登录申请时填写的邮箱，就会收到苹果发过来的验证码，将验证码填进去，再点击Vertify按钮，进行验证 申请邓白氏编码 验证邮箱成功后，Apple ID就注册好了，接下来回到之前的注册登录页面，用刚注册好的Apple ID登录。 登录成功后，来到Apple Developer Enterprise Program Enrollment页面,Entity Type类型选择Company / Organization 如果没有申请邓白氏编码，则需要去申请邓白氏编码后才能继续，点击Check Now按钮，我这边已经申请过邓白氏编码，申请可参考简书上Apple 公司开发者账号&amp;邓白氏码申请记录或者2016年最新苹果开发者账号注册申请流程最强详解这两篇帖子。如果已申请，则点击continue按钮，进入下一步: 申请企业开发者账号 进入下一步后，就开始填写资料 填完资料后检查一遍没问题后点击下面的continue按钮，来到确认页面，进入最终的信息确认 检查完毕后，点击Submit按钮，提交申请，如果一切都填正确后，会出现Your enrollment is being processed.提示，表示申请已被受理，接下来就是等待了,等待付款…. 苹果会发一封申请在处理中国的邮件过来，也可以到开发者主页中的个人账户中查看申请进度。 注意事项 最好用safari浏览器操作，申请前最好清除cookie 公司邮箱须和网站的域名保持一致，既邮箱@后面为公司的域名 填写的姓名须和Apple id账户中的个人信息保持一致 公司信息须和申请邓白氏编码时填写的信息保持一致 最好关闭翻墙，因为翻墙容易造成当前电脑的IP与当前所在地的IP不一致 如果收不到验证邮件，请到邮箱垃圾箱中查看，很可能是默认把苹果的验证邮件给单做垃圾邮件拦截了 最好有一个笔记，记录需要填写的信息和步骤，防止一次不通过后每次都要重复手写，也可以给当做一次实践经验，以后要用到的时候可以方便查看 遇到的问题 与苹果客服交流过，如果是集团公司，用子公司的邓白氏认证的账号申请的只能用在子公司，如果要整个集团都要能使用，苹果要求使用母公司当做账号主体去申请。 申请时填写的资料需要和邓白氏编码上的资料一致，座机电话，联系人信息一定要先确认能联系到自己。验证人电话填自己的领导，并且要和领导沟通，让他接听电话时确认你的身份。一定要接到苹果打来的验证电话，如果接不到，申请会被终止。两次用同一个账号去申请都没接到验证电话，第三次就要很长时间了。 千万一切准备详细了再去申请，一旦错了两次，后面申请都是漫长的过程。 苹果客服（需要提供caseNumber） 苹果中国客服：4006-701-855 美国客服：001-916-399-7000 接通电话后是英文提示，需要输入分机号码按#号结束。然后会是一个中国人接的。通过她才能联系到主管的审核团队，无法直接联系审核团队。 回答苹果的验证电话时一定要小心，邓白氏上的资料和申请企业账号时填写的资料还有回答苹果验证电话时的信息一定要三方都对的上，还有苹果打来验证电话问到申请企业账号用来干嘛，一定要回答是企业内部测试。 一定要向领导说明目前的现状，不要自己背锅。由于近几年苹果的审核政策越来越严苛，有很多公司的申请都没有成功，所以企业账号不一定能申请通过，另外，申请周期可能会比较长。如果实在没有申请通过，考虑是否能从淘宝上买？当然淘宝上也不一定能买到。 邓白氏资料修改。邮箱：applecs@dnb.com，负责对接苹果这边的华夏邓白氏公司电话： 021-26107504.邮件需要用英文写，说明当初申请时填写的资料，然后告知要修改那些内容，理由。 参考资料 2016年最新苹果开发者账号注册申请流程最强详解！ 299$的企业开发者账号申请流程 Apple 公司开发者账号&amp;邓白氏码申请记录 如何申请邓白氏编码（DUNS码) 【记录】申请苹果开发者账号但失败出现：An Unknown error occurred 总结 申请开发者账号是一个iOS开发者经常要碰到的问题，凡事多实践，多总结，就会多一些经验]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>开发者账号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 初体验]]></title>
    <url>%2F2016%2F06%2F02%2FHTML5%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[前言 随着移动互联网的火热，html5技术的成熟，越来越多的APP都采用了混合编程的模式，这是一个趋势。既在原生APP里面嵌入大量的HTML5网页，综合了原生和html5各自的优势。所以作为一个APP开发从业人员，掌握html5开发已成为了职业发展的必备技能。 效果 开发工具WebStorm The smartest JavaScript IDE Lightweight yet powerful IDE, perfectly equipped for complex client-side development and server-side development with Node.js 代码1234567891011121314151617181920212223242526272829303132 &lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;关于我们&lt;/title&gt; &lt;link hre/Users/chenliangjing/Desktop/未命名文件夹f="css/aboutUs.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body style="background-color: #f0f0f0; position: relative"&gt; &lt;!--vstlogo图片--&gt;&lt;div style="height: 130px;text-align: center"&gt; &lt;img src="images/vst_aboutUs.png" style="margin-top: 40px;width: 90px"&gt;&lt;/div&gt; &lt;!--vst简介--&gt;&lt;div id="main"&gt; &lt;div&gt;伟仕佳杰，为全球超过一百二十几个顶尖ICT品牌创建增值服务， 打造由企业级系统、T服务和分销三大核心部分组成的完整业务体系， 产品覆盖智能终端、移动互联、数码外设、基础网络、存储方案、软件与服务、 信息安全、物联应用、云计算、大数据等领域，以优秀的企业信誉和雄厚的资金实力 服务于超过27000个合作伙伴平台。 &lt;/div&gt;&lt;/div&gt; &lt;!--vst官网--&gt;&lt;div id="footer"&gt; &lt;div&gt;伟仕佳杰&lt;/div&gt; &lt;a href="http://ecschina.com" target="_blank"&gt;ecschina.com&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CSS12345678910111213141516171819202122232425262728293031323334353637html,body&#123; margin: 0; padding:0; height: 100%;&#125; #main&#123; margin: 0 auto; padding-bottom: 40px;/*等于footer的高度*/&#125; #main div&#123; margin-right: 12px; margin-top: 20px; margin-left: 12px; font-size: 12px; color: #646464&#125; #footer &#123; text-align: center; position: absolute; bottom: 20px; width: 100%; height: 40px;/*尾部的高度*/&#125; #footer div&#123; /*margin-bottom: 8px;*/ font-size: 15px;&#125; #footer a&#123; color: #646464; font-size: 11px; text-decoration: none; /*去除下划线*/&#125; 总结这是一个最简单的一个html5页面，只有网页和层叠样式，没有JS交互，嵌在原生APP中，跨平台，真正地write once,run everywhere！接下来想学习JavaScript，开发复杂一点的网页出来，go!]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的个人技术博客搭建之旅]]></title>
    <url>%2F2016%2F05%2F01%2F%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[为什么要建站？ 从事iOS开发工作快一年了，一直觉得自己的能力提高的比较慢，想要快点提高自己的技术水平，因为这是一个快鱼吃慢鱼的社会 写博客可以督促自己养成良好的学习、思考、记录、总结的习惯 之前的学习大都参考了很多牛人的博客。从他们的博客中已经学到了很多有用的知识和技术。程序员是一个伟大的职业，受到启发，想成为一个真正的程序员 互联网时代，人人都是自媒体。个人博客是一个平台，可以用来展示自己，建立自己的个人品牌 分享是一种美德。人人为我，我为人人 为什么要建独立的个人博客？ 喜欢自由，个人独立博客，可编辑定制空间大，不像第三方的博客系统，有很多不受自己控制的地方，比如文章页面出现广告，体验很不好 自己动手搭建博客，可以顺便学习到一些网页，写作方面的知识或技能 酷，有趣。程序员都追求酷，自己折腾，自己瞎改，改主题，改配置，改风格，绑定个性化的独立域名，甚至自己开发一套自己喜欢和满意的主题，一切都那么有趣和美好 原理 GitHub会为每一个注册用户分配一个300M的个人空间，所以和hexo结合起来，利用github给我们的免费空间，将我们的静态网页托管到上面，就实现了一个免费的搭建个人博客的方案。 主要涉及的技术名词 Mac OS Git GitHub Pages Hexo Node.js npm Mou Markdown Sublime Jacman GoDaddy Gitcafe 如有不懂，请先google, 然后百度，反正我是这么做的 主要步骤注册GitHub帐号，新建代码仓库 登录GitHub网站，注册一个帐号 新建一个代码仓库 填写仓库信息，其中仓库名称必须和用户名一样 环境配置 安装git。由于我使用的是MAC OS系统，自带了git功能，如果是其他系统，安装一个git客户端软件即可 安装Node环境，Hexo就是基于Node的，访问速度特别快。进入node.js官网，选对操作系统，安装即可 安装Hexo，初始化博客 git和node环境安装好了以后。接下来就可以安装hexo了，直接在命令行中敲入如下代码： 1$ npm install -g hexo-cli 接下来建站 123$ hexo init &lt;folder&gt; # 初始化博客，&lt;文件夹名称&gt;，表示文件会下载到当前目录下的这个文件夹内$ cd &lt;folder&gt; # 进入到这个文件夹目录$ npm install # 安装npm 使用相关编辑器打开这个文件夹&lt;folder&gt;中的文件夹，我是用的是subLime 本地预览1$ hexo server # 开启本地服务器 然后在浏览器里面输入网址http://localhost:4000，就能看到默认主题的界面 这是因为初始化hexo的时候就已经把一个能够起小型的网路服务器功能的依赖装好了，所以启动一下这个本地服务，就能看到hexo的默认主题 上传到远程代码仓库接下来就要将本地的代码上传到远程github仓库。首先建立和之前新建的代码仓库之间的关联，利用ssh key，具体是先用命令行在本地生成一个ssh key，然后复制到github上去。 （1）先检查本地有没存在ssh key 1$ ls -al ~/.ssh # 列出在.ssh文件夹下所有的文件，如果存在这个文件夹或者这些文件的话 （2）生成新的ssh key 1$ ssh-keygen -t rsa -C "your_email@example.com" # 注意将`your_email`替换成之前注册github帐号时的邮箱 生成成功后进入到~/.ssh/id_rsa.pub路径下，用文件编辑器打开id_rsa.pub文件，里面的内容就是ssk key，将内容复制到剪切板 登录GitHub网站,依次点击Settings –&gt; SSH and GPG keys –&gt; New SSH key，进入新建SSK key页面，随便填写一下Title,然后将剪切板中复制好的ssh key复制到key中去，最后点击Add SSH key按钮，就OK了 用subLime打开博客主目录，找到主目录在的_config.yml文件，编辑这个文件，找到最下方deployment模块（顺便找到Site模块，修改一下博客的titile，subtitle，author，改成你自己个性化的），将deployment模块里面的代码替换为如下： 1234deploy: type: git repository: https://github.com/用户名/用户名.github.io.git # 将用户名替换为你自己的github用户名 branch: master 特别提醒：每个分号:后都要有一个空格，不然接下来生成和部署博客到github上时会报下面这种错误： 1JS-YAML: bad indentation of a mapping entry at line , column （3）进到博客根目录下，先执行 1$ hexo generate # 或者：hexo g 生成静态页面至public目录 如出现报错 12ERROR Local hexo not found in ~/blogERROR Try runing: 'npm install hexo --save' 则执行： 1$ npm install hexo --save 再执行： 1$ hexo deploy # 或者：hexo -g 将.deploy目录部署到GitHub 如果无法连接到git,则执行： 1$ npm install hexo-deployer-git --save # 安装hexo-deployer-git 最后再执行： 12$ hexo g$ hexo d （4）进到浏览器，打开http://用户名.github.io网址，就可以看到和之前本地看到的hexo默认主题的首页，看到你修改好的博客title，subtitle，author，等。至此，和github的关联已经建立好，接下来就可以写博客了 写博客写博客主要使用到几个命令： 12$ hexo new "postName" # 新建文章 默认在\source\_posts\postName.md文件夹下$ hexo new page "pageName" #新建页面，如关于我界面 新建后，在source文件目录下生成一个以postName命名的.md文件，直接用markdown语法编辑，写文章就是这么简单。hexo可以将markdown语法的文件渲染成静态的HTML。关于markdown语法，非常简单，上手很快，可以上网去搜一下语法Markdown 语法说明 (简体中文版) $ hexo clean # 删除之前生成的public文件夹和缓存数据 $ hexo g # 重新生成博客文件 $ hexo d # 将修改同步到github远程仓库 换主题，个性化配置1.更换主题进入hexo相关主题展示的theme网站,选取一款你喜欢的主题。将你喜欢的主题clone到themes文件夹下，我选的是jacman主题，直接编辑主目录下的_config.yml配置文件，找到theme,将默认的主题换成你喜欢的主题名即可 2.配置主题样式换完主题后，就可以修改主题样式了，我以我的jacman主题为例，主要修改主配置文件_config.yml以及主题文件下的配置文件_config.yml，我把底部的作者介绍给删掉了，然后右边的展示插件widget，我添加了分类，标签，归档，标签云，友情链接这几项。 3.添加第三方评论系统我使用的是多说，直接注册，然后获取到duoshuo_shortname，填到jacman主题下面配置文件_config.yml对应的地方，第三方评论系统就安装好了 4.其他还有些站内搜索和流量统计等功能的配置，直接参考jacman主题的配置说明和介绍，里面很详细 申请域名并绑定1.申请如果向像我的博客一样，有一个独立、专属的个性化域名，那么就需要去购买一个，然后和用户名.github.io这个网址进行绑定就可以了，购买域名推荐GoDaddy，不用备案，支持支付宝付款，购买完成后去到域名管理中心，给域名添加一条A记录，指向github的主机地址。 2.绑定在/themes/你的主题/source目录下新建一个文件，文件名为CNAME,编辑这个文件，将你之前申请的域名填入到这个文件里.然后打开命令行,cd 到博客目录 $ hexo clean $ hexo g $ hexo d 一切做好后，在浏览器里输入你的个性域名，就可以访问到你的博客了 迁移到GitCafe由于github是国外的网址，服务器在国外，国内这边访问起来比较慢，若向提高网站的访问速度，一般的替代解决方案是把博客部署到gitcafe上来 主要参考资料 [BetterExplained]为什么你应该（从现在开始就）写博客 趣谈个人建站 作为码农，我们为什么要写作 技术人员如何坚持写作 Mac上搭建基于GitHub的Hexo博客 如何生成SSH key 从 Octopress 迁移到 Hexo hexo+github搭建个人博客 hexo你的博客 大道至简——Hexo简洁主题推荐 极客学院Wiki社区hexo问题解答]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016香港马拉松总结]]></title>
    <url>%2F2016%2F01%2F13%2F2016%E9%A6%99%E6%B8%AF%E9%A9%AC%E6%8B%89%E6%9D%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[上周末去参加了2016香港渣打马拉松，休息一礼拜后，身体基本都恢复了，正好周末不加班，又是雨雪冷天，精力过剩，so随便写写，记录一下这次旅程，无病呻吟也好，流水账也好，至少用写，顶住忘记。 为什么想去参加？首先回答一下这个问题。第一，因为工作在深圳，靠近香港，而且香港马拉松算是亚洲数一数二有名的马拉松赛事了，作为一个马拉松爱好者，必定心驰神往。第二，2016正好是香港马拉松20周年，无意中在facebook上看到了陈奕迅演唱的赛会主题曲《人生马拉松》MV，很受感动，参加了肯定很有纪念意义。好吧，我是个偏感性的人。最后，也是最重要的原因，刚刚毕业，来到大城市，有些迷茫，有些浮躁，有些戾气赶不走，需要一个具象的目标来消化，2016香港马拉松无疑是我能想到的并且适合我的最好的方式。新鲜而又富有挑战性。 九月份，报名。看攻略，演练报名情景，只为点击的时候能比别人快那么零点几秒。发现支付只支持信用卡，需要有带visa或者万事达标志的那种，于是调休了半天跑了深圳的招行，建行，工行，申请办理那种信用卡，但是都是以没有社保或者缴纳社保不够时长为由被拒绝。被拒绝的时候，感觉自己too young too simple ! 好吧，那时我只是个可怜的试用期员工，还享受不到大城市的社保的福利，就是能办等审批下来也来不及了……求助朋友吧，最后还是长跑俱乐部的一个学长帮到了我。一如近几年国内的马拉松报名，必须用抢的，但是幸好不像深圳马拉松那样报上了还要抽签摇号，是先到先得。早晨七点准时开抢，根据以往几年的经验，我选择了去网吧，不到六点起床，找了一台网速给力，配置给力的机子，当然价格也贵，怀念高中一块钱一个小时的网吧。买了VPN，配置了翻墙（后面发现其实不用，没有被墙）感觉一切准备就绪了，我对着香港时间倒计着秒数，我以为我会很快，等真正点进去的时候发现排到了3000多名，幸运的是最后还是进去了，填了资料，用学长朋友的信用卡刷了350港币。报名成功了！ 十月，十一月，十二月份，训练。其实很惭愧，真正没怎么训练到。毕业后，时间就不是自己的了，断断续续，特别是当我知道和我同时进来的两个做andriod开发的哥们被开了以后，更有危机感。这个时候，生存问题大于一切。但是，也做了一件让自己开心的事情，国庆放假，我花了5天时间搭了一个属于自己的技术博客站点，虽然排版还很粗糙，虽然还没有集成评论分享系统，还没有站内搜索，没做seo，没有数据统计功能，但是相对于这些，走心，优质的内容才是最最重要的，我希望在未来的日子里，它能够帮助我记录我技术成长的点点滴滴。我相信这是一个美好的开始，因为我信仰文字的力量。在这个过程中，我认识了很多业内的大牛和榜样，发现了很多有意思的事情，虽然他们当中没有一个认识我这个无名小卒。我读他们的博客，能够找到很多相似的情感投射和共鸣，这就够了。他们很多时候也孤独，却不无趣，我想有趣才是最高程度的优秀吧！技术应该是有趣的吧，至少可以让他变得有趣！ 说说工作吧，目前在深圳就职于一家互联网行业的创业公司，节奏很快，产品很多，感觉还行，按照某个大牛的话说，这种公司是我们这些初级程序员的锻炼基地，应该好好珍惜。刚进去，首先做的工作是维护之前的旧项目，其实主要是在改bug,，也是很多不懂，项目的技术规范和技术架构不熟悉，找个文件或是变量都要找半天，效率很低，说实话，那段时间很痛苦，但幸好熬过去了。国庆节后就开始做新项目了，一个很小的商家APP，我们三个人做iOS平台，都是90后，其中还有一妹子（这在程序员群体里面是多么的难得），相处配合的都很好，也是在那个项目做完后，谢天谢地，顺利的转正了。十一月初参与了一个理财类APP的改版工作，那个项目的一期代码写的非常规范，项目结构很清晰，是我们公司一个30多岁的技术大牛担任项目经理做的，所以改版任务挺轻松的就完成了，这次改版工作让我学到了团队开发遵从一定的技术规范和标准是多么重要的一件事情，做团队开发的技术人员需要有团队思维。十一月末到现在，都是在做一个团购APP的开发和后期迭代工作，是要给泰国那边事业部去运营的，而我在想，是不是把活做漂亮了，就有机会去泰国看看人妖啥的（梦想还是要有的，万一大Boss给我们实现了呢？哈哈。。）。这段时间也是我们团队最稳定的一段时期。嗯嗯，活儿一定要做好！ 要归正传。训练，多少我还是有训练的，虽然训练次数和训练强度都不能和大学时期相提并论了。最初，住在西乡，我就坐两个地铁站去宝安体育馆跑步，绕着那个体育馆跑，一圈大约600到700米，哪里好多人，而且经常有哪些街头乐队在表演，像是在给我们这些跑步的在加油鼓励，只是那边每晚不到十点就闭馆，每次都只能跑个5公里左右，塞牙缝都不够。后面搬到民治了，这边上班更近了，每天早上可以睡到八点都不会迟到，刚搬来的时候，我去过几次深圳北大草坪，那里夜跑的人也很多，只是那里的赛道很拥挤，而且路很不平，伤膝盖，后面我就没去了，因为接下来我发现了一个新的更好的跑步地点，那就是深圳莲花山公园，哪里盛开了很多深圳的市花——簕杜鹃，非常漂亮。据说每次国家领导人来深圳都会来这个公园，因为山上面有一个邓小平爷爷的铜像，我妈来深圳的时候，我还带她上去过，不高，铜像周围簇拥着很多敬献的花篮，山上可以俯瞰一下深圳的夜景，也是很漂亮，很多广告片或是影视剧取景都常来这里，我还亲身碰到过一次。铜像下面的墙壁上铿锵有力的写着几个邓公的题词——深圳的发展和经验证明，我们建立经济特区的政策是正确的！在莲花山公园跑步，既可以跑长距离，绕外圈一次大约5公里，也可以短距离，绕着中央的湖一圈跑大约1.2公里，还有一些有坡度的跑道，可以模拟练习马拉松的上下坡赛道，这里的森林覆盖率也很高，氧气很足，洗肺充分。湖光山色，鸟语花香，跑步在这里就是一种大自然的享受。 一月份，比赛。第一次去香港，在不影响项目开发进度的情况下，调了一天休，一月十五号准备了一天，换了个深圳的号码，全球通，因为泉州的号在香港不能用了，而且要开通港澳台服务的话需要本人携带证件到泉州营业厅去办理，相当麻烦，不然我是不情愿换号的。晚上在携程上订了一间较便宜的房间，靠近起点尖沙咀，也要300多， 选了离自己最近的福田口岸通关，看攻略上说年底了又是周末很多大陆游客会去香港购物，本以为通关要花很长的时间，结果那天没感觉排了很长的队就顺利出关了，可能是天气不太好吧，大家都不太愿意出门，哈哈。在福田口岸，将自己的L签转了G签，换了几百港币，买了张八达通卡，就开始乘坐港铁了，东铁转西铁，在地铁里看到那些红磡，铜锣湾，尖沙咀什么的站的时候，还有那种很高的双层巴士，好像有一种穿越到香港电影或是TVB剧的感觉，太酷了！可见文化的入侵比什么都来的猛烈。噢，好像不能讲入侵，应该讲融合。 来到香港的第一站是维多利亚公园，也是这次马拉松的终点，一月16号，海外选手需要在这里来领取参赛的包裹，海外？对，对于香港人而言，我就是海外选手。 但不得不说，组织的真的很有秩序，完全不乱，也不用等很久就能领到包裹，里面有参赛服，号码牌（计时芯片绑定在号码牌背面），参赛说明，还有一些广告传单。他们的志愿者大多能用粤语，国语，英语三门语言来维持秩序，也挺有礼貌的，对比之下，感觉内地的一些马拉松赛事服务质量确实还有提升的空间。在香港吃了中餐和晚餐，普通的扬州炒饭和一个什么鸡肉套餐，花了将近100港币，真不便宜。一切准备妥当后，开始睡觉，我以为我能睡着，结果只睡了两个小时，后面就在思考人生了，，，，四点起床，吃早餐，赶到起点，存包，热身，重复着之前跑马拉松都会重复的工作，不同的是，开跑前十分钟，天空突然噼里啪啦的下起大雨来，但好像并没有减弱大家的热情，人群反而更兴奋了，6点45，开跑，大家都蜂拥而出，一群人一起跑步的感觉就是，就算你不high，也会被带high的。一开始我混在人群中自由自在地跑着，任由周边的人一个一个超过我，因为过去的参赛经验告诉我，开头我不能跑太快，否则会死的很惨，我看得出来，他们中有高手，也有菜鸟，但我不会拉住某个要超过我的那个看起来像菜鸟的选手，告诉他，你应该跑慢点，不然后面你会死的很惨。第一，那会显得很傻逼，第二因为我曾经也是菜鸟，一切都需要靠自己的领悟和体验。遵从少量多次的补水原则，我安全地跑到了30公里。三十公里前，当我跑步时，我在想些什么呢？我在想，这雨什么时候能停，我在想，这赛道为什么这么难跑，基本都是在桥上，环形公路造成的高低脚，让人很难受。三十公里后，我吃了大量的香蕉和巧克力，因为可以快速补充能量，更因为这里是所有马拉松运动员的一个关口，生理极限，全体都有，黑人也不列外。人体储藏的肝糖原和肌糖原在这里全部分解完了，人体各项机能达到最低点，大脑开始调配脂肪供给能量，只是中间有段过渡期，有些人长有些人短而已，撑不过的就叫撞墙了。我知道我今年练得不够，加上魔鬼赛道和下雨，撞墙在所难免。所以，三十公里后，我在想些什么呢？我在想这该死的过渡期怎么还过不去？该死的脂肪怎么还不分解供能？我在预支跑完后的心情，拿着奖牌，拍着照，又一次成功的挑战了自己，可喜可贺。公里数在我心里也由已经跑了多少公里变成了了仅有几公里。没有大的不同，但是这些心里的微妙变化在跑马的心路历程中却显得特别的有趣，我想把他记录下来而已。 所以这就是亚洲第一魔鬼赛道，三座大桥，三条隧道，最后两公里还要过个几百米的天桥，就是要让你不舒服。总是将人生比作马拉松，或许我还没完全理解，但是在试着慢慢地去理解。 2016，期许。戒奢戒躁，技术上有提高。不作恶。跑步，读书，享受音乐。一个人固然寂寞，两个人孤灯下无言相对却可以更寂寞。他之蜜糖，我之砒霜。。。 PS：不能再写了，夜已深，发现越来越感性了，真是精力过剩，写了一堆废话，删了又可惜，，，能看到这里的都真爱。]]></content>
      <categories>
        <category>生活</category>
        <category>马拉松</category>
      </categories>
      <tags>
        <tag>马拉松</tag>
      </tags>
  </entry>
</search>
